*javax.swing.JTable* *JTable* The JTable is used to display and edit regular two-dimensional tables
 of cells.

public class JTable
  extends    |javax.swing.JComponent|
  implements |javax.swing.event.TableModelListener|
             |javax.swing.Scrollable|
             |javax.swing.event.TableColumnModelListener|
             |javax.swing.event.ListSelectionListener|
             |javax.swing.event.CellEditorListener|
             |javax.accessibility.Accessible|

|javax.swing.JTable_Description|
|javax.swing.JTable_Fields|
|javax.swing.JTable_Constructors|
|javax.swing.JTable_Methods|

====================================================================================================================================================================================

*javax.swing.JTable_Fields*
|int_javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS|
|int_javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN|
|int_javax.swing.JTable.AUTO_RESIZE_NEXT_COLUMN|
|int_javax.swing.JTable.AUTO_RESIZE_OFF|
|int_javax.swing.JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS|
|boolean_javax.swing.JTable.autoCreateColumnsFromModel|
|int_javax.swing.JTable.autoResizeMode|
|javax.swing.table.TableCellEditor_javax.swing.JTable.cellEditor|
|boolean_javax.swing.JTable.cellSelectionEnabled|
|javax.swing.table.TableColumnModel_javax.swing.JTable.columnModel|
|javax.swing.table.TableModel_javax.swing.JTable.dataModel|
|java.util.Hashtable_javax.swing.JTable.defaultEditorsByColumnClass|
|java.util.Hashtable_javax.swing.JTable.defaultRenderersByColumnClass|
|int_javax.swing.JTable.editingColumn|
|int_javax.swing.JTable.editingRow|
|java.awt.Component_javax.swing.JTable.editorComp|
|java.awt.Color_javax.swing.JTable.gridColor|
|java.awt.Dimension_javax.swing.JTable.preferredViewportSize|
|int_javax.swing.JTable.rowHeight|
|int_javax.swing.JTable.rowMargin|
|boolean_javax.swing.JTable.rowSelectionAllowed|
|java.awt.Color_javax.swing.JTable.selectionBackground|
|java.awt.Color_javax.swing.JTable.selectionForeground|
|javax.swing.ListSelectionModel_javax.swing.JTable.selectionModel|
|boolean_javax.swing.JTable.showHorizontalLines|
|boolean_javax.swing.JTable.showVerticalLines|
|javax.swing.table.JTableHeader_javax.swing.JTable.tableHeader|

*javax.swing.JTable_Constructors*
|javax.swing.JTable()|Constructs a default JTable that is initialized with a default  data model, a default column model, and a default selection  model.
|javax.swing.JTable(int,int)|Constructs a JTable with numRows  and numColumns of empty cells using  DefaultTableModel.
|javax.swing.JTable(Object[][],Object[])|Constructs a JTable to display the values in the two dimensional array,  rowData, with column names, columnNames.
|javax.swing.JTable(TableModel)|Constructs a JTable that is initialized with  dm as the data model, a default column model,  and a default selection model.
|javax.swing.JTable(TableModel,TableColumnModel)|Constructs a JTable that is initialized with  dm as the data model, cm  as the column model, and a default selection model.
|javax.swing.JTable(TableModel,TableColumnModel,ListSelectionModel)|Constructs a JTable that is initialized with  dm as the data model, cm as the  column model, and sm as the sele
|javax.swing.JTable(Vector,Vector)|Constructs a JTable to display the values in the  Vector of Vectors, rowData,  with column names, columnNames.

*javax.swing.JTable_Methods*
|javax.swing.JTable.addColumn(TableColumn)|Appends aColumn to the end of the array of columns held by   this JTable's column model.
|javax.swing.JTable.addColumnSelectionInterval(int,int)|Adds the columns from index0 to index1,  inclusive, to the current selection.
|javax.swing.JTable.addNotify()|Calls the configureEnclosingScrollPane method.
|javax.swing.JTable.addRowSelectionInterval(int,int)|Adds the rows from index0 to index1, inclusive, to  the current selection.
|javax.swing.JTable.changeSelection(int,int,boolean,boolean)|Updates the selection models of the table, depending on the state of the  two flags: toggle and extend.
|javax.swing.JTable.clearSelection()|Deselects all selected columns and rows.
|javax.swing.JTable.columnAdded(TableColumnModelEvent)|Invoked when a column is added to the table column model.
|javax.swing.JTable.columnAtPoint(Point)|Returns the index of the column that point lies in,  or -1 if the result is not in the range  [0, getColumnCount()-1].
|javax.swing.JTable.columnMarginChanged(ChangeEvent)|Invoked when a column is moved due to a margin change.
|javax.swing.JTable.columnMoved(TableColumnModelEvent)|Invoked when a column is repositioned.
|javax.swing.JTable.columnRemoved(TableColumnModelEvent)|Invoked when a column is removed from the table column model.
|javax.swing.JTable.columnSelectionChanged(ListSelectionEvent)|Invoked when the selection model of the TableColumnModel  is changed.
|javax.swing.JTable.configureEnclosingScrollPane()|If this JTable is the viewportView of an enclosing JScrollPane  (the usual situation), configure this ScrollPane by, amongst oth
|javax.swing.JTable.convertColumnIndexToModel(int)|Maps the index of the column in the view at  viewColumnIndex to the index of the column  in the table model.
|javax.swing.JTable.convertColumnIndexToView(int)|Maps the index of the column in the table model at  modelColumnIndex to the index of the column  in the view.
|javax.swing.JTable.createDefaultColumnModel()|Returns the default column model object, which is  a DefaultTableColumnModel.
|javax.swing.JTable.createDefaultColumnsFromModel()|Creates default columns for the table from  the data model using the getColumnCount method  defined in the TableModel interface
|javax.swing.JTable.createDefaultDataModel()|Returns the default table model object, which is  a DefaultTableModel.
|javax.swing.JTable.createDefaultEditors()|Creates default cell editors for objects, numbers, and boolean values.
|javax.swing.JTable.createDefaultRenderers()|Creates default cell renderers for objects, numbers, doubles, dates,  booleans, and icons.
|javax.swing.JTable.createDefaultSelectionModel()|Returns the default selection model object, which is  a DefaultListSelectionModel.
|javax.swing.JTable.createDefaultTableHeader()|Returns the default table header object, which is  a JTableHeader.
|javax.swing.JTable.createScrollPaneForTable(JTable)|Equivalent to new JScrollPane(aTable).
|javax.swing.JTable.doLayout()|Causes this table to lay out its rows and columns.
|javax.swing.JTable.editCellAt(int,int)|Programmatically starts editing the cell at row and  column, if those indices are in the valid range, and  the cell at those indices is edi
|javax.swing.JTable.editCellAt(int,int,EventObject)|Programmatically starts editing the cell at row and  column, if those indices are in the valid range, and  the cell at those in
|javax.swing.JTable.editingCanceled(ChangeEvent)|Invoked when editing is canceled.
|javax.swing.JTable.editingStopped(ChangeEvent)|Invoked when editing is finished.
|javax.swing.JTable.getAccessibleContext()|Gets the AccessibleContext associated with this JTable.
|javax.swing.JTable.getAutoCreateColumnsFromModel()|Determines whether the table will create default columns from the model.
|javax.swing.JTable.getAutoResizeMode()|Returns the auto resize mode of the table.
|javax.swing.JTable.getCellEditor()|Returns the active cell editor, which isnullif the table  is not currently editing.
|javax.swing.JTable.getCellEditor(int,int)|Returns an appropriate editor for the cell specified by  row and column.
|javax.swing.JTable.getCellRect(int,int,boolean)|Returns a rectangle for the cell that lies at the intersection of  row and column.
|javax.swing.JTable.getCellRenderer(int,int)|Returns an appropriate renderer for the cell specified by this row and  column.
|javax.swing.JTable.getCellSelectionEnabled()|Returns true if both row and column selection models are enabled.
|javax.swing.JTable.getColumn(Object)|Returns the TableColumn object for the column in the table  whose identifier is equal to identifier, when compared using  equals.
|javax.swing.JTable.getColumnClass(int)|Returns the type of the column appearing in the view at  column position column.
|javax.swing.JTable.getColumnCount()|Returns the number of columns in the column model.
|javax.swing.JTable.getColumnModel()|Returns the TableColumnModel that contains all column information  of this table.
|javax.swing.JTable.getColumnName(int)|Returns the name of the column appearing in the view at  column position column.
|javax.swing.JTable.getColumnSelectionAllowed()|Returns true if columns can be selected.
|javax.swing.JTable.getDefaultEditor(Class<?>)|Returns the editor to be used when no editor has been set in  a TableColumn.
|javax.swing.JTable.getDefaultRenderer(Class<?>)|Returns the cell renderer to be used when no renderer has been set in  a TableColumn.
|javax.swing.JTable.getDragEnabled()|Gets the value of the dragEnabled property.
|javax.swing.JTable.getEditingColumn()|Returns the index of the column that contains the cell currently  being edited.
|javax.swing.JTable.getEditingRow()|Returns the index of the row that contains the cell currently  being edited.
|javax.swing.JTable.getEditorComponent()|Returns the component that is handling the editing session.
|javax.swing.JTable.getGridColor()|Returns the color used to draw grid lines.
|javax.swing.JTable.getIntercellSpacing()|Returns the horizontal and vertical space between cells.
|javax.swing.JTable.getModel()|Returns the TableModel that provides the data displayed by this  JTable.
|javax.swing.JTable.getPreferredScrollableViewportSize()|Returns the preferred size of the viewport for this table.
|javax.swing.JTable.getPrintable(JTable.PrintMode,MessageFormat,MessageFormat)|Return a Printable for use in printing this JTable.
|javax.swing.JTable.getRowCount()|Returns the number of rows in this table's model.
|javax.swing.JTable.getRowHeight()|Returns the height of a table row, in pixels.
|javax.swing.JTable.getRowHeight(int)|Returns the height, in pixels, of the cells in row.
|javax.swing.JTable.getRowMargin()|Gets the amount of empty space, in pixels, between cells.
|javax.swing.JTable.getRowSelectionAllowed()|Returns true if rows can be selected.
|javax.swing.JTable.getScrollableBlockIncrement(Rectangle,int,int)|Returns visibleRect.height or  visibleRect.width,  depending on this table's orientation.
|javax.swing.JTable.getScrollableTracksViewportHeight()|Returns false to indicate that the height of the viewport does not  determine the height of the table.
|javax.swing.JTable.getScrollableTracksViewportWidth()|Returns false if autoResizeMode is set to  AUTO_RESIZE_OFF, which indicates that the  width of the viewport does not determi
|javax.swing.JTable.getScrollableUnitIncrement(Rectangle,int,int)|Returns the scroll increment (in pixels) that completely exposes one new  row or column (depending on the orienta
|javax.swing.JTable.getSelectedColumn()|Returns the index of the first selected column,  -1 if no column is selected.
|javax.swing.JTable.getSelectedColumnCount()|Returns the number of selected columns.
|javax.swing.JTable.getSelectedColumns()|Returns the indices of all selected columns.
|javax.swing.JTable.getSelectedRow()|Returns the index of the first selected row, -1 if no row is selected.
|javax.swing.JTable.getSelectedRowCount()|Returns the number of selected rows.
|javax.swing.JTable.getSelectedRows()|Returns the indices of all selected rows.
|javax.swing.JTable.getSelectionBackground()|Returns the background color for selected cells.
|javax.swing.JTable.getSelectionForeground()|Returns the foreground color for selected cells.
|javax.swing.JTable.getSelectionModel()|Returns the ListSelectionModel that is used to maintain row  selection state.
|javax.swing.JTable.getShowHorizontalLines()|Returns true if the table draws horizontal lines between cells, false if it  doesn't.
|javax.swing.JTable.getShowVerticalLines()|Returns true if the table draws vertical lines between cells, false if it  doesn't.
|javax.swing.JTable.getSurrendersFocusOnKeystroke()|Returns true if the editor should get the focus  when keystrokes cause the editor to be activated
|javax.swing.JTable.getTableHeader()|Returns the tableHeader used by this JTable.
|javax.swing.JTable.getToolTipText(MouseEvent)|Overrides JComponent's getToolTipText  method in order to allow the renderer's tips to be used  if it has text set.
|javax.swing.JTable.getUI()|Returns the Lobject that renders this component.
|javax.swing.JTable.getUIClassID()|Returns the suffix used to construct the name of the Lclass used to  render this component.
|javax.swing.JTable.getValueAt(int,int)|Returns the cell value at row and column.
|javax.swing.JTable.initializeLocalVars()|Initializes table properties to their default values.
|javax.swing.JTable.isCellEditable(int,int)|Returns true if the cell at row and column  is editable.
|javax.swing.JTable.isCellSelected(int,int)|Returns true if the specified indices are in the valid range of rows  and columns and the cell at the specified position is selected.
|javax.swing.JTable.isColumnSelected(int)|Returns true if the specified index is in the valid range of columns,  and the column at that index is selected.
|javax.swing.JTable.isEditing()|Returns true if a cell is being edited.
|javax.swing.JTable.isRowSelected(int)|Returns true if the specified index is in the valid range of rows,  and the row at that index is selected.
|javax.swing.JTable.moveColumn(int,int)|Moves the column column to the position currently  occupied by the column targetColumn in the view.
|javax.swing.JTable.paramString()|Returns a string representation of this table.
|javax.swing.JTable.prepareEditor(TableCellEditor,int,int)|Prepares the editor by querying the data model for the value and  selection state of the cell at row, column.
|javax.swing.JTable.prepareRenderer(TableCellRenderer,int,int)|Prepares the renderer by querying the data model for the  value and selection state  of the cell at row, column.
|javax.swing.JTable.print()|A convenience method that displays a printing dialog, and then prints  this JTable in mode PrintMode.FIT_WIDTH,  with no header or footer text.
|javax.swing.JTable.print(JTable.PrintMode)|A convenience method that displays a printing dialog, and then prints  this JTable in the given printing mode,  with no header or foote
|javax.swing.JTable.print(JTable.PrintMode,MessageFormat,MessageFormat)|A convenience method that displays a printing dialog, and then prints  this JTable in the given printing mo
|javax.swing.JTable.print(JTable.PrintMode,MessageFormat,MessageFormat,boolean,PrintRequestAttributeSet,boolean)|Print this JTable.
|javax.swing.JTable.processKeyBinding(KeyStroke,KeyEvent,int,boolean)|
|javax.swing.JTable.removeColumn(TableColumn)|Removes aColumn from this JTable's   array of columns.
|javax.swing.JTable.removeColumnSelectionInterval(int,int)|Deselects the columns from index0 to index1, inclusive.
|javax.swing.JTable.removeEditor()|Discards the editor object and frees the real estate it used for  cell rendering.
|javax.swing.JTable.removeNotify()|Calls the unconfigureEnclosingScrollPane method.
|javax.swing.JTable.removeRowSelectionInterval(int,int)|Deselects the rows from index0 to index1, inclusive.
|javax.swing.JTable.resizeAndRepaint()|Equivalent to revalidate followed by repaint.
|javax.swing.JTable.rowAtPoint(Point)|Returns the index of the row that point lies in,  or -1 if the result is not in the range  [0, getRowCount()-1].
|javax.swing.JTable.selectAll()|Selects all rows, columns, and cells in the table.
|javax.swing.JTable.setAutoCreateColumnsFromModel(boolean)|Sets this table's autoCreateColumnsFromModel flag.
|javax.swing.JTable.setAutoResizeMode(int)|Sets the table's auto resize mode when the table is resized.
|javax.swing.JTable.setCellEditor(TableCellEditor)|Sets the active cell editor.
|javax.swing.JTable.setCellSelectionEnabled(boolean)|Sets whether this table allows both a column selection and a  row selection to exist simultaneously.
|javax.swing.JTable.setColumnModel(TableColumnModel)|Sets the column model for this table to newModel and registers  for listener notifications from the new column model.
|javax.swing.JTable.setColumnSelectionAllowed(boolean)|Sets whether the columns in this model can be selected.
|javax.swing.JTable.setColumnSelectionInterval(int,int)|Selects the columns from index0 to index1,  inclusive.
|javax.swing.JTable.setDefaultEditor(Class<?>,TableCellEditor)|Sets a default cell editor to be used if no editor has been set in  a TableColumn.
|javax.swing.JTable.setDefaultRenderer(Class<?>,TableCellRenderer)|Sets a default cell renderer to be used if no renderer has been set in  a TableColumn.
|javax.swing.JTable.setDragEnabled(boolean)|Sets the dragEnabled property,  which must be true to enable  automatic drag handling (the first part of drag and drop)  on this compon
|javax.swing.JTable.setEditingColumn(int)|Sets the editingColumn variable.
|javax.swing.JTable.setEditingRow(int)|Sets the editingRow variable.
|javax.swing.JTable.setGridColor(Color)|Sets the color used to draw grid lines to gridColor and redisplays.
|javax.swing.JTable.setIntercellSpacing(Dimension)|Sets the rowMargin and the columnMargin --  the height and width of the space between cells -- to  intercellSpacing.
|javax.swing.JTable.setModel(TableModel)|Sets the data model for this table to newModel and registers  with it for listener notifications from the new data model.
|javax.swing.JTable.setPreferredScrollableViewportSize(Dimension)|Sets the preferred size of the viewport for this table.
|javax.swing.JTable.setRowHeight(int)|Sets the height, in pixels, of all cells to rowHeight,  revalidates, and repaints.
|javax.swing.JTable.setRowHeight(int,int)|Sets the height for row to rowHeight,  revalidates, and repaints.
|javax.swing.JTable.setRowMargin(int)|Sets the amount of empty space between cells in adjacent rows.
|javax.swing.JTable.setRowSelectionAllowed(boolean)|Sets whether the rows in this model can be selected.
|javax.swing.JTable.setRowSelectionInterval(int,int)|Selects the rows from index0 to index1,  inclusive.
|javax.swing.JTable.setSelectionBackground(Color)|Sets the background color for selected cells.
|javax.swing.JTable.setSelectionForeground(Color)|Sets the foreground color for selected cells.
|javax.swing.JTable.setSelectionMode(int)|Sets the table's selection mode to allow only single selections, a single  contiguous interval, or multiple intervals.
|javax.swing.JTable.setSelectionModel(ListSelectionModel)|Sets the row selection model for this table to newModel  and registers for listener notifications from the new selection 
|javax.swing.JTable.setShowGrid(boolean)|Sets whether the table draws grid lines around cells.
|javax.swing.JTable.setShowHorizontalLines(boolean)|Sets whether the table draws horizontal lines between cells.
|javax.swing.JTable.setShowVerticalLines(boolean)|Sets whether the table draws vertical lines between cells.
|javax.swing.JTable.setSurrendersFocusOnKeystroke(boolean)|Sets whether editors in this JTable get the keyboard focus  when an editor is activated as a result of the JTable  forwa
|javax.swing.JTable.setTableHeader(JTableHeader)|Sets the tableHeader working with this JTable to newHeader.
|javax.swing.JTable.setUI(TableUI)|Sets the Lobject that renders this component and repaints.
|javax.swing.JTable.setValueAt(Object,int,int)|Sets the value for the cell in the table model at row  and column.
|javax.swing.JTable.sizeColumnsToFit(boolean)|Sizes the table columns to fit the available space.
|javax.swing.JTable.sizeColumnsToFit(int)|Obsolete as of Java 2 platform v1.4.
|javax.swing.JTable.tableChanged(TableModelEvent)|Invoked when this table's TableModel generates  a TableModelEvent.
|javax.swing.JTable.unconfigureEnclosingScrollPane()|Reverses the effect of configureEnclosingScrollPane  by replacing the columnHeaderView of the enclosing  scroll pane with null
|javax.swing.JTable.updateUI()|Notification from the UIManager that the Lhas changed.
|javax.swing.JTable.valueChanged(ListSelectionEvent)|Invoked when the row selection changes -- repaints to show the new  selection.

*javax.swing.JTable_Description*

The JTable is used to display and edit regular two-dimensional tables of cells. See How to Use Tables in The Java Tutorial for task-oriented documentation and examples of using 
JTable. 

The JTable has many facilities that make it possible to customize its rendering and editing but provides defaults for these features so that simple tables can be set up easily. 
For example, to set up a table with 10 rows and 10 columns of numbers: 



TableModel dataModel = new AbstractTableModel() { public int getColumnCount() { return 10; } public int getRowCount() { return 10;} public Object getValueAt(int row, int col) { 
return new Integer(row*col); } }; JTable table = new JTable(dataModel); JScrollPane scrollpane = new JScrollPane(table); 

Note that if you wish to use a JTable in a standalone view (outside of a JScrollPane) and want the header displayed, you can get it using (|javax.swing.JTable|) and display it 
separately. 

When designing applications that use the JTable it is worth paying close attention to the data structures that will represent the table's data. The DefaultTableModel is a model 
implementation that uses a Vector of Vectors of Objects to store the cell values. As well as copying the data from an application into the DefaultTableModel, it is also possible 
to wrap the data in the methods of the TableModel interface so that the data can be passed to the JTable directly, as in the example above. This often results in more efficient 
applications because the model is free to choose the internal representation that best suits the data. A good rule of thumb for deciding whether to use the AbstractTableModel or 
the DefaultTableModel is to use the AbstractTableModel as the base class for creating subclasses and the DefaultTableModel when subclassing is not required. 

The "TableExample" directory in the demo area of the source distribution gives a number of complete examples of JTable usage, covering how the JTable can be used to provide an 
editable view of data taken from a database and how to modify the columns in the display to use specialized renderers and editors. 

The JTable uses integers exclusively to refer to both the rows and the columns of the model that it displays. The JTable simply takes a tabular range of cells and uses 
getValueAt(int, int) to retrieve the values from the model during painting. 

By default, columns may be rearranged in the JTable so that the view's columns appear in a different order to the columns in the model. This does not affect the implementation of 
the model at all: when the columns are reordered, the JTable maintains the new order of the columns internally and converts its column indices before querying the model. 

So, when writing a TableModel, it is not necessary to listen for column reordering events as the model will be queried in its own coordinate system regardless of what is happening 
in the view. In the examples area there is a demonstration of a sorting algorithm making use of exactly this technique to interpose yet another coordinate system where the order 
of the rows is changed, rather than the order of the columns. 

J2SE 5 adds methods to JTable to provide convenient access to some common printing needs. Simple new (|javax.swing.JTable|) methods allow for quick and easy addition of printing 
support to your application. In addition, a new (|javax.swing.JTable|) method is available for more advanced printing needs. 

As for all JComponent classes, you can use (|javax.swing.InputMap|) and (|javax.swing.ActionMap|) to associate an (|javax.swing.Action|) object with a (|javax.swing.KeyStroke|) 
and execute the action under specified conditions. 

Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between 
applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansTM has been added to the java.beans package. Please see 
(|java.beans.XMLEncoder|) . 



*int_javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS*

During all resize operations, proportionately resize all columns. 


*int_javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN*

During all resize operations, apply adjustments to the last column only. 


*int_javax.swing.JTable.AUTO_RESIZE_NEXT_COLUMN*

When a column is adjusted in the UI, adjust the next column the opposite way. 


*int_javax.swing.JTable.AUTO_RESIZE_OFF*

Do not adjust column widths automatically; use a scrollbar. 


*int_javax.swing.JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS*

During UI adjustment, change subsequent columns to preserve the total width; this is the default behavior. 


*boolean_javax.swing.JTable.autoCreateColumnsFromModel*

The table will query the TableModel to build the default set of columns if this is true. 


*int_javax.swing.JTable.autoResizeMode*

Determines if the table automatically resizes the width of the table's columns to take up the entire width of the table, and how it does the resizing. 


*javax.swing.table.TableCellEditor_javax.swing.JTable.cellEditor*

The active cell editor object, that overwrites the screen real estate occupied by the current cell and allows the user to change its contents.nullif the table isn't currently 
editing. 


*boolean_javax.swing.JTable.cellSelectionEnabled*

Obsolete as of Java 2 platform v1.3. Please use the rowSelectionAllowed property and the columnSelectionAllowed property of the columnModel instead. Or use the method 
getCellSelectionEnabled. 


*javax.swing.table.TableColumnModel_javax.swing.JTable.columnModel*

The TableColumnModel of the table. 


*javax.swing.table.TableModel_javax.swing.JTable.dataModel*

The TableModel of the table. 


*java.util.Hashtable_javax.swing.JTable.defaultEditorsByColumnClass*

A table of objects that display and edit the contents of a cell, indexed by class as declared in getColumnClass in the TableModel interface. 


*java.util.Hashtable_javax.swing.JTable.defaultRenderersByColumnClass*

A table of objects that display the contents of a cell, indexed by class as declared in getColumnClass in the TableModel interface. 


*int_javax.swing.JTable.editingColumn*

Identifies the column of the cell being edited. 


*int_javax.swing.JTable.editingRow*

Identifies the row of the cell being edited. 


*java.awt.Component_javax.swing.JTable.editorComp*

If editing, the Component that is handling the editing. 


*java.awt.Color_javax.swing.JTable.gridColor*

The color of the grid. 


*java.awt.Dimension_javax.swing.JTable.preferredViewportSize*

Used by the Scrollable interface to determine the initial visible area. 


*int_javax.swing.JTable.rowHeight*

The height in pixels of each row in the table. 


*int_javax.swing.JTable.rowMargin*

The height in pixels of the margin between the cells in each row. 


*boolean_javax.swing.JTable.rowSelectionAllowed*

True if row selection is allowed in this table. 


*java.awt.Color_javax.swing.JTable.selectionBackground*

The background color of selected cells. 


*java.awt.Color_javax.swing.JTable.selectionForeground*

The foreground color of selected cells. 


*javax.swing.ListSelectionModel_javax.swing.JTable.selectionModel*

The ListSelectionModel of the table, used to keep track of row selections. 


*boolean_javax.swing.JTable.showHorizontalLines*

The table draws horizontal lines between cells if showHorizontalLines is true. 


*boolean_javax.swing.JTable.showVerticalLines*

The table draws vertical lines between cells if showVerticalLines is true. 


*javax.swing.table.JTableHeader_javax.swing.JTable.tableHeader*

The TableHeader working with the table. 



*javax.swing.JTable()*

public JTable()

Constructs a default JTable that is initialized with a default data model, a default column model, and a default selection model. 


*javax.swing.JTable(int,int)*

public JTable(
  int numRows,
  int numColumns)

Constructs a JTable with numRows and numColumns of empty cells using DefaultTableModel. The columns will have names of the form "A", "B", "C", etc. 

    numRows - the number of rows the table holds 
    numColumns - the number of columns the table holds 

*javax.swing.JTable(Object[][],Object[])*

public JTable(
  java.lang.Object[][] rowData,
  java.lang.Object[] columnNames)

Constructs a JTable to display the values in the two dimensional array, rowData, with column names, columnNames. rowData is an array of rows, so the value of the cell at row 1, 
column 5 can be obtained with the following code: 

rowData[1][5]; 

All rows must be of the same length as columnNames. 

    rowData - the data for the new table 
    columnNames - names of each column 

*javax.swing.JTable(TableModel)*

public JTable(javax.swing.table.TableModel dm)

Constructs a JTable that is initialized with dm as the data model, a default column model, and a default selection model. 

    dm - the data model for the table 

*javax.swing.JTable(TableModel,TableColumnModel)*

public JTable(
  javax.swing.table.TableModel dm,
  javax.swing.table.TableColumnModel cm)

Constructs a JTable that is initialized with dm as the data model, cm as the column model, and a default selection model. 

    dm - the data model for the table 
    cm - the column model for the table 

*javax.swing.JTable(TableModel,TableColumnModel,ListSelectionModel)*

public JTable(
  javax.swing.table.TableModel dm,
  javax.swing.table.TableColumnModel cm,
  javax.swing.ListSelectionModel sm)

Constructs a JTable that is initialized with dm as the data model, cm as the column model, and sm as the selection model. If any of the parameters are null this method will 
initialize the table with the corresponding default model. The autoCreateColumnsFromModel flag is set to false if cm is non-null, otherwise it is set to true and the column model 
is populated with suitable TableColumns for the columns in dm. 

    dm - the data model for the table 
    cm - the column model for the table 
    sm - the row selection model for the table 

*javax.swing.JTable(Vector,Vector)*

public JTable(
  java.util.Vector rowData,
  java.util.Vector columnNames)

Constructs a JTable to display the values in the Vector of Vectors, rowData, with column names, columnNames. The Vectors contained in rowData should contain the values for that 
row. In other words, the value of the cell at row 1, column 5 can be obtained with the following code: 

((Vector)rowData.elementAt(1)).elementAt(5); 



    rowData - the data for the new table 
    columnNames - names of each column 

*javax.swing.JTable.addColumn(TableColumn)*

public void addColumn(javax.swing.table.TableColumn aColumn)

Appends aColumn to the end of the array of columns held by this JTable's column model. If the column name of aColumn is null, sets the column name of aColumn to the name returned 
by getModel().getColumnName(). 

To add a column to this JTable to display the modelColumn'th column of data in the model with a given width, cellRenderer, and cellEditor you can use: 

addColumn(new TableColumn(modelColumn, width, cellRenderer, cellEditor)); 



[Any of the TableColumn constructors can be used instead of this one.] The model column number is stored inside the TableColumn and is used during rendering and editing to locate 
the appropriates data values in the model. The model column number does not change when columns are reordered in the view. 


    aColumn - the TableColumn to be added 

*javax.swing.JTable.addColumnSelectionInterval(int,int)*

public void addColumnSelectionInterval(
  int index0,
  int index1)

Adds the columns from index0 to index1, inclusive, to the current selection. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.addNotify()*

public void addNotify()

Calls the configureEnclosingScrollPane method. 



*javax.swing.JTable.addRowSelectionInterval(int,int)*

public void addRowSelectionInterval(
  int index0,
  int index1)

Adds the rows from index0 to index1, inclusive, to the current selection. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.changeSelection(int,int,boolean,boolean)*

public void changeSelection(
  int rowIndex,
  int columnIndex,
  boolean toggle,
  boolean extend)

Updates the selection models of the table, depending on the state of the two flags: toggle and extend. Most changes to the selection that are the result of keyboard or mouse 
events received by the UI are channeled through this method so that the behavior may be overridden by a subclass. Some UIs may need more functionality than this method provides, 
such as when manipulating the lead for discontiguous selection, and may not call into this method for some selection changes. 

This implementation uses the following conventions: 

toggle: false, extend: false. Clear the previous selection and ensure the new cell is selected. toggle: false, extend: true. Extend the previous selection from the anchor to the 
specified cell, clearing all other selections. toggle: true, extend: false. If the specified cell is selected, deselect it. If it is not selected, select it. toggle: true, extend: 
true. Leave the selection state as it is, but move the anchor index to the specified location. 


    rowIndex - affects the selection at row 
    columnIndex - affects the selection at column 
    toggle - see description above 
    extend - if true, extend the current selection 

*javax.swing.JTable.clearSelection()*

public void clearSelection()

Deselects all selected columns and rows. 



*javax.swing.JTable.columnAdded(TableColumnModelEvent)*

public void columnAdded(javax.swing.event.TableColumnModelEvent e)

Invoked when a column is added to the table column model. 

Application code will not use these methods explicitly, they are used internally by JTable. 



*javax.swing.JTable.columnAtPoint(Point)*

public int columnAtPoint(java.awt.Point point)

Returns the index of the column that point lies in, or -1 if the result is not in the range [0, getColumnCount()-1]. 


    point - the location of interest 

    Returns: the index of the column that point lies in, or -1 if the result is not in the range [0, getColumnCount()-1] 

*javax.swing.JTable.columnMarginChanged(ChangeEvent)*

public void columnMarginChanged(javax.swing.event.ChangeEvent e)

Invoked when a column is moved due to a margin change. If a cell is being edited, then editing is stopped and the cell is redrawn. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 

*javax.swing.JTable.columnMoved(TableColumnModelEvent)*

public void columnMoved(javax.swing.event.TableColumnModelEvent e)

Invoked when a column is repositioned. If a cell is being edited, then editing is stopped and the cell is redrawn. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 

*javax.swing.JTable.columnRemoved(TableColumnModelEvent)*

public void columnRemoved(javax.swing.event.TableColumnModelEvent e)

Invoked when a column is removed from the table column model. 

Application code will not use these methods explicitly, they are used internally by JTable. 



*javax.swing.JTable.columnSelectionChanged(ListSelectionEvent)*

public void columnSelectionChanged(javax.swing.event.ListSelectionEvent e)

Invoked when the selection model of the TableColumnModel is changed. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 

*javax.swing.JTable.configureEnclosingScrollPane()*

protected void configureEnclosingScrollPane()

If this JTable is the viewportView of an enclosing JScrollPane (the usual situation), configure this ScrollPane by, amongst other things, installing the table's tableHeader as the 
columnHeaderView of the scroll pane. When a JTable is added to a JScrollPane in the usual way, using new JScrollPane(myTable), addNotify is called in the JTable (when the table is 
added to the viewport). JTable's addNotify method in turn calls this method, which is protected so that this default installation procedure can be overridden by a subclass. 



*javax.swing.JTable.convertColumnIndexToModel(int)*

public int convertColumnIndexToModel(int viewColumnIndex)

Maps the index of the column in the view at viewColumnIndex to the index of the column in the table model. Returns the index of the corresponding column in the model. If 
viewColumnIndex is less than zero, returns viewColumnIndex. 


    viewColumnIndex - the index of the column in the view 

    Returns: the index of the corresponding column in the model 

*javax.swing.JTable.convertColumnIndexToView(int)*

public int convertColumnIndexToView(int modelColumnIndex)

Maps the index of the column in the table model at modelColumnIndex to the index of the column in the view. Returns the index of the corresponding column in the view; returns -1 
if this column is not being displayed. If modelColumnIndex is less than zero, returns modelColumnIndex. 


    modelColumnIndex - the index of the column in the model 

    Returns: the index of the corresponding column in the view 

*javax.swing.JTable.createDefaultColumnModel()*

protected |javax.swing.table.TableColumnModel| createDefaultColumnModel()

Returns the default column model object, which is a DefaultTableColumnModel. A subclass can override this method to return a different column model object. 



    Returns: the default column model object 

*javax.swing.JTable.createDefaultColumnsFromModel()*

public void createDefaultColumnsFromModel()

Creates default columns for the table from the data model using the getColumnCount method defined in the TableModel interface. 

Clears any existing columns before creating the new columns based on information from the model. 



*javax.swing.JTable.createDefaultDataModel()*

protected |javax.swing.table.TableModel| createDefaultDataModel()

Returns the default table model object, which is a DefaultTableModel. A subclass can override this method to return a different table model object. 



    Returns: the default table model object 

*javax.swing.JTable.createDefaultEditors()*

protected void createDefaultEditors()

Creates default cell editors for objects, numbers, and boolean values. 



*javax.swing.JTable.createDefaultRenderers()*

protected void createDefaultRenderers()

Creates default cell renderers for objects, numbers, doubles, dates, booleans, and icons. 



*javax.swing.JTable.createDefaultSelectionModel()*

protected |javax.swing.ListSelectionModel| createDefaultSelectionModel()

Returns the default selection model object, which is a DefaultListSelectionModel. A subclass can override this method to return a different selection model object. 



    Returns: the default selection model object 

*javax.swing.JTable.createDefaultTableHeader()*

protected |javax.swing.table.JTableHeader| createDefaultTableHeader()

Returns the default table header object, which is a JTableHeader. A subclass can override this method to return a different table header object. 



    Returns: the default table header object 

*javax.swing.JTable.createScrollPaneForTable(JTable)*

public static |javax.swing.JScrollPane| createScrollPaneForTable(javax.swing.JTable aTable)

Equivalent to new JScrollPane(aTable). 

    Deprecated: As of Swing version 1.0.2,
 replaced by <code>new JScrollPane(aTable)</code>.


*javax.swing.JTable.doLayout()*

public void doLayout()

Causes this table to lay out its rows and columns. Overridden so that columns can be resized to accomodate a change in the size of a containing parent. Resizes one or more of the 
columns in the table so that the total width of all of this JTable's columns is equal to the width of the table. 

Before the layout begins the method gets the resizingColumn of the tableHeader. When the method is called as a result of the resizing of an enclosing window, the resizingColumn is 
null. This means that resizing has taken place "outside" the JTable and the change - or "delta" - should be distributed to all of the columns regardless of this JTable's automatic 
resize mode. 

If the resizingColumn is not null, it is one of the columns in the table that has changed size rather than the table itself. In this case the auto-resize modes govern the way the 
extra (or deficit) space is distributed amongst the available columns. 

The modes are: 

AUTO_RESIZE_OFF: Don't automatically adjust the column's widths at all. Use a horizontal scrollbar to accomodate the columns when their sum exceeds the width of the Viewport. If 
the JTable is not enclosed in a JScrollPane this may leave parts of the table invisible. AUTO_RESIZE_NEXT_COLUMN: Use just the column after the resizing column. This results in 
the "boundary" or divider between adjacent cells being independently adjustable. AUTO_RESIZE_SUBSEQUENT_COLUMNS: Use all columns after the one being adjusted to absorb the 
changes. This is the default behavior. AUTO_RESIZE_LAST_COLUMN: Automatically adjust the size of the last column only. If the bounds of the last column prevent the desired size 
from being allocated, set the width of the last column to the appropriate limit and make no further adjustments. AUTO_RESIZE_ALL_COLUMNS: Spread the delta amongst all the columns 
in the JTable, including the one that is being adjusted. 

Note: When a JTable makes adjustments to the widths of the columns it respects their minimum and maximum values absolutely. It is therefore possible that, even after this method 
is called, the total width of the columns is still not equal to the width of the table. When this happens the JTable does not put itself in AUTO_RESIZE_OFF mode to bring up a 
scroll bar, or break other commitments of its current auto-resize mode -- instead it allows its bounds to be set larger (or smaller) than the total of the column minimum or 
maximum, meaning, either that there will not be enough room to display all of the columns, or that the columns will not fill the JTable's bounds. These respectively, result in the 
clipping of some columns or an area being painted in the JTable's background color during painting. 

The mechanism for distributing the delta amongst the available columns is provided in a private method in the JTable class: 

adjustSizes(long targetSize, final Resizable3 r, boolean inverse) 

an explanation of which is provided in the following section. Resizable3 is a private interface that allows any data structure containing a collection of elements with a size, 
preferred size, maximum size and minimum size to have its elements manipulated by the algorithm. 

Distributing the delta 

Overview 

Call "DELTA" the difference between the target size and the sum of the preferred sizes of the elements in r. The individual sizes are calculated by taking the original preferred 
sizes and adding a share of the DELTA - that share being based on how far each preferred size is from its limiting bound (minimum or maximum). 

Definition 

Call the individual constraints min[i], max[i], and pref[i]. 

Call their respective sums: MIN, MAX, and PREF. 

Each new size will be calculated using: 



size[i] = pref[i] + delta[i] 

where each individual delta[i] is calculated according to: 

If (DELTA 

DELTA delta[i] = ------------ * (pref[i] - min[i]) (PREF - MIN) 

If (DELTA > 0) we are in expand mode where: 



DELTA delta[i] = ------------ * (max[i] - pref[i]) (MAX - PREF) 

The overall effect is that the total size moves that same percentage, k, towards the total minimum or maximum and that percentage guarantees accomodation of the required space, 
DELTA. 

Details 

Naive evaluation of the formulae presented here would be subject to the aggregated rounding errors caused by doing this operation in finite precision (using ints). To deal with 
this, the multiplying factor above, is constantly recalculated and this takes account of the rounding errors in the previous iterations. The result is an algorithm that produces a 
set of integers whose values exactly sum to the supplied targetSize, and does so by spreading the rounding errors evenly over the given elements. 

When the MAX and MIN bounds are hit 

When targetSize is outside the [MIN, MAX] range, the algorithm sets all sizes to their appropriate limiting value (maximum or minimum). 



*javax.swing.JTable.editCellAt(int,int)*

public boolean editCellAt(
  int row,
  int column)

Programmatically starts editing the cell at row and column, if those indices are in the valid range, and the cell at those indices is editable. Note that this is a convenience 
method for editCellAt(int, int, null). 


    row - the row to be edited 
    column - the column to be edited 

    Returns: false if for any reason the cell cannot be edited, or if the indices are invalid 

*javax.swing.JTable.editCellAt(int,int,EventObject)*

public boolean editCellAt(
  int row,
  int column,
  java.util.EventObject e)

Programmatically starts editing the cell at row and column, if those indices are in the valid range, and the cell at those indices is editable. To prevent the JTable from editing 
a particular table, column or cell value, return false from the isCellEditable method in the TableModel interface. 


    row - the row to be edited 
    column - the column to be edited 
    e - event to pass into shouldSelectCell; note that as of Java 2 platform v1.2, the call to shouldSelectCell is no longer made 

    Returns: false if for any reason the cell cannot be edited, or if the indices are invalid 

*javax.swing.JTable.editingCanceled(ChangeEvent)*

public void editingCanceled(javax.swing.event.ChangeEvent e)

Invoked when editing is canceled. The editor object is discarded and the cell is rendered once again. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 

*javax.swing.JTable.editingStopped(ChangeEvent)*

public void editingStopped(javax.swing.event.ChangeEvent e)

Invoked when editing is finished. The changes are saved and the editor is discarded. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 

*javax.swing.JTable.getAccessibleContext()*

public |javax.accessibility.AccessibleContext| getAccessibleContext()

Gets the AccessibleContext associated with this JTable. For tables, the AccessibleContext takes the form of an AccessibleJTable. A new AccessibleJTable instance is created if 
necessary. 



    Returns: an AccessibleJTable that serves as the AccessibleContext of this JTable 

*javax.swing.JTable.getAutoCreateColumnsFromModel()*

public boolean getAutoCreateColumnsFromModel()

Determines whether the table will create default columns from the model. If true, setModel will clear any existing columns and create new columns from the new model. Also, if the 
event in the tableChanged notification specifies that the entire table changed, then the columns will be rebuilt. The default is true. 



    Returns: the autoCreateColumnsFromModel of the table 

*javax.swing.JTable.getAutoResizeMode()*

public int getAutoResizeMode()

Returns the auto resize mode of the table. The default mode is AUTO_RESIZE_SUBSEQUENT_COLUMNS. 



    Returns: the autoResizeMode of the table 

*javax.swing.JTable.getCellEditor()*

public |javax.swing.table.TableCellEditor| getCellEditor()

Returns the active cell editor, which isnullif the table is not currently editing. 



    Returns: the {@code TableCellEditor} that does the editing, or {@code null} if the table is not currently editing. 

*javax.swing.JTable.getCellEditor(int,int)*

public |javax.swing.table.TableCellEditor| getCellEditor(
  int row,
  int column)

Returns an appropriate editor for the cell specified by row and column. If the TableColumn for this column has a non-null editor, returns that. If not, finds the class of the data 
in this column (using getColumnClass) and returns the default editor for this type of data. 

Note: Throughout the table package, the internal implementations always use this method to provide editors so that this default behavior can be safely overridden by a subclass. 


    row - the row of the cell to edit, where 0 is the first row 
    column - the column of the cell to edit, where 0 is the first column 

    Returns: the editor for this cell; if null return the default editor for this type of cell 

*javax.swing.JTable.getCellRect(int,int,boolean)*

public |java.awt.Rectangle| getCellRect(
  int row,
  int column,
  boolean includeSpacing)

Returns a rectangle for the cell that lies at the intersection of row and column. If includeSpacing is true then the value returned has the full height and width of the row and 
column specified. If it is false, the returned rectangle is inset by the intercell spacing to return the true bounds of the rendering or editing component as it will be set during 
rendering. 

If the column index is valid but the row index is less than zero the method returns a rectangle with the y and height values set appropriately and the x and width values both set 
to zero. In general, when either the row or column indices indicate a cell outside the appropriate range, the method returns a rectangle depicting the closest edge of the closest 
cell that is within the table's range. When both row and column indices are out of range the returned rectangle covers the closest point of the closest cell. 

In all cases, calculations that use this method to calculate results along one axis will not fail because of anomalies in calculations along the other axis. When the cell is not 
valid the includeSpacing parameter is ignored. 


    row - the row index where the desired cell is located 
    column - the column index where the desired cell is located in the display; this is not necessarily the same as the column index in the data model for the table; the {@link 
       #convertColumnIndexToView(int)} method may be used to convert a data model column index to a display column index 
    includeSpacing - if false, return the true cell bounds - computed by subtracting the intercell spacing from the height and widths of the column and row models 

    Returns: the rectangle containing the cell at location row,column 

*javax.swing.JTable.getCellRenderer(int,int)*

public |javax.swing.table.TableCellRenderer| getCellRenderer(
  int row,
  int column)

Returns an appropriate renderer for the cell specified by this row and column. If the TableColumn for this column has a non-null renderer, returns that. If not, finds the class of 
the data in this column (using getColumnClass) and returns the default renderer for this type of data. 

Note: Throughout the table package, the internal implementations always use this method to provide renderers so that this default behavior can be safely overridden by a subclass. 


    row - the row of the cell to render, where 0 is the first row 
    column - the column of the cell to render, where 0 is the first column 

    Returns: the assigned renderer; if null returns the default renderer for this type of object 

*javax.swing.JTable.getCellSelectionEnabled()*

public boolean getCellSelectionEnabled()

Returns true if both row and column selection models are enabled. Equivalent to getRowSelectionAllowed() getColumnSelectionAllowed(). 



    Returns: true if both row and column selection models are enabled 

*javax.swing.JTable.getColumn(Object)*

public |javax.swing.table.TableColumn| getColumn(java.lang.Object identifier)

Returns the TableColumn object for the column in the table whose identifier is equal to identifier, when compared using equals. 


    identifier - the identifier object 

    Returns: the TableColumn object that matches the identifier 

*javax.swing.JTable.getColumnClass(int)*

public |java.lang.Class|<?> getColumnClass(int column)

Returns the type of the column appearing in the view at column position column. 


    column - the column in the view being queried 

    Returns: the type of the column at position column in the view where the first column is column 0 

*javax.swing.JTable.getColumnCount()*

public int getColumnCount()

Returns the number of columns in the column model. Note that this may be different from the number of columns in the table model. 



    Returns: the number of columns in the table 

*javax.swing.JTable.getColumnModel()*

public |javax.swing.table.TableColumnModel| getColumnModel()

Returns the TableColumnModel that contains all column information of this table. 



    Returns: the object that provides the column state of the table 

*javax.swing.JTable.getColumnName(int)*

public |java.lang.String| getColumnName(int column)

Returns the name of the column appearing in the view at column position column. 


    column - the column in the view being queried 

    Returns: the name of the column at position column in the view where the first column is column 0 

*javax.swing.JTable.getColumnSelectionAllowed()*

public boolean getColumnSelectionAllowed()

Returns true if columns can be selected. 



    Returns: true if columns can be selected, otherwise false 

*javax.swing.JTable.getDefaultEditor(Class<?>)*

public |javax.swing.table.TableCellEditor| getDefaultEditor(java.lang.Class<?> columnClass)

Returns the editor to be used when no editor has been set in a TableColumn. During the editing of cells the editor is fetched from a Hashtable of entries according to the class of 
the cells in the column. If there is no entry for this columnClass the method returns the entry for the most specific superclass. The JTable installs entries for Object, Number, 
and Boolean, all of which can be modified or replaced. 


    columnClass - return the default cell editor for this columnClass 

    Returns: the default cell editor to be used for this columnClass 

*javax.swing.JTable.getDefaultRenderer(Class<?>)*

public |javax.swing.table.TableCellRenderer| getDefaultRenderer(java.lang.Class<?> columnClass)

Returns the cell renderer to be used when no renderer has been set in a TableColumn. During the rendering of cells the renderer is fetched from a Hashtable of entries according to 
the class of the cells in the column. If there is no entry for this columnClass the method returns the entry for the most specific superclass. The JTable installs entries for 
Object, Number, and Boolean, all of which can be modified or replaced. 


    columnClass - return the default cell renderer for this columnClass 

    Returns: the renderer for this columnClass 

*javax.swing.JTable.getDragEnabled()*

public boolean getDragEnabled()

Gets the value of the dragEnabled property. 



    Returns: the value of the dragEnabled property 

*javax.swing.JTable.getEditingColumn()*

public int getEditingColumn()

Returns the index of the column that contains the cell currently being edited. If nothing is being edited, returns -1. 



    Returns: the index of the column that contains the cell currently being edited; returns -1 if nothing being edited 

*javax.swing.JTable.getEditingRow()*

public int getEditingRow()

Returns the index of the row that contains the cell currently being edited. If nothing is being edited, returns -1. 



    Returns: the index of the row that contains the cell currently being edited; returns -1 if nothing being edited 

*javax.swing.JTable.getEditorComponent()*

public |java.awt.Component| getEditorComponent()

Returns the component that is handling the editing session. If nothing is being edited, returns null. 



    Returns: Component handling editing session 

*javax.swing.JTable.getGridColor()*

public |java.awt.Color| getGridColor()

Returns the color used to draw grid lines. The default color is look and feel dependent. 



    Returns: the color used to draw grid lines 

*javax.swing.JTable.getIntercellSpacing()*

public |java.awt.Dimension| getIntercellSpacing()

Returns the horizontal and vertical space between cells. The default spacing is (1, 1), which provides room to draw the grid. 



    Returns: the horizontal and vertical spacing between cells 

*javax.swing.JTable.getModel()*

public |javax.swing.table.TableModel| getModel()

Returns the TableModel that provides the data displayed by this JTable. 



    Returns: the TableModel that provides the data displayed by this JTable 

*javax.swing.JTable.getPreferredScrollableViewportSize()*

public |java.awt.Dimension| getPreferredScrollableViewportSize()

Returns the preferred size of the viewport for this table. 



    Returns: a Dimension object containing the preferredSize of the JViewport which displays this table 

*javax.swing.JTable.getPrintable(JTable.PrintMode,MessageFormat,MessageFormat)*

public |java.awt.print.Printable| getPrintable(
  javax.swing.JTable.PrintMode printMode,
  java.text.MessageFormat headerFormat,
  java.text.MessageFormat footerFormat)

Return a Printable for use in printing this JTable. 

The Printable can be requested in one of two printing modes. In both modes, it spreads table rows naturally in sequence across multiple pages, fitting as many rows as possible per 
page. PrintMode.NORMAL specifies that the table be printed at its current size. In this mode, there may be a need to spread columns across pages in a similar manner to that of the 
rows. When the need arises, columns are distributed in an order consistent with the table's ComponentOrientation. PrintMode.FIT_WIDTH specifies that the output be scaled smaller, 
if necessary, to fit the table's entire width (and thereby all columns) on each page. Width and height are scaled equally, maintaining the aspect ratio of the output. 

The Printable heads the portion of table on each page with the appropriate section from the table's JTableHeader, if it has one. 

Header and footer text can be added to the output by providing MessageFormat arguments. The printing code requests Strings from the formats, providing a single item which may be 
included in the formatted string: an Integer representing the current page number. 

You are encouraged to read the documentation for MessageFormat as some characters, such as single-quote, are special and need to be escaped. 

Here's an example of creating a MessageFormat that can be used to print "Duke's Table: Page - " and the current page number: 



// notice the escaping of the single quote // notice how the page number is included with "{0}" MessageFormat format = new MessageFormat("Duke''s Table: Page - {0}"); 

The Printable constrains what it draws to the printable area of each page that it prints. Under certain circumstances, it may find it impossible to fit all of a page's content 
into that area. In these cases the output may be clipped, but the implementation makes an effort to do something reasonable. Here are a few situations where this is known to 
occur, and how they may be handled by this particular implementation: 

In any mode, when the header or footer text is too wide to fit completely in the printable area -- print as much of the text as possible starting from the beginning, as determined 
by the table's ComponentOrientation. In any mode, when a row is too tall to fit in the printable area -- print the upper-most portion of the row and paint no lower border on the 
table. In PrintMode.NORMAL when a column is too wide to fit in the printable area -- print the center portion of the column and leave the left and right borders off the table. 

It is entirely valid for this Printable to be wrapped inside another in order to create complex reports and documents. You may even request that different pages be rendered into 
different sized printable areas. The implementation must be prepared to handle this (possibly by doing its layout calculations on the fly). However, providing different heights to 
each page will likely not work well with PrintMode.NORMAL when it has to spread columns across pages. 

It is important to note that this Printable prints the table at its current visual state, using the table's existing renderers. Before calling this method, you may wish to first 
modify the state of the table (such as to change the renderers, cancel editing, or hide the selection). 

You must not, however, modify the table in any way after this Printable is fetched (invalid modifications include changes in: size, renderers, or underlying data). The behavior of 
the returned Printable is undefined once the table has been changed. 

Here's a simple example that calls this method to fetch a Printable, shows a cross-platform print dialog, and then prints the Printable unless the user cancels the dialog: 



// prepare the table for printing here first (for example, hide selection) 

// wrap in a try/finally so table can be restored even if something fails try { // fetch the printable Printable printable = table.getPrintable(JTable.PrintMode.FIT_WIDTH, new 
MessageFormat("My Table"), new MessageFormat("Page - {0}")); 

// fetch a PrinterJob PrinterJob job = PrinterJob.getPrinterJob(); 

// set the Printable on the PrinterJob job.setPrintable(printable); 

// create an attribute set to store attributes from the print dialog PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet(); 

// display a print dialog and record whether or not the user cancels it boolean printAccepted = job.printDialog(attr); 

// if the user didn't cancel the dialog if (printAccepted) { // do the printing (may need to handle PrinterException) job.print(attr); } } finally { // restore the original table 
state here (for example, restore selection) } 


    printMode - the printing mode that the printable should use 
    headerFormat - a MessageFormat specifying the text to be used in printing a header, or null for none 
    footerFormat - a MessageFormat specifying the text to be used in printing a footer, or null for none 

    Returns: a Printable for printing this JTable 

*javax.swing.JTable.getRowCount()*

public int getRowCount()

Returns the number of rows in this table's model. 



    Returns: the number of rows in this table's model 

*javax.swing.JTable.getRowHeight()*

public int getRowHeight()

Returns the height of a table row, in pixels. The default row height is 16.0. 



    Returns: the height in pixels of a table row 

*javax.swing.JTable.getRowHeight(int)*

public int getRowHeight(int row)

Returns the height, in pixels, of the cells in row. 


    row - the row whose height is to be returned 

    Returns: the height, in pixels, of the cells in the row 

*javax.swing.JTable.getRowMargin()*

public int getRowMargin()

Gets the amount of empty space, in pixels, between cells. Equivalent to: getIntercellSpacing().height. 



    Returns: the number of pixels between cells in a row 

*javax.swing.JTable.getRowSelectionAllowed()*

public boolean getRowSelectionAllowed()

Returns true if rows can be selected. 



    Returns: true if rows can be selected, otherwise false 

*javax.swing.JTable.getScrollableBlockIncrement(Rectangle,int,int)*

public int getScrollableBlockIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Returns visibleRect.height or visibleRect.width, depending on this table's orientation. Note that as of Swing 1.1.1 (Java 2 v 1.2.2) the value returned will ensure that the 
viewport is cleanly aligned on a row boundary. 



    Returns: visibleRect.height or visibleRect.width per the orientation 

*javax.swing.JTable.getScrollableTracksViewportHeight()*

public boolean getScrollableTracksViewportHeight()

Returns false to indicate that the height of the viewport does not determine the height of the table. 



    Returns: 

*javax.swing.JTable.getScrollableTracksViewportWidth()*

public boolean getScrollableTracksViewportWidth()

Returns false if autoResizeMode is set to AUTO_RESIZE_OFF, which indicates that the width of the viewport does not determine the width of the table. Otherwise returns true. 



    Returns: false if autoResizeMode is set to AUTO_RESIZE_OFF, otherwise returns true 

*javax.swing.JTable.getScrollableUnitIncrement(Rectangle,int,int)*

public int getScrollableUnitIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Returns the scroll increment (in pixels) that completely exposes one new row or column (depending on the orientation). 

This method is called each time the user requests a unit scroll. 


    visibleRect - the view area visible within the viewport 
    orientation - either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL 
    direction - less than zero to scroll up/left, greater than zero for down/right 

    Returns: the "unit" increment for scrolling in the specified direction 

*javax.swing.JTable.getSelectedColumn()*

public int getSelectedColumn()

Returns the index of the first selected column, -1 if no column is selected. 



    Returns: the index of the first selected column 

*javax.swing.JTable.getSelectedColumnCount()*

public int getSelectedColumnCount()

Returns the number of selected columns. 



    Returns: the number of selected columns, 0 if no columns are selected 

*javax.swing.JTable.getSelectedColumns()*

public int[] getSelectedColumns()

Returns the indices of all selected columns. 



    Returns: an array of integers containing the indices of all selected columns, or an empty array if no column is selected 

*javax.swing.JTable.getSelectedRow()*

public int getSelectedRow()

Returns the index of the first selected row, -1 if no row is selected. 



    Returns: the index of the first selected row 

*javax.swing.JTable.getSelectedRowCount()*

public int getSelectedRowCount()

Returns the number of selected rows. 



    Returns: the number of selected rows, 0 if no rows are selected 

*javax.swing.JTable.getSelectedRows()*

public int[] getSelectedRows()

Returns the indices of all selected rows. 



    Returns: an array of integers containing the indices of all selected rows, or an empty array if no row is selected 

*javax.swing.JTable.getSelectionBackground()*

public |java.awt.Color| getSelectionBackground()

Returns the background color for selected cells. 



    Returns: the Color used for the background of selected list items 

*javax.swing.JTable.getSelectionForeground()*

public |java.awt.Color| getSelectionForeground()

Returns the foreground color for selected cells. 



    Returns: the Color object for the foreground property 

*javax.swing.JTable.getSelectionModel()*

public |javax.swing.ListSelectionModel| getSelectionModel()

Returns the ListSelectionModel that is used to maintain row selection state. 



    Returns: the object that provides row selection state, null if row selection is not allowed 

*javax.swing.JTable.getShowHorizontalLines()*

public boolean getShowHorizontalLines()

Returns true if the table draws horizontal lines between cells, false if it doesn't. The default is true. 



    Returns: true if the table draws horizontal lines between cells, false if it doesn't 

*javax.swing.JTable.getShowVerticalLines()*

public boolean getShowVerticalLines()

Returns true if the table draws vertical lines between cells, false if it doesn't. The default is true. 



    Returns: true if the table draws vertical lines between cells, false if it doesn't 

*javax.swing.JTable.getSurrendersFocusOnKeystroke()*

public boolean getSurrendersFocusOnKeystroke()

Returns true if the editor should get the focus when keystrokes cause the editor to be activated 



    Returns: true if the editor should get the focus when keystrokes cause the editor to be activated 

*javax.swing.JTable.getTableHeader()*

public |javax.swing.table.JTableHeader| getTableHeader()

Returns the tableHeader used by this JTable. 



    Returns: the tableHeader used by this table 

*javax.swing.JTable.getToolTipText(MouseEvent)*

public |java.lang.String| getToolTipText(java.awt.event.MouseEvent event)

Overrides JComponent's getToolTipText method in order to allow the renderer's tips to be used if it has text set. 

Note: For JTable to properly display tooltips of its renderers JTable must be a registered component with the ToolTipManager. This is done automatically in initializeLocalVars, 
but if at a later point JTable is told setToolTipText(null) it will unregister the table component, and no tips from renderers will display anymore. 



*javax.swing.JTable.getUI()*

public |javax.swing.plaf.TableUI| getUI()

Returns the Lobject that renders this component. 



    Returns: the TableUI object that renders this component 

*javax.swing.JTable.getUIClassID()*

public |java.lang.String| getUIClassID()

Returns the suffix used to construct the name of the Lclass used to render this component. 



    Returns: the string "TableUI" 

*javax.swing.JTable.getValueAt(int,int)*

public |java.lang.Object| getValueAt(
  int row,
  int column)

Returns the cell value at row and column. 

Note: The column is specified in the table view's display order, and not in the TableModel's column order. This is an important distinction because as the user rearranges the 
columns in the table, the column at a given index in the view will change. Meanwhile the user's actions never affect the model's column ordering. 


    row - the row whose value is to be queried 
    column - the column whose value is to be queried 

    Returns: the Object at the specified cell 

*javax.swing.JTable.initializeLocalVars()*

protected void initializeLocalVars()

Initializes table properties to their default values. 



*javax.swing.JTable.isCellEditable(int,int)*

public boolean isCellEditable(
  int row,
  int column)

Returns true if the cell at row and column is editable. Otherwise, invoking setValueAt on the cell will have no effect. 

Note: The column is specified in the table view's display order, and not in the TableModel's column order. This is an important distinction because as the user rearranges the 
columns in the table, the column at a given index in the view will change. Meanwhile the user's actions never affect the model's column ordering. 


    row - the row whose value is to be queried 
    column - the column whose value is to be queried 

    Returns: true if the cell is editable 

*javax.swing.JTable.isCellSelected(int,int)*

public boolean isCellSelected(
  int row,
  int column)

Returns true if the specified indices are in the valid range of rows and columns and the cell at the specified position is selected. 


    row - the row being queried 
    column - the column being queried 

    Returns: true if row and column are valid indices and the cell at index (row, column) is selected, where the first row and first column are at index 0 

*javax.swing.JTable.isColumnSelected(int)*

public boolean isColumnSelected(int column)

Returns true if the specified index is in the valid range of columns, and the column at that index is selected. 


    column - the column in the column model 

    Returns: true if column is a valid index and the column at that index is selected (where 0 is the first column) 

*javax.swing.JTable.isEditing()*

public boolean isEditing()

Returns true if a cell is being edited. 



    Returns: true if the table is editing a cell 

*javax.swing.JTable.isRowSelected(int)*

public boolean isRowSelected(int row)

Returns true if the specified index is in the valid range of rows, and the row at that index is selected. 



    Returns: true if row is a valid index and the row at that index is selected (where 0 is the first row) 

*javax.swing.JTable.moveColumn(int,int)*

public void moveColumn(
  int column,
  int targetColumn)

Moves the column column to the position currently occupied by the column targetColumn in the view. The old column at targetColumn is shifted left or right to make room. 


    column - the index of column to be moved 
    targetColumn - the new index of the column 

*javax.swing.JTable.paramString()*

protected |java.lang.String| paramString()

Returns a string representation of this table. This method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between 
implementations. The returned string may be empty but may not be null. 



    Returns: a string representation of this table 

*javax.swing.JTable.prepareEditor(TableCellEditor,int,int)*

public |java.awt.Component| prepareEditor(
  javax.swing.table.TableCellEditor editor,
  int row,
  int column)

Prepares the editor by querying the data model for the value and selection state of the cell at row, column. 

Note: Throughout the table package, the internal implementations always use this method to prepare editors so that this default behavior can be safely overridden by a subclass. 


    editor - the TableCellEditor to set up 
    row - the row of the cell to edit, where 0 is the first row 
    column - the column of the cell to edit, where 0 is the first column 

    Returns: the Component being edited 

*javax.swing.JTable.prepareRenderer(TableCellRenderer,int,int)*

public |java.awt.Component| prepareRenderer(
  javax.swing.table.TableCellRenderer renderer,
  int row,
  int column)

Prepares the renderer by querying the data model for the value and selection state of the cell at row, column. Returns the component (may be a Component or a JComponent) under the 
event location. 

Note: Throughout the table package, the internal implementations always use this method to prepare renderers so that this default behavior can be safely overridden by a subclass. 


    renderer - the TableCellRenderer to prepare 
    row - the row of the cell to render, where 0 is the first row 
    column - the column of the cell to render, where 0 is the first column 

    Returns: the Component under the event location 

*javax.swing.JTable.print()*

public boolean print()
  throws |java.awt.print.PrinterException|
         
A convenience method that displays a printing dialog, and then prints this JTable in mode PrintMode.FIT_WIDTH, with no header or footer text. A modal progress dialog, with an 
abort option, will be shown for the duration of printing. 

Note: In headless mode, no dialogs will be shown. 



    Returns: true, unless printing is cancelled by the user 

*javax.swing.JTable.print(JTable.PrintMode)*

public boolean print(javax.swing.JTable.PrintMode printMode)
  throws |java.awt.print.PrinterException|
         
A convenience method that displays a printing dialog, and then prints this JTable in the given printing mode, with no header or footer text. A modal progress dialog, with an abort 
option, will be shown for the duration of printing. 

Note: In headless mode, no dialogs will be shown. 


    printMode - the printing mode that the printable should use 

    Returns: true, unless printing is cancelled by the user 

*javax.swing.JTable.print(JTable.PrintMode,MessageFormat,MessageFormat)*

public boolean print(
  javax.swing.JTable.PrintMode printMode,
  java.text.MessageFormat headerFormat,
  java.text.MessageFormat footerFormat)
  throws |java.awt.print.PrinterException|
         
A convenience method that displays a printing dialog, and then prints this JTable in the given printing mode, with the specified header and footer text. A modal progress dialog, 
with an abort option, will be shown for the duration of printing. 

Note: In headless mode, no dialogs will be shown. 


    printMode - the printing mode that the printable should use 
    headerFormat - a MessageFormat specifying the text to be used in printing a header, or null for none 
    footerFormat - a MessageFormat specifying the text to be used in printing a footer, or null for none 

    Returns: true, unless printing is cancelled by the user 

*javax.swing.JTable.print(JTable.PrintMode,MessageFormat,MessageFormat,boolean,PrintRequestAttributeSet,boolean)*

public boolean print(
  javax.swing.JTable.PrintMode printMode,
  java.text.MessageFormat headerFormat,
  java.text.MessageFormat footerFormat,
  boolean showPrintDialog,
  javax.print.attribute.PrintRequestAttributeSet attr,
  boolean interactive)
  throws |java.awt.HeadlessException|
         |java.awt.print.PrinterException|
         
Print this JTable. Takes steps that the majority of developers would take in order to print a JTable. In short, it prepares the table, calls getPrintable to fetch an appropriate 
Printable, and then sends it to the printer. 

A boolean parameter allows you to specify whether or not a printing dialog is displayed to the user. When it is, the user may use the dialog to change printing attributes or even 
cancel the print. Another parameter allows for printing attributes to be specified directly. This can be used either to provide the initial values for the print dialog, or to 
supply any needed attributes when the dialog is not shown. 

A second boolean parameter allows you to specify whether or not to perform printing in an interactive mode. If true, a modal progress dialog, with an abort option, is displayed 
for the duration of printing . This dialog also prevents any user action which may affect the table. However, it can not prevent the table from being modified by code (for 
example, another thread that posts updates using SwingUtilities.invokeLater). It is therefore the responsibility of the developer to ensure that no other code modifies the table 
in any way during printing (invalid modifications include changes in: size, renderers, or underlying data). Printing behavior is undefined when the table is changed during 
printing. 

If false is specified for this parameter, no dialog will be displayed and printing will begin immediately on the event-dispatch thread. This blocks any other events, including 
repaints, from being processed until printing is complete. Although this effectively prevents the table from being changed, it doesn't provide a good user experience. For this 
reason, specifying false is only recommended when printing from an application with no visible GUI. 

Note: Attempting to show the printing dialog or run interactively, while in headless mode, will result in a HeadlessException. 

Before fetching the printable, this method prepares the table in order to get the most desirable printed result. If the table is currently in an editing mode, it terminates the 
editing as gracefully as possible. It also ensures that the the table's current selection and focused cell are not indicated in the printed output. This is handled on the view 
level, and only for the duration of the printing, thus no notification needs to be sent to the selection models. 

See (|javax.swing.JTable|) for further description on how the table is printed. 


    printMode - the printing mode that the printable should use 
    headerFormat - a MessageFormat specifying the text to be used in printing a header, or null for none 
    footerFormat - a MessageFormat specifying the text to be used in printing a footer, or null for none 
    showPrintDialog - whether or not to display a print dialog 
    attr - a PrintRequestAttributeSet specifying any printing attributes, or null for none 
    interactive - whether or not to print in an interactive mode 

    Returns: true, unless printing is cancelled by the user 

*javax.swing.JTable.processKeyBinding(KeyStroke,KeyEvent,int,boolean)*

protected boolean processKeyBinding(
  javax.swing.KeyStroke ks,
  java.awt.event.KeyEvent e,
  int condition,
  boolean pressed)





*javax.swing.JTable.removeColumn(TableColumn)*

public void removeColumn(javax.swing.table.TableColumn aColumn)

Removes aColumn from this JTable's array of columns. Note: this method does not remove the column of data from the model; it just removes the TableColumn that was responsible for 
displaying it. 


    aColumn - the TableColumn to be removed 

*javax.swing.JTable.removeColumnSelectionInterval(int,int)*

public void removeColumnSelectionInterval(
  int index0,
  int index1)

Deselects the columns from index0 to index1, inclusive. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.removeEditor()*

public void removeEditor()

Discards the editor object and frees the real estate it used for cell rendering. 



*javax.swing.JTable.removeNotify()*

public void removeNotify()

Calls the unconfigureEnclosingScrollPane method. 



*javax.swing.JTable.removeRowSelectionInterval(int,int)*

public void removeRowSelectionInterval(
  int index0,
  int index1)

Deselects the rows from index0 to index1, inclusive. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.resizeAndRepaint()*

protected void resizeAndRepaint()

Equivalent to revalidate followed by repaint. 



*javax.swing.JTable.rowAtPoint(Point)*

public int rowAtPoint(java.awt.Point point)

Returns the index of the row that point lies in, or -1 if the result is not in the range [0, getRowCount()-1]. 


    point - the location of interest 

    Returns: the index of the row that point lies in, or -1 if the result is not in the range [0, getRowCount()-1] 

*javax.swing.JTable.selectAll()*

public void selectAll()

Selects all rows, columns, and cells in the table. 



*javax.swing.JTable.setAutoCreateColumnsFromModel(boolean)*

public void setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel)

Sets this table's autoCreateColumnsFromModel flag. This method calls createDefaultColumnsFromModel if autoCreateColumnsFromModel changes from false to true. 


    autoCreateColumnsFromModel - true if JTable should automatically create columns 

*javax.swing.JTable.setAutoResizeMode(int)*

public void setAutoResizeMode(int mode)

Sets the table's auto resize mode when the table is resized. 


    mode - One of 5 legal values: AUTO_RESIZE_OFF, AUTO_RESIZE_NEXT_COLUMN, AUTO_RESIZE_SUBSEQUENT_COLUMNS, AUTO_RESIZE_LAST_COLUMN, AUTO_RESIZE_ALL_COLUMNS 

*javax.swing.JTable.setCellEditor(TableCellEditor)*

public void setCellEditor(javax.swing.table.TableCellEditor anEditor)

Sets the active cell editor. 


    anEditor - the active cell editor 

*javax.swing.JTable.setCellSelectionEnabled(boolean)*

public void setCellSelectionEnabled(boolean cellSelectionEnabled)

Sets whether this table allows both a column selection and a row selection to exist simultaneously. When set, the table treats the intersection of the row and column selection 
models as the selected cells. Override isCellSelected to change this default behavior. This method is equivalent to setting both the rowSelectionAllowed property and 
columnSelectionAllowed property of the columnModel to the supplied value. 


    cellSelectionEnabled - true if simultaneous row and column selection is allowed 

*javax.swing.JTable.setColumnModel(TableColumnModel)*

public void setColumnModel(javax.swing.table.TableColumnModel columnModel)

Sets the column model for this table to newModel and registers for listener notifications from the new column model. Also sets the column model of the JTableHeader to columnModel. 


    columnModel - the new data source for this table 

*javax.swing.JTable.setColumnSelectionAllowed(boolean)*

public void setColumnSelectionAllowed(boolean columnSelectionAllowed)

Sets whether the columns in this model can be selected. 


    columnSelectionAllowed - true if this model will allow column selection 

*javax.swing.JTable.setColumnSelectionInterval(int,int)*

public void setColumnSelectionInterval(
  int index0,
  int index1)

Selects the columns from index0 to index1, inclusive. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.setDefaultEditor(Class<?>,TableCellEditor)*

public void setDefaultEditor(
  java.lang.Class<?> columnClass,
  javax.swing.table.TableCellEditor editor)

Sets a default cell editor to be used if no editor has been set in a TableColumn. If no editing is required in a table, or a particular column in a table, uses the isCellEditable 
method in the TableModel interface to ensure that this JTable will not start an editor in these columns. If editor is null, removes the default editor for this column class. 


    columnClass - set the default cell editor for this columnClass 
    editor - default cell editor to be used for this columnClass 

*javax.swing.JTable.setDefaultRenderer(Class<?>,TableCellRenderer)*

public void setDefaultRenderer(
  java.lang.Class<?> columnClass,
  javax.swing.table.TableCellRenderer renderer)

Sets a default cell renderer to be used if no renderer has been set in a TableColumn. If renderer is null, removes the default renderer for this column class. 


    columnClass - set the default cell renderer for this columnClass 
    renderer - default cell renderer to be used for this columnClass 

*javax.swing.JTable.setDragEnabled(boolean)*

public void setDragEnabled(boolean b)

Sets the dragEnabled property, which must be true to enable automatic drag handling (the first part of drag and drop) on this component. The transferHandler property needs to be 
set to a non-null value for the drag to do anything. The default value of the dragEnabledfalse. 



When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over a selection and then moves the mouse a 
few pixels. Setting this property to true can therefore have a subtle effect on how selections behave. 



Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call 
the exportAsDrag method of a TransferHandler. 


    b - the value to set the dragEnabled property to 

*javax.swing.JTable.setEditingColumn(int)*

public void setEditingColumn(int aColumn)

Sets the editingColumn variable. 


    aColumn - the column of the cell to be edited 

*javax.swing.JTable.setEditingRow(int)*

public void setEditingRow(int aRow)

Sets the editingRow variable. 


    aRow - the row of the cell to be edited 

*javax.swing.JTable.setGridColor(Color)*

public void setGridColor(java.awt.Color gridColor)

Sets the color used to draw grid lines to gridColor and redisplays. The default color is look and feel dependent. 


    gridColor - the new color of the grid lines 

*javax.swing.JTable.setIntercellSpacing(Dimension)*

public void setIntercellSpacing(java.awt.Dimension intercellSpacing)

Sets the rowMargin and the columnMargin -- the height and width of the space between cells -- to intercellSpacing. 


    intercellSpacing - a Dimension specifying the new width and height between cells 

*javax.swing.JTable.setModel(TableModel)*

public void setModel(javax.swing.table.TableModel dataModel)

Sets the data model for this table to newModel and registers with it for listener notifications from the new data model. 


    dataModel - the new data source for this table 

*javax.swing.JTable.setPreferredScrollableViewportSize(Dimension)*

public void setPreferredScrollableViewportSize(java.awt.Dimension size)

Sets the preferred size of the viewport for this table. 


    size - a Dimension object specifying the preferredSize of a JViewport whose view is this table 

*javax.swing.JTable.setRowHeight(int)*

public void setRowHeight(int rowHeight)

Sets the height, in pixels, of all cells to rowHeight, revalidates, and repaints. The height of the cells will be equal to the row height minus the row margin. 


    rowHeight - new row height 

*javax.swing.JTable.setRowHeight(int,int)*

public void setRowHeight(
  int row,
  int rowHeight)

Sets the height for row to rowHeight, revalidates, and repaints. The height of the cells in this row will be equal to the row height minus the row margin. 


    row - the row whose height is being changed 
    rowHeight - new row height, in pixels 

*javax.swing.JTable.setRowMargin(int)*

public void setRowMargin(int rowMargin)

Sets the amount of empty space between cells in adjacent rows. 


    rowMargin - the number of pixels between cells in a row 

*javax.swing.JTable.setRowSelectionAllowed(boolean)*

public void setRowSelectionAllowed(boolean rowSelectionAllowed)

Sets whether the rows in this model can be selected. 


    rowSelectionAllowed - true if this model will allow row selection 

*javax.swing.JTable.setRowSelectionInterval(int,int)*

public void setRowSelectionInterval(
  int index0,
  int index1)

Selects the rows from index0 to index1, inclusive. 


    index0 - one end of the interval 
    index1 - the other end of the interval 

*javax.swing.JTable.setSelectionBackground(Color)*

public void setSelectionBackground(java.awt.Color selectionBackground)

Sets the background color for selected cells. Cell renderers can use this color to the fill selected cells. 

The default value of this property is defined by the look and feel implementation. 

This is a JavaBeans bound property. 


    selectionBackground - the Color to use for the background of selected cells 

*javax.swing.JTable.setSelectionForeground(Color)*

public void setSelectionForeground(java.awt.Color selectionForeground)

Sets the foreground color for selected cells. Cell renderers can use this color to render text and graphics for selected cells. 

The default value of this property is defined by the look and feel implementation. 

This is a JavaBeans bound property. 


    selectionForeground - the Color to use in the foreground for selected list items 

*javax.swing.JTable.setSelectionMode(int)*

public void setSelectionMode(int selectionMode)

Sets the table's selection mode to allow only single selections, a single contiguous interval, or multiple intervals. 

Note: JTable provides all the methods for handling column and row selection. When setting states, such as setSelectionMode, it not only updates the mode for the row selection 
model but also sets similar values in the selection model of the columnModel. If you want to have the row and column selection models operating in different modes, set them both 
directly. 

Both the row and column selection models for JTable default to using a DefaultListSelectionModel so that JTable works the same way as the JList. See the setSelectionMode method in 
JList for details about the modes. 



*javax.swing.JTable.setSelectionModel(ListSelectionModel)*

public void setSelectionModel(javax.swing.ListSelectionModel newModel)

Sets the row selection model for this table to newModel and registers for listener notifications from the new selection model. 


    newModel - the new selection model 

*javax.swing.JTable.setShowGrid(boolean)*

public void setShowGrid(boolean showGrid)

Sets whether the table draws grid lines around cells. If showGrid is true it does; if it is false it doesn't. There is no getShowGrid method as this state is held in two variables 
-- showHorizontalLines and showVerticalLines -- each of which can be queried independently. 


    showGrid - true if table view should draw grid lines 

*javax.swing.JTable.setShowHorizontalLines(boolean)*

public void setShowHorizontalLines(boolean showHorizontalLines)

Sets whether the table draws horizontal lines between cells. If showHorizontalLines is true it does; if it is false it doesn't. 


    showHorizontalLines - true if table view should draw horizontal lines 

*javax.swing.JTable.setShowVerticalLines(boolean)*

public void setShowVerticalLines(boolean showVerticalLines)

Sets whether the table draws vertical lines between cells. If showVerticalLines is true it does; if it is false it doesn't. 


    showVerticalLines - true if table view should draw vertical lines 

*javax.swing.JTable.setSurrendersFocusOnKeystroke(boolean)*

public void setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke)

Sets whether editors in this JTable get the keyboard focus when an editor is activated as a result of the JTable forwarding keyboard events for a cell. By default, this property 
is false, and the JTable retains the focus unless the cell is clicked. 


    surrendersFocusOnKeystroke - true if the editor should get the focus when keystrokes cause the editor to be activated 

*javax.swing.JTable.setTableHeader(JTableHeader)*

public void setTableHeader(javax.swing.table.JTableHeader tableHeader)

Sets the tableHeader working with this JTable to newHeader. It is legal to have a null tableHeader. 


    tableHeader - new tableHeader 

*javax.swing.JTable.setUI(TableUI)*

public void setUI(javax.swing.plaf.TableUI ui)

Sets the Lobject that renders this component and repaints. 


    ui - the TableUI Lobject 

*javax.swing.JTable.setValueAt(Object,int,int)*

public void setValueAt(
  java.lang.Object aValue,
  int row,
  int column)

Sets the value for the cell in the table model at row and column. 

Note: The column is specified in the table view's display order, and not in the TableModel's column order. This is an important distinction because as the user rearranges the 
columns in the table, the column at a given index in the view will change. Meanwhile the user's actions never affect the model's column ordering. 

aValue is the new value. 


    aValue - the new value 
    row - the row of the cell to be changed 
    column - the column of the cell to be changed 

*javax.swing.JTable.sizeColumnsToFit(boolean)*

public void sizeColumnsToFit(boolean lastColumnOnly)

Sizes the table columns to fit the available space. 

    Deprecated: As of Swing version 1.0.3,
 replaced by <code>doLayout()</code>.


*javax.swing.JTable.sizeColumnsToFit(int)*

public void sizeColumnsToFit(int resizingColumn)

Obsolete as of Java 2 platform v1.4. Please use the doLayout() method instead. 


    resizingColumn - the column whose resizing made this adjustment necessary or -1 if there is no such column 

*javax.swing.JTable.tableChanged(TableModelEvent)*

public void tableChanged(javax.swing.event.TableModelEvent e)

Invoked when this table's TableModel generates a TableModelEvent. The TableModelEvent should be constructed in the coordinate system of the model; the appropriate mapping to the 
view coordinate system is performed by this JTable when it receives the event. 

Application code will not use these methods explicitly, they are used internally by JTable. 

Note that as of 1.3, this method clears the selection, if any. 



*javax.swing.JTable.unconfigureEnclosingScrollPane()*

protected void unconfigureEnclosingScrollPane()

Reverses the effect of configureEnclosingScrollPane by replacing the columnHeaderView of the enclosing scroll pane with null. JTable's removeNotify method calls this method, which 
is protected so that this default uninstallation procedure can be overridden by a subclass. 



*javax.swing.JTable.updateUI()*

public void updateUI()

Notification from the UIManager that the Lhas changed. Replaces the current UI object with the latest version from the UIManager. 



*javax.swing.JTable.valueChanged(ListSelectionEvent)*

public void valueChanged(javax.swing.event.ListSelectionEvent e)

Invoked when the row selection changes -- repaints to show the new selection. 

Application code will not use these methods explicitly, they are used internally by JTable. 


    e - the event received 


