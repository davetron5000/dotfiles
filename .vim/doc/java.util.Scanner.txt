*java.util.Scanner* *Scanner* A simple text scanner which can parse primitive ty

public final class Scanner
  extends    |java.lang.Object|
  implements |java.util.Iterator|

|java.util.Scanner_Description|
|java.util.Scanner_Fields|
|java.util.Scanner_Constructors|
|java.util.Scanner_Methods|

================================================================================

*java.util.Scanner_Constructors*
|java.util.Scanner(File)|Constructs a new Scanner that produces values scanned 
|java.util.Scanner(File,String)|Constructs a new Scanner that produces values s
|java.util.Scanner(InputStream)|Constructs a new Scanner that produces values s
|java.util.Scanner(InputStream,String)|Constructs a new Scanner that produces v
|java.util.Scanner(Readable)|Constructs a new Scanner that produces values scan
|java.util.Scanner(ReadableByteChannel)|Constructs a new Scanner that produces 
|java.util.Scanner(ReadableByteChannel,String)|Constructs a new Scanner that pr
|java.util.Scanner(String)|Constructs a new Scanner that produces values scanne

*java.util.Scanner_Methods*
|java.util.Scanner.close()|Closes this scanner.
|java.util.Scanner.delimiter()|Returns the Pattern this Scanner is currently  u
|java.util.Scanner.findInLine(Pattern)|Attempts to find the next occurrence of 
|java.util.Scanner.findInLine(String)|Attempts to find the next occurrence of a
|java.util.Scanner.findWithinHorizon(Pattern,int)|Attempts to find the next occ
|java.util.Scanner.findWithinHorizon(String,int)|Attempts to find the next occu
|java.util.Scanner.hasNext()|Returns true if this scanner has another token in 
|java.util.Scanner.hasNext(Pattern)|Returns true if the next complete token mat
|java.util.Scanner.hasNext(String)|Returns true if the next token matches the p
|java.util.Scanner.hasNextBigDecimal()|Returns true if the next token in this s
|java.util.Scanner.hasNextBigInteger()|Returns true if the next token in this s
|java.util.Scanner.hasNextBigInteger(int)|Returns true if the next token in thi
|java.util.Scanner.hasNextBoolean()|Returns true if the next token in this scan
|java.util.Scanner.hasNextByte()|Returns true if the next token in this scanner
|java.util.Scanner.hasNextByte(int)|Returns true if the next token in this scan
|java.util.Scanner.hasNextDouble()|Returns true if the next token in this scann
|java.util.Scanner.hasNextFloat()|Returns true if the next token in this scanne
|java.util.Scanner.hasNextInt()|Returns true if the next token in this scanner'
|java.util.Scanner.hasNextInt(int)|Returns true if the next token in this scann
|java.util.Scanner.hasNextLine()|Returns true if there is another line in the i
|java.util.Scanner.hasNextLong()|Returns true if the next token in this scanner
|java.util.Scanner.hasNextLong(int)|Returns true if the next token in this scan
|java.util.Scanner.hasNextShort()|Returns true if the next token in this scanne
|java.util.Scanner.hasNextShort(int)|Returns true if the next token in this sca
|java.util.Scanner.ioException()|Returns the IOException last thrown by this  S
|java.util.Scanner.locale()|Returns this scanner's locale.
|java.util.Scanner.match()|Returns the match result of the last scanning operat
|java.util.Scanner.next()|Finds and returns the next complete token from this s
|java.util.Scanner.next(Pattern)|Returns the next token if it matches the speci
|java.util.Scanner.next(String)|Returns the next token if it matches the patter
|java.util.Scanner.nextBigDecimal()|Scans the next token of the input as ajava.
|java.util.Scanner.nextBigInteger()|Scans the next token of the input as ajava.
|java.util.Scanner.nextBigInteger(int)|Scans the next token of the input as aja
|java.util.Scanner.nextBoolean()|Scans the next token of the input into a boole
|java.util.Scanner.nextByte()|Scans the next token of the input as a byte.
|java.util.Scanner.nextByte(int)|Scans the next token of the input as a byte.
|java.util.Scanner.nextDouble()|Scans the next token of the input as a double.
|java.util.Scanner.nextFloat()|Scans the next token of the input as a float.
|java.util.Scanner.nextInt()|Scans the next token of the input as an int.
|java.util.Scanner.nextInt(int)|Scans the next token of the input as an int.
|java.util.Scanner.nextLine()|Advances this scanner past the current line and r
|java.util.Scanner.nextLong()|Scans the next token of the input as a long.
|java.util.Scanner.nextLong(int)|Scans the next token of the input as a long.
|java.util.Scanner.nextShort()|Scans the next token of the input as a short.
|java.util.Scanner.nextShort(int)|Scans the next token of the input as a short.
|java.util.Scanner.radix()|Returns this scanner's default radix.
|java.util.Scanner.remove()|The remove operation is not supported by this imple
|java.util.Scanner.skip(Pattern)|Skips input that matches the specified pattern
|java.util.Scanner.skip(String)|Skips input that matches a pattern constructed 
|java.util.Scanner.toString()|Returns the string representation of this Scanner
|java.util.Scanner.useDelimiter(Pattern)|Sets this scanner's delimiting pattern
|java.util.Scanner.useDelimiter(String)|Sets this scanner's delimiting pattern 
|java.util.Scanner.useLocale(Locale)|Sets this scanner's locale to the specifie
|java.util.Scanner.useRadix(int)|Sets this scanner's default radix to the speci

*java.util.Scanner_Description*

A simple text scanner which can parse primitive types and strings using regular 
expressions. 

A Scanner breaks its input into tokens using a delimiter pattern, which by 
default matches whitespace. The resulting tokens may then be converted into 
values of different types using the various next methods. 

For example, this code allows a user to read a number from System.in: 

Scanner sc = new Scanner(System.in); int i = sc.nextInt(); 

As another example, this code allows long types to be assigned from entries in 
a file myNumbers: 

Scanner sc = new Scanner(new File("myNumbers")); while (sc.hasNextLong()) { 
long aLong = sc.nextLong(); } 

The scanner can also use delimiters other than whitespace. This example reads 
several items in from a string: 

String input = "1 fish 2 fish red fish blue fish"; Scanner s = new 
Scanner(input).useDelimiter("\\s*fish\\s*"); System.out.println(s.nextInt()); 
System.out.println(s.nextInt()); System.out.println(s.next()); 
System.out.println(s.next()); s.close(); 

prints the following output: 

1 2 red blue 

The same output can be generated with this code, which uses a regular 
expression to parse all four tokens at once: 

String input = "1 fish 2 fish red fish blue fish"; Scanner s = new 
Scanner(input); s.findInLine("(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)"); 
MatchResult result = s.match(); for (int i=1; i 

The default whitespace delimiter used by a scanner is as recognized by 
(|java.lang.Character|) . isWhitespace(|java.lang.Character|) . 

A scanning operation may block waiting for input. 

The (|java.util.Scanner|) and (|java.util.Scanner|) methods and their 
primitive-type companion methods (such as (|java.util.Scanner|) and 
(|java.util.Scanner|) ) first skip any input that matches the delimiter 
pattern, and then attempt to return the next token. Both hasNext and next 
methods may block waiting for further input. Whether a hasNext method blocks 
has no connection to whether or not its associated next method will block. 

The (|java.util.Scanner|) , (|java.util.Scanner|) , and (|java.util.Scanner|) 
methods operate independently of the delimiter pattern. These methods will 
attempt to match the specified pattern with no regard to delimiters in the 
input and thus can be used in special circumstances where delimiters are not 
relevant. These methods may block waiting for more input. 

When a scanner throws an (|java.util.InputMismatchException|) , the scanner 
will not pass the token that caused the exception, so that it may be retrieved 
or skipped via some other method. 

Depending upon the type of delimiting pattern, empty tokens may be returned. 
For example, the pattern "\\s+" will return no empty tokens since it matches 
multiple instances of the delimiter. The delimiting pattern "\\s" could return 
empty tokens since it only passes one space at a time. 

A scanner can read text from any object which implements the 
(|java.lang.Readable|) interface. If an invocation of the underlying readable's 
(|java.lang.Readable|) method throws an (|java.io.IOException|) then the 
scanner assumes that the end of the input has been reached. The most recent 
IOException thrown by the underlying readable can be retrieved via the 
(|java.util.Scanner|) method. 

When a Scanner is closed, it will close its input source if the source 
implements the (|java.io.Closeable|) interface. 

A Scanner is not safe for multithreaded use without external synchronization. 

Unless otherwise mentioned, passing a null parameter into any method of a 
Scanner will cause a NullPointerException to be thrown. 

A scanner will default to interpreting numbers as decimal unless a different 
radix has been set by using the (|java.util.Scanner|) method. 

Localized numbers 

An instance of this class is capable of scanning numbers in the standard 
formats as well as in the formats of the scanner's locale. A scanner's initial 
locale is the value returned by the (|java.util.Locale|) method; it may be 
changed via the (|java.util.Scanner|) method. 

The localized formats are defined in terms of the following parameters, which 
for a particular locale are taken from that locale's 
DecimalFormat(|java.text.DecimalFormat|) object, df, and its and 
DecimalFormatSymbols(|java.text.DecimalFormatSymbols|) object, dfs. 

LocalGroupSeparator The character used to separate thousands groups, i.e.,dfs. 
getGroupingSeparator()(|java.text.DecimalFormatSymbols|) LocalDecimalSeparator 
The character used for the decimal point, i.e.,dfs. 
getDecimalSeparator()(|java.text.DecimalFormatSymbols|) LocalPositivePrefix The 
string that appears before a positive number (may be empty), i.e.,df. 
getPositivePrefix()(|java.text.DecimalFormat|) LocalPositiveSuffix The string 
that appears after a positive number (may be empty), i.e.,df. 
getPositiveSuffix()(|java.text.DecimalFormat|) LocalNegativePrefix The string 
that appears before a negative number (may be empty), i.e.,df. 
getNegativePrefix()(|java.text.DecimalFormat|) LocalNegativeSuffix The string 
that appears after a negative number (may be empty), i.e.,df. 
getNegativeSuffix()(|java.text.DecimalFormat|) LocalNaN The string that 
represents not-a-number for floating-point values, i.e.,dfs. 
getInfinity()(|java.text.DecimalFormatSymbols|) LocalInfinity The string that 
represents infinity for floating-point values, i.e.,dfs. 
getInfinity()(|java.text.DecimalFormatSymbols|) 



Number syntax 

The strings that can be parsed as numbers by an instance of this class are 
specified in terms of the following regular-expression grammar, where Rmax is 
the highest digit in the radix being used (for example, Rmax is 9 in base 10). 



NonASCIIDigit:: = A non-ASCII character c for which 
Character.isDigit(|java.lang.Character|) (c) returnstrue 



Non0Digit:: = [1-Rmax] | NonASCIIDigit 



Digit:: = [0-Rmax] | NonASCIIDigit 



GroupedNumeral:: 

= ( Non0Digit Digit? Digit? 

(LocalGroupSeparator Digit Digit Digit )+ ) 



Numeral:: = ( ( Digit+ ) | GroupedNumeral ) 



Integer:: = ( [-+]? ( Numeral ) ) 

| LocalPositivePrefix Numeral LocalPositiveSuffix 

| LocalNegativePrefix Numeral LocalNegativeSuffix 



DecimalNumeral:: = Numeral 

| Numeral LocalDecimalSeparator Digit* 

| LocalDecimalSeparator Digit+ 



Exponent:: = ( [eE] [+-]? Digit+ ) 



Decimal:: = ( [-+]? DecimalNumeral Exponent? ) 

| LocalPositivePrefix DecimalNumeral LocalPositiveSuffix Exponent? 

| LocalNegativePrefix DecimalNumeral LocalNegativeSuffix Exponent? 



HexFloat:: = [-+]? 0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+ ([pP][-+]?[0-9]+)? 



NonNumber:: = NaN | LocalNan | Infinity | LocalInfinity 



SignedNonNumber:: = ( [-+]? NonNumber ) 

| LocalPositivePrefix NonNumber LocalPositiveSuffix 

| LocalNegativePrefix NonNumber LocalNegativeSuffix 



Float:: = Decimal 

| HexFloat 

| SignedNonNumber 



Whitespace is not significant in the above regular expressions. 


*java.util.Scanner(File)*

public Scanner(java.io.File source)
  throws |java.io.FileNotFoundException|
         
Constructs a new Scanner that produces values scanned from the specified file. 
Bytes from the file are converted into characters using the underlying 
platform's default charset(|java.nio.charset.Charset|) . 

    source - A file to be scanned 

*java.util.Scanner(File,String)*

public Scanner(
  java.io.File source,
  java.lang.String charsetName)
  throws |java.io.FileNotFoundException|
         
Constructs a new Scanner that produces values scanned from the specified file. 
Bytes from the file are converted into characters using the specified charset. 

    source - A file to be scanned 
    charsetName - The encoding type used to convert bytes from the file into characters to be 
       scanned 

*java.util.Scanner(InputStream)*

public Scanner(java.io.InputStream source)

Constructs a new Scanner that produces values scanned from the specified input 
stream. Bytes from the stream are converted into characters using the 
underlying platform's default charset(|java.nio.charset.Charset|) . 

    source - An input stream to be scanned 

*java.util.Scanner(InputStream,String)*

public Scanner(
  java.io.InputStream source,
  java.lang.String charsetName)

Constructs a new Scanner that produces values scanned from the specified input 
stream. Bytes from the stream are converted into characters using the specified 
charset. 

    source - An input stream to be scanned 
    charsetName - The encoding type used to convert bytes from the stream into characters to be 
       scanned 

*java.util.Scanner(Readable)*

public Scanner(java.lang.Readable source)

Constructs a new Scanner that produces values scanned from the specified 
source. 

    source - A character source implementing the {@link Readable} interface 

*java.util.Scanner(ReadableByteChannel)*

public Scanner(java.nio.channels.ReadableByteChannel source)

Constructs a new Scanner that produces values scanned from the specified 
channel. Bytes from the source are converted into characters using the 
underlying platform's default charset(|java.nio.charset.Charset|) . 

    source - A channel to scan 

*java.util.Scanner(ReadableByteChannel,String)*

public Scanner(
  java.nio.channels.ReadableByteChannel source,
  java.lang.String charsetName)

Constructs a new Scanner that produces values scanned from the specified 
channel. Bytes from the source are converted into characters using the 
specified charset. 

    source - A channel to scan 
    charsetName - The encoding type used to convert bytes from the channel into characters to be 
       scanned 

*java.util.Scanner(String)*

public Scanner(java.lang.String source)

Constructs a new Scanner that produces values scanned from the specified 
string. 

    source - A string to scan 

*java.util.Scanner.close()*

public void close()

Closes this scanner. 

If this scanner has not yet been closed then if its underlying 
readable(|java.lang.Readable|) also implements the (|java.io.Closeable|) 
interface then the readable's close method will be invoked. If this scanner is 
already closed then invoking this method will have no effect. 

Attempting to perform search operations after a scanner has been closed will 
result in an (|java.lang.IllegalStateException|) . 


*java.util.Scanner.delimiter()*

public |java.util.regex.Pattern| delimiter()

Returns the Pattern this Scanner is currently using to match delimiters. 


    Returns: this scanner's delimiting pattern. 
*java.util.Scanner.findInLine(Pattern)*

public |java.lang.String| findInLine(java.util.regex.Pattern pattern)

Attempts to find the next occurrence of the specified pattern ignoring 
delimiters. If the pattern is found before the next line separator, the scanner 
advances past the input that matched and returns the string that matched the 
pattern. If no such pattern is detected in the input up to the next line 
separator, then null is returned and the scanner's position is unchanged. This 
method may block waiting for input that matches the pattern. 

Since this method continues to search through the input looking for the 
specified pattern, it may buffer all of the input searching for the desired 
token if no line separators are present. 

    pattern - the pattern to scan for 

    Returns: the text that matched the specified pattern 
*java.util.Scanner.findInLine(String)*

public |java.lang.String| findInLine(java.lang.String pattern)

Attempts to find the next occurrence of a pattern constructed from the 
specified string, ignoring delimiters. 

An invocation of this method of the form findInLine(pattern) behaves in exactly 
the same way as the invocation findInLine(Pattern.compile(pattern)). 

    pattern - a string specifying the pattern to search for 

    Returns: the text that matched the specified pattern 
*java.util.Scanner.findWithinHorizon(Pattern,int)*

public |java.lang.String| findWithinHorizon(
  java.util.regex.Pattern pattern,
  int horizon)

Attempts to find the next occurrence of the specified pattern. 

This method searches through the input up to the specified search horizon, 
ignoring delimiters. If the pattern is found the scanner advances past the 
input that matched and returns the string that matched the pattern. If no such 
pattern is detected then the null is returned and the scanner's position 
remains unchanged. This method may block waiting for input that matches the 
pattern. 

A scanner will never search more than horizon code points beyond its current 
position. Note that a match may be clipped by the horizon; that is, an 
arbitrary match result may have been different if the horizon had been larger. 
The scanner treats the horizon as a transparent, non-anchoring bound (see 
(|java.util.regex.Matcher|) and (|java.util.regex.Matcher|) ). 

If horizon is 0, then the horizon is ignored and this method continues to 
search through the input looking for the specified pattern without bound. In 
this case it may buffer all of the input searching for the pattern. 

If horizon is negative, then an IllegalArgumentException is thrown. 

    pattern - the pattern to scan for 

    Returns: the text that matched the specified pattern 
*java.util.Scanner.findWithinHorizon(String,int)*

public |java.lang.String| findWithinHorizon(
  java.lang.String pattern,
  int horizon)

Attempts to find the next occurrence of a pattern constructed from the 
specified string, ignoring delimiters. 

An invocation of this method of the form findWithinHorizon(pattern) behaves in 
exactly the same way as the invocation 
findWithinHorizon(Pattern.compile(pattern, horizon)). 

    pattern - a string specifying the pattern to search for 

    Returns: the text that matched the specified pattern 
*java.util.Scanner.hasNext()*

public boolean hasNext()

Returns true if this scanner has another token in its input. This method may 
block while waiting for input to scan. The scanner does not advance past any 
input. 


    Returns: true if and only if this scanner has another token 
*java.util.Scanner.hasNext(Pattern)*

public boolean hasNext(java.util.regex.Pattern pattern)

Returns true if the next complete token matches the specified pattern. A 
complete token is prefixed and postfixed by input that matches the delimiter 
pattern. This method may block while waiting for input. The scanner does not 
advance past any input. 

    pattern - the pattern to scan for 

    Returns: true if and only if this scanner has another token matching the specified 
             pattern 
*java.util.Scanner.hasNext(String)*

public boolean hasNext(java.lang.String pattern)

Returns true if the next token matches the pattern constructed from the 
specified string. The scanner does not advance past any input. 

An invocation of this method of the form hasNext(pattern) behaves in exactly 
the same way as the invocation hasNext(Pattern.compile(pattern)). 

    pattern - a string specifying the pattern to scan 

    Returns: true if and only if this scanner has another token matching the specified 
             pattern 
*java.util.Scanner.hasNextBigDecimal()*

public boolean hasNextBigDecimal()

Returns true if the next token in this scanner's input can be interpreted as a 
BigDecimal using the (|java.util.Scanner|) method. The scanner does not advance 
past any input. 


    Returns: true if and only if this scanner's next token is a valid BigDecimal 
*java.util.Scanner.hasNextBigInteger()*

public boolean hasNextBigInteger()

Returns true if the next token in this scanner's input can be interpreted as a 
BigInteger in the default radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 


    Returns: true if and only if this scanner's next token is a valid BigInteger 
*java.util.Scanner.hasNextBigInteger(int)*

public boolean hasNextBigInteger(int radix)

Returns true if the next token in this scanner's input can be interpreted as a 
BigInteger in the specified radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 

    radix - the radix used to interpret the token as an integer 

    Returns: true if and only if this scanner's next token is a valid BigInteger 
*java.util.Scanner.hasNextBoolean()*

public boolean hasNextBoolean()

Returns true if the next token in this scanner's input can be interpreted as a 
boolean value using a case insensitive pattern created from the string 
"true|false". The scanner does not advance past the input that matched. 


    Returns: true if and only if this scanner's next token is a valid boolean value 
*java.util.Scanner.hasNextByte()*

public boolean hasNextByte()

Returns true if the next token in this scanner's input can be interpreted as a 
byte value in the default radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 


    Returns: true if and only if this scanner's next token is a valid byte value 
*java.util.Scanner.hasNextByte(int)*

public boolean hasNextByte(int radix)

Returns true if the next token in this scanner's input can be interpreted as a 
byte value in the specified radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 

    radix - the radix used to interpret the token as a byte value 

    Returns: true if and only if this scanner's next token is a valid byte value 
*java.util.Scanner.hasNextDouble()*

public boolean hasNextDouble()

Returns true if the next token in this scanner's input can be interpreted as a 
double value using the (|java.util.Scanner|) method. The scanner does not 
advance past any input. 


    Returns: true if and only if this scanner's next token is a valid double value 
*java.util.Scanner.hasNextFloat()*

public boolean hasNextFloat()

Returns true if the next token in this scanner's input can be interpreted as a 
float value using the (|java.util.Scanner|) method. The scanner does not 
advance past any input. 


    Returns: true if and only if this scanner's next token is a valid float value 
*java.util.Scanner.hasNextInt()*

public boolean hasNextInt()

Returns true if the next token in this scanner's input can be interpreted as an 
int value in the default radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 


    Returns: true if and only if this scanner's next token is a valid int value 
*java.util.Scanner.hasNextInt(int)*

public boolean hasNextInt(int radix)

Returns true if the next token in this scanner's input can be interpreted as an 
int value in the specified radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 

    radix - the radix used to interpret the token as an int value 

    Returns: true if and only if this scanner's next token is a valid int value 
*java.util.Scanner.hasNextLine()*

public boolean hasNextLine()

Returns true if there is another line in the input of this scanner. This method 
may block while waiting for input. The scanner does not advance past any input. 


    Returns: true if and only if this scanner has another line of input 
*java.util.Scanner.hasNextLong()*

public boolean hasNextLong()

Returns true if the next token in this scanner's input can be interpreted as a 
long value in the default radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 


    Returns: true if and only if this scanner's next token is a valid long value 
*java.util.Scanner.hasNextLong(int)*

public boolean hasNextLong(int radix)

Returns true if the next token in this scanner's input can be interpreted as a 
long value in the specified radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 

    radix - the radix used to interpret the token as a long value 

    Returns: true if and only if this scanner's next token is a valid long value 
*java.util.Scanner.hasNextShort()*

public boolean hasNextShort()

Returns true if the next token in this scanner's input can be interpreted as a 
short value in the default radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 


    Returns: true if and only if this scanner's next token is a valid short value in the 
             default radix 
*java.util.Scanner.hasNextShort(int)*

public boolean hasNextShort(int radix)

Returns true if the next token in this scanner's input can be interpreted as a 
short value in the specified radix using the (|java.util.Scanner|) method. The 
scanner does not advance past any input. 

    radix - the radix used to interpret the token as a short value 

    Returns: true if and only if this scanner's next token is a valid short value in the 
             specified radix 
*java.util.Scanner.ioException()*

public |java.io.IOException| ioException()

Returns the IOException last thrown by this Scanner's underlying Readable. This 
method returns null if no such exception exists. 


    Returns: the last exception thrown by this scanner's readable 
*java.util.Scanner.locale()*

public |java.util.Locale| locale()

Returns this scanner's locale. 

A scanner's locale affects many elements of its default primitive matching 
regular expressions; see localized numbers above. 


    Returns: this scanner's locale 
*java.util.Scanner.match()*

public |java.util.regex.MatchResult| match()

Returns the match result of the last scanning operation performed by this 
scanner. This method throws IllegalStateException if no match has been 
performed, or if the last match was not successful. 

The various nextmethods of Scanner make a match result available if they 
complete without throwing an exception. For instance, after an invocation of 
the (|java.util.Scanner|) method that returned an int, this method returns a 
MatchResult for the search of the Integer regular expression defined above. 
Similarly the (|java.util.Scanner|) , (|java.util.Scanner|) , and 
(|java.util.Scanner|) methods will make a match available if they succeed. 


    Returns: a match result for the last match operation 
*java.util.Scanner.next()*

public |java.lang.String| next()

Finds and returns the next complete token from this scanner. A complete token 
is preceded and followed by input that matches the delimiter pattern. This 
method may block while waiting for input to scan, even if a previous invocation 
of (|java.util.Scanner|) returned true. 


    Returns: the next token 
*java.util.Scanner.next(Pattern)*

public |java.lang.String| next(java.util.regex.Pattern pattern)

Returns the next token if it matches the specified pattern. This method may 
block while waiting for input to scan, even if a previous invocation of 
(|java.util.Scanner|) returned true. If the match is successful, the scanner 
advances past the input that matched the pattern. 

    pattern - the pattern to scan for 

    Returns: the next token 
*java.util.Scanner.next(String)*

public |java.lang.String| next(java.lang.String pattern)

Returns the next token if it matches the pattern constructed from the specified 
string. If the match is successful, the scanner advances past the input that 
matched the pattern. 

An invocation of this method of the form next(pattern) behaves in exactly the 
same way as the invocation next(Pattern.compile(pattern)). 

    pattern - a string specifying the pattern to scan 

    Returns: the next token 
*java.util.Scanner.nextBigDecimal()*

public |java.math.BigDecimal| nextBigDecimal()

Scans the next token of the input as a BigDecimal(|java.math.BigDecimal|) . 

If the next token matches the Decimal regular expression defined above then the 
token is converted into a BigDecimal value as if by removing all group 
separators, mapping non-ASCII digits into ASCII digits via the 
Character.digit(|java.lang.Character|) , and passing the resulting string to 
the BigDecimal(String)(|java.math.BigDecimal|) constructor. 


    Returns: the BigDecimal scanned from the input 
*java.util.Scanner.nextBigInteger()*

public |java.math.BigInteger| nextBigInteger()

Scans the next token of the input as a BigInteger(|java.math.BigInteger|) . 

An invocation of this method of the form nextBigInteger() behaves in exactly 
the same way as the invocation nextBigInteger(radix), where radix is the 
default radix of this scanner. 


    Returns: the BigInteger scanned from the input 
*java.util.Scanner.nextBigInteger(int)*

public |java.math.BigInteger| nextBigInteger(int radix)

Scans the next token of the input as a BigInteger(|java.math.BigInteger|) . 

If the next token matches the Integer regular expression defined above then the 
token is converted into a BigInteger value as if by removing all group 
separators, mapping non-ASCII digits into ASCII digits via the 
Character.digit(|java.lang.Character|) , and passing the resulting string to 
the BigInteger(String, int)(|java.math.BigInteger|) constructor with the 
specified radix. 

    radix - the radix used to interpret the token 

    Returns: the BigInteger scanned from the input 
*java.util.Scanner.nextBoolean()*

public boolean nextBoolean()

Scans the next token of the input into a boolean value and returns that value. 
This method will throw InputMismatchException if the next token cannot be 
translated into a valid boolean value. If the match is successful, the scanner 
advances past the input that matched. 


    Returns: the boolean scanned from the input 
*java.util.Scanner.nextByte()*

public byte nextByte()

Scans the next token of the input as a byte. 

An invocation of this method of the form nextByte() behaves in exactly the same 
way as the invocation nextByte(radix), where radix is the default radix of this 
scanner. 


    Returns: the byte scanned from the input 
*java.util.Scanner.nextByte(int)*

public byte nextByte(int radix)

Scans the next token of the input as a byte. This method will throw 
InputMismatchException if the next token cannot be translated into a valid byte 
value as described below. If the translation is successful, the scanner 
advances past the input that matched. 

If the next token matches the Integer regular expression defined above then the 
token is converted into a byte value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Byte.parseByte(|java.lang.Byte|) with the specified radix. 

    radix - the radix used to interpret the token as a byte value 

    Returns: the byte scanned from the input 
*java.util.Scanner.nextDouble()*

public double nextDouble()

Scans the next token of the input as a double. This method will throw 
InputMismatchException if the next token cannot be translated into a valid 
double value. If the translation is successful, the scanner advances past the 
input that matched. 

If the next token matches the Float regular expression defined above then the 
token is converted into a double value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Double.parseDouble(|java.lang.Double|) . If the token matches the localized NaN 
or infinity strings, then either "Nan" or "Infinity" is passed to 
Double.parseDouble(|java.lang.Double|) as appropriate. 


    Returns: the double scanned from the input 
*java.util.Scanner.nextFloat()*

public float nextFloat()

Scans the next token of the input as a float. This method will throw 
InputMismatchException if the next token cannot be translated into a valid 
float value as described below. If the translation is successful, the scanner 
advances past the input that matched. 

If the next token matches the Float regular expression defined above then the 
token is converted into a float value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Float.parseFloat(|java.lang.Float|) . If the token matches the localized NaN or 
infinity strings, then either "Nan" or "Infinity" is passed to 
Float.parseFloat(|java.lang.Float|) as appropriate. 


    Returns: the float scanned from the input 
*java.util.Scanner.nextInt()*

public int nextInt()

Scans the next token of the input as an int. 

An invocation of this method of the form nextInt() behaves in exactly the same 
way as the invocation nextInt(radix), where radix is the default radix of this 
scanner. 


    Returns: the int scanned from the input 
*java.util.Scanner.nextInt(int)*

public int nextInt(int radix)

Scans the next token of the input as an int. This method will throw 
InputMismatchException if the next token cannot be translated into a valid int 
value as described below. If the translation is successful, the scanner 
advances past the input that matched. 

If the next token matches the Integer regular expression defined above then the 
token is converted into an int value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Integer.parseInt(|java.lang.Integer|) with the specified radix. 

    radix - the radix used to interpret the token as an int value 

    Returns: the int scanned from the input 
*java.util.Scanner.nextLine()*

public |java.lang.String| nextLine()

Advances this scanner past the current line and returns the input that was 
skipped. 

This method returns the rest of the current line, excluding any line separator 
at the end. The position is set to the beginning of the next line. 

Since this method continues to search through the input looking for a line 
separator, it may buffer all of the input searching for the line to skip if no 
line separators are present. 


    Returns: the line that was skipped 
*java.util.Scanner.nextLong()*

public long nextLong()

Scans the next token of the input as a long. 

An invocation of this method of the form nextLong() behaves in exactly the same 
way as the invocation nextLong(radix), where radix is the default radix of this 
scanner. 


    Returns: the long scanned from the input 
*java.util.Scanner.nextLong(int)*

public long nextLong(int radix)

Scans the next token of the input as a long. This method will throw 
InputMismatchException if the next token cannot be translated into a valid long 
value as described below. If the translation is successful, the scanner 
advances past the input that matched. 

If the next token matches the Integer regular expression defined above then the 
token is converted into an long value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Long.parseLong(|java.lang.Long|) with the specified radix. 

    radix - the radix used to interpret the token as an int value 

    Returns: the long scanned from the input 
*java.util.Scanner.nextShort()*

public short nextShort()

Scans the next token of the input as a short. 

An invocation of this method of the form nextShort() behaves in exactly the 
same way as the invocation nextShort(radix), where radix is the default radix 
of this scanner. 


    Returns: the short scanned from the input 
*java.util.Scanner.nextShort(int)*

public short nextShort(int radix)

Scans the next token of the input as a short. This method will throw 
InputMismatchException if the next token cannot be translated into a valid 
short value as described below. If the translation is successful, the scanner 
advances past the input that matched. 

If the next token matches the Integer regular expression defined above then the 
token is converted into a short value as if by removing all locale specific 
prefixes, group separators, and locale specific suffixes, then mapping 
non-ASCII digits into ASCII digits via Character.digit(|java.lang.Character|) , 
prepending a negative sign (-) if the locale specific negative prefixes and 
suffixes were present, and passing the resulting string to 
Short.parseShort(|java.lang.Short|) with the specified radix. 

    radix - the radix used to interpret the token as a short value 

    Returns: the short scanned from the input 
*java.util.Scanner.radix()*

public int radix()

Returns this scanner's default radix. 

A scanner's radix affects elements of its default number matching regular 
expressions; see localized numbers above. 


    Returns: the default radix of this scanner 
*java.util.Scanner.remove()*

public void remove()

The remove operation is not supported by this implementation of Iterator. 


*java.util.Scanner.skip(Pattern)*

public |java.util.Scanner| skip(java.util.regex.Pattern pattern)

Skips input that matches the specified pattern, ignoring delimiters. This 
method will skip input if an anchored match of the specified pattern succeeds. 

If a match to the specified pattern is not found at the current position, then 
no input is skipped and a NoSuchElementException is thrown. 

Since this method seeks to match the specified pattern starting at the 
scanner's current position, patterns that can match a lot of input (".*", for 
example) may cause the scanner to buffer a large amount of input. 

Note that it is possible to skip something without risking a 
NoSuchElementException by using a pattern that can match nothing, e.g., 
sc.skip("[ \t]*"). 

    pattern - a string specifying the pattern to skip over 

    Returns: 
*java.util.Scanner.skip(String)*

public |java.util.Scanner| skip(java.lang.String pattern)

Skips input that matches a pattern constructed from the specified string. 

An invocation of this method of the form skip(pattern) behaves in exactly the 
same way as the invocation skip(Pattern.compile(pattern)). 

    pattern - a string specifying the pattern to skip over 

    Returns: 
*java.util.Scanner.toString()*

public |java.lang.String| toString()

Returns the string representation of this Scanner. The string representation of 
a Scanner contains information that may be useful for debugging. The exact 
format is unspecified. 


    Returns: The string representation of this scanner 
*java.util.Scanner.useDelimiter(Pattern)*

public |java.util.Scanner| useDelimiter(java.util.regex.Pattern pattern)

Sets this scanner's delimiting pattern to the specified pattern. 

    pattern - A delimiting pattern 

    Returns: 
*java.util.Scanner.useDelimiter(String)*

public |java.util.Scanner| useDelimiter(java.lang.String pattern)

Sets this scanner's delimiting pattern to a pattern constructed from the 
specified String. 

An invocation of this method of the form useDelimiter(pattern) behaves in 
exactly the same way as the invocation hasDelimiter(Pattern.compile(pattern)). 

    pattern - A string specifying a delimiting pattern 

    Returns: 
*java.util.Scanner.useLocale(Locale)*

public |java.util.Scanner| useLocale(java.util.Locale locale)

Sets this scanner's locale to the specified locale. 

A scanner's locale affects many elements of its default primitive matching 
regular expressions; see localized numbers above. 

    locale - A string specifying the locale to use 

    Returns: 
*java.util.Scanner.useRadix(int)*

public |java.util.Scanner| useRadix(int radix)

Sets this scanner's default radix to the specified radix. 

A scanner's radix affects elements of its default number matching regular 
expressions; see localized numbers above. 

If the radix is less than Character.MIN_RADIX or greater than 
Character.MAX_RADIX, then an IllegalArgumentException is thrown. 

    radix - The radix to use when scanning numbers 

    Returns: 

