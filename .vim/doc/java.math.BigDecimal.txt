*java.math.BigDecimal* *BigDecimal* Immutable, arbitrary-precision signed decima

public class BigDecimal
  extends    |java.lang.Number|
  implements |java.lang.Comparable|

|java.math.BigDecimal_Description|
|java.math.BigDecimal_Fields|
|java.math.BigDecimal_Constructors|
|java.math.BigDecimal_Methods|

================================================================================

*java.math.BigDecimal_Fields*
|java.math.BigDecimal_java.math.BigDecimal.ONE|
|int_java.math.BigDecimal.ROUND_CEILING|
|int_java.math.BigDecimal.ROUND_DOWN|
|int_java.math.BigDecimal.ROUND_FLOOR|
|int_java.math.BigDecimal.ROUND_HALF_DOWN|
|int_java.math.BigDecimal.ROUND_HALF_EVEN|
|int_java.math.BigDecimal.ROUND_HALF_UP|
|int_java.math.BigDecimal.ROUND_UNNECESSARY|
|int_java.math.BigDecimal.ROUND_UP|
|java.math.BigDecimal_java.math.BigDecimal.TEN|
|java.math.BigDecimal_java.math.BigDecimal.ZERO|

*java.math.BigDecimal_Constructors*
|java.math.BigDecimal(BigInteger)|Translates a BigInteger into a BigDecimal.
|java.math.BigDecimal(BigInteger,int)|Translates a BigInteger unscaled value an
|java.math.BigDecimal(BigInteger,int,MathContext)|Translates a BigInteger unsca
|java.math.BigDecimal(BigInteger,MathContext)|Translates a BigInteger into a Bi
|java.math.BigDecimal(char[])|Translates a character array representation of a 
|java.math.BigDecimal(char[],int,int)|Translates a character array representati
|java.math.BigDecimal(char[],int,int,MathContext)|Translates a character array 
|java.math.BigDecimal(char[],MathContext)|Translates a character array represen
|java.math.BigDecimal(double)|Translates a double into a BigDecimal which  is t
|java.math.BigDecimal(double,MathContext)|Translates a double into a BigDecimal
|java.math.BigDecimal(int)|Translates an int into a BigDecimal.
|java.math.BigDecimal(int,MathContext)|Translates an int into a BigDecimal, wit
|java.math.BigDecimal(long)|Translates a long into a BigDecimal.
|java.math.BigDecimal(long,MathContext)|Translates a long into a BigDecimal, wi
|java.math.BigDecimal(String)|Translates the string representation of a BigDeci
|java.math.BigDecimal(String,MathContext)|Translates the string representation 

*java.math.BigDecimal_Methods*
|java.math.BigDecimal.abs()|Returns a BigDecimal whose value is the absolute va
|java.math.BigDecimal.abs(MathContext)|Returns a BigDecimal whose value is the 
|java.math.BigDecimal.add(BigDecimal)|Returns a BigDecimal whose value is (this
|java.math.BigDecimal.add(BigDecimal,MathContext)|Returns a BigDecimal whose va
|java.math.BigDecimal.byteValueExact()|Converts this BigDecimal to a byte, chec
|java.math.BigDecimal.compareTo(BigDecimal)|Compares this BigDecimal with the s
|java.math.BigDecimal.divide(BigDecimal)|Returns a BigDecimal whose value is (t
|java.math.BigDecimal.divide(BigDecimal,int)|Returns a BigDecimal whose value i
|java.math.BigDecimal.divide(BigDecimal,int,int)|Returns a BigDecimal whose val
|java.math.BigDecimal.divide(BigDecimal,int,RoundingMode)|Returns a BigDecimal 
|java.math.BigDecimal.divide(BigDecimal,MathContext)|Returns a BigDecimal whose
|java.math.BigDecimal.divide(BigDecimal,RoundingMode)|Returns a BigDecimal whos
|java.math.BigDecimal.divideAndRemainder(BigDecimal)|Returns a two-element BigD
|java.math.BigDecimal.divideAndRemainder(BigDecimal,MathContext)|Returns a two-
|java.math.BigDecimal.divideToIntegralValue(BigDecimal)|Returns a BigDecimal wh
|java.math.BigDecimal.divideToIntegralValue(BigDecimal,MathContext)|Returns a B
|java.math.BigDecimal.doubleValue()|Converts this BigDecimal to a double.
|java.math.BigDecimal.equals(Object)|Compares this BigDecimal with the specifie
|java.math.BigDecimal.floatValue()|Converts this BigDecimal to a float.
|java.math.BigDecimal.hashCode()|Returns the hash code for this BigDecimal.
|java.math.BigDecimal.intValue()|Converts this BigDecimal to an int.
|java.math.BigDecimal.intValueExact()|Converts this BigDecimal to an int, check
|java.math.BigDecimal.longValue()|Converts this BigDecimal to a long.
|java.math.BigDecimal.longValueExact()|Converts this BigDecimal to a long, chec
|java.math.BigDecimal.max(BigDecimal)|Returns the maximum of this BigDecimal an
|java.math.BigDecimal.min(BigDecimal)|Returns the minimum of this BigDecimal an
|java.math.BigDecimal.movePointLeft(int)|Returns a BigDecimal which is equivale
|java.math.BigDecimal.movePointRight(int)|Returns a BigDecimal which is equival
|java.math.BigDecimal.multiply(BigDecimal)|Returns a BigDecimal whose value is 
|java.math.BigDecimal.multiply(BigDecimal,MathContext)|Returns a BigDecimal who
|java.math.BigDecimal.negate()|Returns a BigDecimal whose value is (-this),  an
|java.math.BigDecimal.negate(MathContext)|Returns a BigDecimal whose value is (
|java.math.BigDecimal.plus()|Returns a BigDecimal whose value is (+this), and w
|java.math.BigDecimal.plus(MathContext)|Returns a BigDecimal whose value is (+t
|java.math.BigDecimal.pow(int)|Returns a BigDecimal whose value is  (thisn), Th
|java.math.BigDecimal.pow(int,MathContext)|Returns a BigDecimal whose value is 
|java.math.BigDecimal.precision()|Returns the precision of this BigDecimal.
|java.math.BigDecimal.remainder(BigDecimal)|Returns a BigDecimal whose value is
|java.math.BigDecimal.remainder(BigDecimal,MathContext)|Returns a BigDecimal wh
|java.math.BigDecimal.round(MathContext)|Returns a BigDecimal rounded according
|java.math.BigDecimal.scale()|Returns the scale of this BigDecimal.
|java.math.BigDecimal.scaleByPowerOfTen(int)|Returns a BigDecimal whose numeric
|java.math.BigDecimal.setScale(int)|Returns a BigDecimal whose scale is the spe
|java.math.BigDecimal.setScale(int,int)|Returns a BigDecimal whose scale is the
|java.math.BigDecimal.setScale(int,RoundingMode)|Returns a BigDecimal whose sca
|java.math.BigDecimal.shortValueExact()|Converts this BigDecimal to a short, ch
|java.math.BigDecimal.signum()|Returns the signum function of this BigDecimal.
|java.math.BigDecimal.stripTrailingZeros()|Returns a BigDecimal which is numeri
|java.math.BigDecimal.subtract(BigDecimal)|Returns a BigDecimal whose value is 
|java.math.BigDecimal.subtract(BigDecimal,MathContext)|Returns a BigDecimal who
|java.math.BigDecimal.toBigInteger()|Converts this BigDecimal to a BigInteger.
|java.math.BigDecimal.toBigIntegerExact()|Converts this BigDecimal to a BigInte
|java.math.BigDecimal.toEngineeringString()|Returns a string representation of 
|java.math.BigDecimal.toPlainString()|Returns a string representation of this B
|java.math.BigDecimal.toString()|Returns the string representation of this BigD
|java.math.BigDecimal.ulp()|Returns the size of an ulp, a unit in the last plac
|java.math.BigDecimal.unscaledValue()|Returns a BigInteger whose value is the u
|java.math.BigDecimal.valueOf(double)|Translates a double into a BigDecimal, us
|java.math.BigDecimal.valueOf(long)|Translates a long value into a BigDecimal  
|java.math.BigDecimal.valueOf(long,int)|Translates a long unscaled value and an

*java.math.BigDecimal_Description*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*java.math.BigDecimal_java.math.BigDecimal.ONE*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_CEILING*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_DOWN*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_FLOOR*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_HALF_DOWN*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_HALF_EVEN*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_HALF_UP*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_UNNECESSARY*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*int_java.math.BigDecimal.ROUND_UP*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*java.math.BigDecimal_java.math.BigDecimal.TEN*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 


*java.math.BigDecimal_java.math.BigDecimal.ZERO*

Immutable, arbitrary-precision signed decimal numbers. A BigDecimal consists of 
an arbitrary precision integer unscaled value and a 32-bit integer scale. If 
zero or positive, the scale is the number of digits to the right of the decimal 
point. If negative, the unscaled value of the number is multiplied by ten to 
the power of the negation of the scale. The value of the number represented by 
the BigDecimal is therefore (unscaledValue 10-scale). 

The BigDecimal class provides operations for arithmetic, scale manipulation, 
rounding, comparison, hashing, and format conversion. The 
(|java.math.BigDecimal|) method provides a canonical representation of a 
BigDecimal. 

The BigDecimal class gives its user complete control over rounding behavior. If 
no rounding mode is specified and the exact result cannot be represented, an 
exception is thrown; otherwise, calculations can be carried out to a chosen 
precision and rounding mode by supplying an appropriate 
(|java.math.MathContext|) object to the operation. In either case, eight 
rounding modes are provided for the control of rounding. Using the integer 
fields in this class (such as (|java.math.BigDecimal|) ) to represent rounding 
mode is largely obsolete; the enumeration values of the RoundingMode enum, 
(such as (|java.math.RoundingMode|) ) should be used instead. 

When a MathContext object is supplied with a precision setting of 0 (for 
example, (|java.math.MathContext|) ), arithmetic operations are exact, as are 
the arithmetic methods which take no MathContext object. (This is the only 
behavior that was supported in releases prior to 5.) As a corollary of 
computing the exact result, the rounding mode setting of a MathContext object 
with a precision setting of 0 is not used and thus irrelevant. In the case of 
divide, the exact quotient could have an infinitely long decimal expansion; for 
example, 1 divided by 3. If the quotient has a nonterminating decimal expansion 
and the operation is specified to return an exact result, an 
ArithmeticException is thrown. Otherwise, the exact result of the division is 
returned, as done for other operations. 

When the precision setting is not 0, the rules of BigDecimal arithmetic are 
broadly compatible with selected modes of operation of the arithmetic defined 
in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4). Unlike those 
standards, BigDecimal includes many rounding modes, which were mandatory for 
division in BigDecimal releases prior to 5. Any conflicts between these ANSI 
standards and the BigDecimal specification are resolved in favor of BigDecimal. 

Since the same numerical value can have different representations (with 
different scales), the rules of arithmetic and rounding must specify both the 
numerical result and the scale used in the result's representation. 

In general the rounding modes and precision setting determine how operations 
return results with a limited number of digits when the exact result has more 
digits (perhaps infinitely many in the case of division) than the number of 
digits returned. 

First, the total number of digits to return is specified by the MathContext's 
precision setting; this determines the result's precision. The digit count 
starts from the leftmost nonzero digit of the exact result. The rounding mode 
determines how any discarded trailing digits affect the returned result. 

For all arithmetic operators , the operation is carried out as though an exact 
intermediate result were first calculated and then rounded to the number of 
digits specified by the precision setting (if necessary), using the selected 
rounding mode. If the exact result is not returned, some digit positions of the 
exact result are discarded. When rounding increases the magnitude of the 
returned result, it is possible for a new digit position to be created by a 
carry propagating to a leading 9 digit. For example, rounding the value 999.9 
to three digits rounding up would be numerically equal to one thousand, 
represented as 100101. In such cases, the new 1 is the leading digit position 
of the returned result. 

Besides a logical exact result, each arithmetic operation has a preferred scale 
for representing a result. The preferred scale for each operation is listed in 
the table below. 

Preferred Scales for Results of Arithmetic Operations 

OperationPreferred Scale of Result Addmax(addend.scale(), augend.scale()) 
Subtractmax(minuend.scale(), subtrahend.scale()) Multiplymultiplier.scale() + 
multiplicand.scale() Dividedividend.scale() - divisor.scale() 

These scales are the ones used by the methods which return exact arithmetic 
results; except that an exact divide may have to use a larger scale since the 
exact result may have more digits. For example, 1/32 is 0.03125. 

Before rounding, the scale of the logical exact intermediate result is the 
preferred scale for that operation. If the exact numerical result cannot be 
represented in precision digits, rounding selects the set of digits to return 
and the scale of the result is reduced from the scale of the intermediate 
result to the least scale which can represent the precision digits actually 
returned. If the exact result can be represented with at most precision digits, 
the representation of the result with the scale closest to the preferred scale 
is returned. In particular, an exactly representable quotient may be 
represented in fewer than precision digits by removing trailing zeros and 
decreasing the scale. For example, rounding to three digits using the 
floor(|java.math.RoundingMode|) rounding mode, 

19/100 = 0.19 // integer=19, scale=2 

but 

21/110 = 0.190 // integer=190, scale=3 

Note that for add, subtract, and multiply, the reduction in scale will equal 
the number of digit positions of the exact result which are discarded. If the 
rounding causes a carry propagation to create a new high-order digit position, 
an additional digit of the result is discarded than when no new digit position 
is created. 

Other methods may have slightly different rounding semantics. For example, the 
result of the pow method using the specified algorithm(|java.math.BigDecimal|) 
can occasionally differ from the rounded mathematical result by more than one 
unit in the last place, one ulp(|java.math.BigDecimal|) . 

Two types of operations are provided for manipulating the scale of a 
BigDecimal: scaling/rounding operations and decimal point motion operations. 
Scaling/rounding operations ( setScale(|java.math.BigDecimal|) and 
round(|java.math.BigDecimal|) ) return a BigDecimal whose value is 
approximately (or exactly) equal to that of the operand, but whose scale or 
precision is the specified value; that is, they increase or decrease the 
precision of the stored number with minimal effect on its value. Decimal point 
motion operations ( movePointLeft(|java.math.BigDecimal|) and 
movePointRight(|java.math.BigDecimal|) ) return a BigDecimal created from the 
operand by moving the decimal point a specified distance in the specified 
direction. 

For the sake of brevity and clarity, pseudo-code is used throughout the 
descriptions of BigDecimal methods. The pseudo-code expression (i + j) is 
shorthand for a BigDecimal whose value is that of the BigDecimal i added to 
that of the BigDecimal j. The pseudo-code expression (i == j) is shorthand for 
true if and only if the BigDecimal i represents the same value as the 
BigDecimal j. Other pseudo-code expressions are interpreted similarly. Square 
brackets are used to represent the particular BigInteger and scale pair 
defining a BigDecimal value; for example [19, 2] is the BigDecimal numerically 
equal to 0.19 having a scale of 2. 

Note: care should be exercised if BigDecimal objects are used as keys in a 
SortedMap(|java.util.SortedMap|) or elements in a 
SortedSet(|java.util.SortedSet|) since BigDecimal's natural ordering is 
inconsistent with equals. See (|java.lang.Comparable|) , 
(|java.util.SortedMap|) or (|java.util.SortedSet|) for more information. 

All methods and constructors for this class throw NullPointerException when 
passed a null object reference for any input parameter. 



*java.math.BigDecimal(BigInteger)*

public BigDecimal(java.math.BigInteger val)

Translates a BigInteger into a BigDecimal. The scale of the BigDecimal is zero. 

    val - BigInteger value to be converted to BigDecimal. 

*java.math.BigDecimal(BigInteger,int)*

public BigDecimal(
  java.math.BigInteger unscaledVal,
  int scale)

Translates a BigInteger unscaled value and an int scale into a BigDecimal. The 
value of the BigDecimal is (unscaledVal 10-scale). 

    unscaledVal - unscaled value of the BigDecimal. 
    scale - scale of the BigDecimal. 

*java.math.BigDecimal(BigInteger,int,MathContext)*

public BigDecimal(
  java.math.BigInteger unscaledVal,
  int scale,
  java.math.MathContext mc)

Translates a BigInteger unscaled value and an int scale into a BigDecimal, with 
rounding according to the context settings. The value of the BigDecimal is 
(unscaledVal 10-scale), rounded according to the precision and rounding mode 
settings. 

    unscaledVal - unscaled value of the BigDecimal. 
    scale - scale of the BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal(BigInteger,MathContext)*

public BigDecimal(
  java.math.BigInteger val,
  java.math.MathContext mc)

Translates a BigInteger into a BigDecimal rounding according to the context 
settings. The scale of the BigDecimal is zero. 

    val - BigInteger value to be converted to BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal(char[])*

public BigDecimal(char[] in)

Translates a character array representation of a BigDecimal into a BigDecimal, 
accepting the same sequence of characters as the (|java.math.BigDecimal|) 
constructor. 

Note that if the sequence of characters is already available as a character 
array, using this constructor is faster than converting the char array to 
string and using the BigDecimal(String) constructor . 

    in - char array that is the source of characters. 

*java.math.BigDecimal(char[],int,int)*

public BigDecimal(
  char[] in,
  int offset,
  int len)

Translates a character array representation of a BigDecimal into a BigDecimal, 
accepting the same sequence of characters as the (|java.math.BigDecimal|) 
constructor, while allowing a sub-array to be specified. 

Note that if the sequence of characters is already available within a character 
array, using this constructor is faster than converting the char array to 
string and using the BigDecimal(String) constructor . 

    in - char array that is the source of characters. 
    offset - first character in the array to inspect. 
    len - number of characters to consider. 

*java.math.BigDecimal(char[],int,int,MathContext)*

public BigDecimal(
  char[] in,
  int offset,
  int len,
  java.math.MathContext mc)

Translates a character array representation of a BigDecimal into a BigDecimal, 
accepting the same sequence of characters as the (|java.math.BigDecimal|) 
constructor, while allowing a sub-array to be specified and with rounding 
according to the context settings. 

Note that if the sequence of characters is already available within a character 
array, using this constructor is faster than converting the char array to 
string and using the BigDecimal(String) constructor . 

    in - char array that is the source of characters. 
    offset - first character in the array to inspect. 
    len - number of characters to consider.. 
    mc - the context to use. 

*java.math.BigDecimal(char[],MathContext)*

public BigDecimal(
  char[] in,
  java.math.MathContext mc)

Translates a character array representation of a BigDecimal into a BigDecimal, 
accepting the same sequence of characters as the (|java.math.BigDecimal|) 
constructor and with rounding according to the context settings. 

Note that if the sequence of characters is already available as a character 
array, using this constructor is faster than converting the char array to 
string and using the BigDecimal(String) constructor . 

    in - char array that is the source of characters. 
    mc - the context to use. 

*java.math.BigDecimal(double)*

public BigDecimal(double val)

Translates a double into a BigDecimal which is the exact decimal representation 
of the double's binary floating-point value. The scale of the returned 
BigDecimal is the smallest value such that (10scale val) is an integer. 

Notes: 

The results of this constructor can be somewhat unpredictable. One might assume 
that writing new BigDecimal(0.1) in Java creates a BigDecimal which is exactly 
equal to 0.1 (an unscaled value of 1, with a scale of 1), but it is actually 
equal to 0.1000000000000000055511151231257827021181583404541015625. This is 
because 0.1 cannot be represented exactly as a double (or, for that matter, as 
a binary fraction of any finite length). Thus, the value that is being passed 
in to the constructor is not exactly equal to 0.1, appearances notwithstanding. 

The String constructor, on the other hand, is perfectly predictable: writing 
new BigDecimal("0.1") creates a BigDecimal which is exactly equal to 0.1, as 
one would expect. Therefore, it is generally recommended that the 
<tt>String</tt> constructor(|java.math.BigDecimal|) be used in preference to 
this one. 

When a double must be used as a source for a BigDecimal, note that this 
constructor provides an exact conversion; it does not give the same result as 
converting the double to a String using the (|java.lang.Double|) method and 
then using the (|java.math.BigDecimal|) constructor. To get that result, use 
the static (|java.math.BigDecimal|) method. 

    val - double value to be converted to BigDecimal. 

*java.math.BigDecimal(double,MathContext)*

public BigDecimal(
  double val,
  java.math.MathContext mc)

Translates a double into a BigDecimal, with rounding according to the context 
settings. The scale of the BigDecimal is the smallest value such that (10scale 
val) is an integer. 

The results of this constructor can be somewhat unpredictable and its use is 
generally not recommended; see the notes under the (|java.math.BigDecimal|) 
constructor. 

    val - double value to be converted to BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal(int)*

public BigDecimal(int val)

Translates an int into a BigDecimal. The scale of the BigDecimal is zero. 

    val - int value to be converted to BigDecimal. 

*java.math.BigDecimal(int,MathContext)*

public BigDecimal(
  int val,
  java.math.MathContext mc)

Translates an int into a BigDecimal, with rounding according to the context 
settings. The scale of the BigDecimal, before any rounding, is zero. 

    val - int value to be converted to BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal(long)*

public BigDecimal(long val)

Translates a long into a BigDecimal. The scale of the BigDecimal is zero. 

    val - long value to be converted to BigDecimal. 

*java.math.BigDecimal(long,MathContext)*

public BigDecimal(
  long val,
  java.math.MathContext mc)

Translates a long into a BigDecimal, with rounding according to the context 
settings. The scale of the BigDecimal, before any rounding, is zero. 

    val - long value to be converted to BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal(String)*

public BigDecimal(java.lang.String val)

Translates the string representation of a BigDecimal into a BigDecimal. The 
string representation consists of an optional sign, '+' ('u002B') or '-' 
('u002D'), followed by a sequence of zero or more decimal digits ("the 
integer"), optionally followed by a fraction, optionally followed by an 
exponent. 

The fraction consists of a decimal point followed by zero or more decimal 
digits. The string must contain at least one digit in either the integer or the 
fraction. The number formed by the sign, the integer and the fraction is 
referred to as the significand. 

The exponent consists of the character 'e' ('u0075') or 'E' ('u0045') followed 
by one or more decimal digits. The value of the exponent must lie between - 
(|java.lang.Integer|) ( (|java.lang.Integer|) +1) and (|java.lang.Integer|) , 
inclusive. 

More formally, the strings this constructor accepts are described by the 
following grammar: 

BigDecimalString: Signopt Significand Exponentopt 

Sign: + - 

Significand: IntegerPart . FractionPartopt . FractionPart IntegerPart 

IntegerPart: Digits 

FractionPart: Digits 

Exponent: ExponentIndicator SignedInteger 

ExponentIndicator: e E 

SignedInteger: Signopt Digits 

Digits: Digit Digits Digit 

Digit: any character for which (|java.lang.Character|) returns true, including 
0, 1, 2 ... 



The scale of the returned BigDecimal will be the number of digits in the 
fraction, or zero if the string contains no decimal point, subject to 
adjustment for any exponent; if the string contains an exponent, the exponent 
is subtracted from the scale. The value of the resulting scale must lie between 
Integer.MIN_VALUE and Integer.MAX_VALUE, inclusive. 

The character-to-digit mapping is provided by (|java.lang.Character|) set to 
convert to radix 10. The String may not contain any extraneous characters 
(whitespace, for example). 

Examples: The value of the returned BigDecimal is equal to significand 
10exponent. For each string on the left, the resulting representation 
[BigInteger, scale] is shown on the right. 

"0" [0,0] "0.00" [0,2] "123" [123,0] "-123" [-123,0] "1.23E3" [123,-1] 
"1.23E+3" [123,-1] "12.3E+7" [123,-6] "12.0" [120,1] "12.3" [123,1] "0.00123" 
[123,5] "-1.23E-12" [-123,14] "1234.5E-4" [12345,5] "0E+7" [0,-7] "-0" [0,0] 

Note: For values other than float and double NaN and Infinity, this constructor 
is compatible with the values returned by (|java.lang.Float|) and 
(|java.lang.Double|) . This is generally the preferred way to convert a float 
or double into a BigDecimal, as it doesn't suffer from the unpredictability of 
the (|java.math.BigDecimal|) constructor. 

    val - String representation of BigDecimal. 

*java.math.BigDecimal(String,MathContext)*

public BigDecimal(
  java.lang.String val,
  java.math.MathContext mc)

Translates the string representation of a BigDecimal into a BigDecimal, 
accepting the same strings as the (|java.math.BigDecimal|) constructor, with 
rounding according to the context settings. 

    val - string representation of a BigDecimal. 
    mc - the context to use. 

*java.math.BigDecimal.abs()*

public |java.math.BigDecimal| abs()

Returns a BigDecimal whose value is the absolute value of this BigDecimal, and 
whose scale is this.scale(). 


    Returns: 
*java.math.BigDecimal.abs(MathContext)*

public |java.math.BigDecimal| abs(java.math.MathContext mc)

Returns a BigDecimal whose value is the absolute value of this BigDecimal, with 
rounding according to the context settings. 

    mc - the context to use. 

    Returns: abs(this), rounded as necessary. 
*java.math.BigDecimal.add(BigDecimal)*

public |java.math.BigDecimal| add(java.math.BigDecimal augend)

Returns a BigDecimal whose value is (this + augend), and whose scale is 
max(this.scale(), augend.scale()). 

    augend - value to be added to this BigDecimal. 

    Returns: this + augend 
*java.math.BigDecimal.add(BigDecimal,MathContext)*

public |java.math.BigDecimal| add(
  java.math.BigDecimal augend,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (this + augend), with rounding according to 
the context settings. 

If either number is zero and the precision setting is nonzero then the other 
number, rounded if necessary, is used as the result. 

    augend - value to be added to this BigDecimal. 
    mc - the context to use. 

    Returns: this + augend, rounded as necessary. 
*java.math.BigDecimal.byteValueExact()*

public byte byteValueExact()

Converts this BigDecimal to a byte, checking for lost information. If this 
BigDecimal has a nonzero fractional part or is out of the possible range for a 
byte result then an ArithmeticException is thrown. 


    Returns: this BigDecimal converted to an byte. 
*java.math.BigDecimal.compareTo(BigDecimal)*

public int compareTo(java.math.BigDecimal val)

Compares this BigDecimal with the specified BigDecimal. Two BigDecimal objects 
that are equal in value but have a different scale (like 2.0 and 2.00) are 
considered equal by this method. This method is provided in preference to 
individual methods for each of the six boolean comparison operators (<, ==, >, 
>=, !=, <=). The suggested idiom for performing these comparisons is: 
(x.compareTo(y) <op> 0), where <op> is one of the six comparison operators. 

    val - BigDecimal to which this BigDecimal is to be compared. 

    Returns: -1, 0, or 1 as this BigDecimal is numerically less than, equal to, or greater 
             than val. 
*java.math.BigDecimal.divide(BigDecimal)*

public |java.math.BigDecimal| divide(java.math.BigDecimal divisor)

Returns a BigDecimal whose value is (this / divisor), and whose preferred scale 
is (this.scale() - divisor.scale()); if the exact quotient cannot be 
represented (because it has a non-terminating decimal expansion) an 
ArithmeticException is thrown. 

    divisor - value by which this BigDecimal is to be divided. 

    Returns: this / divisor 
*java.math.BigDecimal.divide(BigDecimal,int)*

public |java.math.BigDecimal| divide(
  java.math.BigDecimal divisor,
  int roundingMode)

Returns a BigDecimal whose value is (this / divisor), and whose scale is 
this.scale(). If rounding must be performed to generate a result with the given 
scale, the specified rounding mode is applied. 

The new (|java.math.BigDecimal|) method should be used in preference to this 
legacy method. 

    divisor - value by which this BigDecimal is to be divided. 
    roundingMode - rounding mode to apply. 

    Returns: this / divisor 
*java.math.BigDecimal.divide(BigDecimal,int,int)*

public |java.math.BigDecimal| divide(
  java.math.BigDecimal divisor,
  int scale,
  int roundingMode)

Returns a BigDecimal whose value is (this / divisor), and whose scale is as 
specified. If rounding must be performed to generate a result with the 
specified scale, the specified rounding mode is applied. 

The new (|java.math.BigDecimal|) method should be used in preference to this 
legacy method. 

    divisor - value by which this BigDecimal is to be divided. 
    scale - scale of the BigDecimal quotient to be returned. 
    roundingMode - rounding mode to apply. 

    Returns: this / divisor 
*java.math.BigDecimal.divide(BigDecimal,int,RoundingMode)*

public |java.math.BigDecimal| divide(
  java.math.BigDecimal divisor,
  int scale,
  java.math.RoundingMode roundingMode)

Returns a BigDecimal whose value is (this / divisor), and whose scale is as 
specified. If rounding must be performed to generate a result with the 
specified scale, the specified rounding mode is applied. 

    divisor - value by which this BigDecimal is to be divided. 
    scale - scale of the BigDecimal quotient to be returned. 
    roundingMode - rounding mode to apply. 

    Returns: this / divisor 
*java.math.BigDecimal.divide(BigDecimal,MathContext)*

public |java.math.BigDecimal| divide(
  java.math.BigDecimal divisor,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (this / divisor), with rounding according 
to the context settings. 

    divisor - value by which this BigDecimal is to be divided. 
    mc - the context to use. 

    Returns: this / divisor, rounded as necessary. 
*java.math.BigDecimal.divide(BigDecimal,RoundingMode)*

public |java.math.BigDecimal| divide(
  java.math.BigDecimal divisor,
  java.math.RoundingMode roundingMode)

Returns a BigDecimal whose value is (this / divisor), and whose scale is 
this.scale(). If rounding must be performed to generate a result with the given 
scale, the specified rounding mode is applied. 

    divisor - value by which this BigDecimal is to be divided. 
    roundingMode - rounding mode to apply. 

    Returns: this / divisor 
*java.math.BigDecimal.divideAndRemainder(BigDecimal)*

public |java.math.BigDecimal| divideAndRemainder(java.math.BigDecimal divisor)

Returns a two-element BigDecimal array containing the result of 
divideToIntegralValue followed by the result of remainder on the two operands. 

Note that if both the integer quotient and remainder are needed, this method is 
faster than using the divideToIntegralValue and remainder methods separately 
because the division need only be carried out once. 

    divisor - value by which this BigDecimal is to be divided, and the remainder computed. 

    Returns: a two element BigDecimal array: the quotient (the result of 
             divideToIntegralValue) is the initial element and the remainder is 
             the final element. 
*java.math.BigDecimal.divideAndRemainder(BigDecimal,MathContext)*

public |java.math.BigDecimal| divideAndRemainder(
  java.math.BigDecimal divisor,
  java.math.MathContext mc)

Returns a two-element BigDecimal array containing the result of 
divideToIntegralValue followed by the result of remainder on the two operands 
calculated with rounding according to the context settings. 

Note that if both the integer quotient and remainder are needed, this method is 
faster than using the divideToIntegralValue and remainder methods separately 
because the division need only be carried out once. 

    divisor - value by which this BigDecimal is to be divided, and the remainder computed. 
    mc - the context to use. 

    Returns: a two element BigDecimal array: the quotient (the result of 
             divideToIntegralValue) is the initial element and the remainder is 
             the final element. 
*java.math.BigDecimal.divideToIntegralValue(BigDecimal)*

public |java.math.BigDecimal| divideToIntegralValue(java.math.BigDecimal divisor)

Returns a BigDecimal whose value is the integer part of the quotient (this / 
divisor) rounded down. The preferred scale of the result is (this.scale() - 
divisor.scale()). 

    divisor - value by which this BigDecimal is to be divided. 

    Returns: The integer part of this / divisor. 
*java.math.BigDecimal.divideToIntegralValue(BigDecimal,MathContext)*

public |java.math.BigDecimal| divideToIntegralValue(
  java.math.BigDecimal divisor,
  java.math.MathContext mc)

Returns a BigDecimal whose value is the integer part of (this / divisor). Since 
the integer part of the exact quotient does not depend on the rounding mode, 
the rounding mode does not affect the values returned by this method. The 
preferred scale of the result is (this.scale() - divisor.scale()). An 
ArithmeticException is thrown if the integer part of the exact quotient needs 
more than mc.precision digits. 

    divisor - value by which this BigDecimal is to be divided. 
    mc - the context to use. 

    Returns: The integer part of this / divisor. 
*java.math.BigDecimal.doubleValue()*

public double doubleValue()

Converts this BigDecimal to a double. This conversion is similar to the 
narrowing primitive conversion from double to float as defined in the Java 
Language Specification: if this BigDecimal has too great a magnitude represent 
as a double, it will be converted to (|java.lang.Double|) or 
(|java.lang.Double|) as appropriate. Note that even when the return value is 
finite, this conversion can lose information about the precision of the 
BigDecimal value. 


    Returns: this BigDecimal converted to a double. 
*java.math.BigDecimal.equals(Object)*

public boolean equals(java.lang.Object x)

Compares this BigDecimal with the specified Object for equality. Unlike 
compareTo(|java.math.BigDecimal|) , this method considers two BigDecimal 
objects equal only if they are equal in value and scale (thus 2.0 is not equal 
to 2.00 when compared by this method). 

    x - Object to which this BigDecimal is to be compared. 

    Returns: true if and only if the specified Object is a BigDecimal whose value and scale 
             are equal to this BigDecimal's. 
*java.math.BigDecimal.floatValue()*

public float floatValue()

Converts this BigDecimal to a float. This conversion is similar to the 
narrowing primitive conversion from double to float defined in the Java 
Language Specification: if this BigDecimal has too great a magnitude to 
represent as a float, it will be converted to (|java.lang.Float|) or 
(|java.lang.Float|) as appropriate. Note that even when the return value is 
finite, this conversion can lose information about the precision of the 
BigDecimal value. 


    Returns: this BigDecimal converted to a float. 
*java.math.BigDecimal.hashCode()*

public int hashCode()

Returns the hash code for this BigDecimal. Note that two BigDecimal objects 
that are numerically equal but differ in scale (like 2.0 and 2.00) will 
generally not have the same hash code. 


    Returns: hash code for this BigDecimal. 
*java.math.BigDecimal.intValue()*

public int intValue()

Converts this BigDecimal to an int. This conversion is analogous to a narrowing 
primitive conversion from double to short as defined in the Java Language 
Specification: any fractional part of this BigDecimal will be discarded, and if 
the resulting BigInteger is too big to fit in an int, only the low-order 32 
bits are returned. Note that this conversion can lose information about the 
overall magnitude and precision of this BigDecimal value as well as return a 
result with the opposite sign. 


    Returns: this BigDecimal converted to an int. 
*java.math.BigDecimal.intValueExact()*

public int intValueExact()

Converts this BigDecimal to an int, checking for lost information. If this 
BigDecimal has a nonzero fractional part or is out of the possible range for an 
int result then an ArithmeticException is thrown. 


    Returns: this BigDecimal converted to an int. 
*java.math.BigDecimal.longValue()*

public long longValue()

Converts this BigDecimal to a long. This conversion is analogous to a narrowing 
primitive conversion from double to short as defined in the Java Language 
Specification: any fractional part of this BigDecimal will be discarded, and if 
the resulting BigInteger is too big to fit in a long, only the low-order 64 
bits are returned. Note that this conversion can lose information about the 
overall magnitude and precision of this BigDecimal value as well as return a 
result with the opposite sign. 


    Returns: this BigDecimal converted to an long. 
*java.math.BigDecimal.longValueExact()*

public long longValueExact()

Converts this BigDecimal to a long, checking for lost information. If this 
BigDecimal has a nonzero fractional part or is out of the possible range for a 
long result then an ArithmeticException is thrown. 


    Returns: this BigDecimal converted to a long. 
*java.math.BigDecimal.max(BigDecimal)*

public |java.math.BigDecimal| max(java.math.BigDecimal val)

Returns the maximum of this BigDecimal and val. 

    val - value with which the maximum is to be computed. 

    Returns: the BigDecimal whose value is the greater of this BigDecimal and val. If they 
             are equal, as defined by the {@link #compareTo(BigDecimal) 
             compareTo} method, this is returned. 
*java.math.BigDecimal.min(BigDecimal)*

public |java.math.BigDecimal| min(java.math.BigDecimal val)

Returns the minimum of this BigDecimal and val. 

    val - value with which the minimum is to be computed. 

    Returns: the BigDecimal whose value is the lesser of this BigDecimal and val. If they 
             are equal, as defined by the {@link #compareTo(BigDecimal) 
             compareTo} method, this is returned. 
*java.math.BigDecimal.movePointLeft(int)*

public |java.math.BigDecimal| movePointLeft(int n)

Returns a BigDecimal which is equivalent to this one with the decimal point 
moved n places to the left. If n is non-negative, the call merely adds n to the 
scale. If n is negative, the call is equivalent to movePointRight(-n). The 
BigDecimal returned by this call has value (this 10-n) and scale 
max(this.scale()+n, 0). 

    n - number of places to move the decimal point to the left. 

    Returns: a BigDecimal which is equivalent to this one with the decimal point moved n 
             places to the left. 
*java.math.BigDecimal.movePointRight(int)*

public |java.math.BigDecimal| movePointRight(int n)

Returns a BigDecimal which is equivalent to this one with the decimal point 
moved n places to the right. If n is non-negative, the call merely subtracts n 
from the scale. If n is negative, the call is equivalent to movePointLeft(-n). 
The BigDecimal returned by this call has value (this 10n) and scale 
max(this.scale()-n, 0). 

    n - number of places to move the decimal point to the right. 

    Returns: a BigDecimal which is equivalent to this one with the decimal point moved n 
             places to the right. 
*java.math.BigDecimal.multiply(BigDecimal)*

public |java.math.BigDecimal| multiply(java.math.BigDecimal multiplicand)

Returns a BigDecimal whose value is (this multiplicand), and whose scale is 
(this.scale() + multiplicand.scale()). 

    multiplicand - value to be multiplied by this BigDecimal. 

    Returns: this * multiplicand 
*java.math.BigDecimal.multiply(BigDecimal,MathContext)*

public |java.math.BigDecimal| multiply(
  java.math.BigDecimal multiplicand,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (this multiplicand), with rounding 
according to the context settings. 

    multiplicand - value to be multiplied by this BigDecimal. 
    mc - the context to use. 

    Returns: this * multiplicand, rounded as necessary. 
*java.math.BigDecimal.negate()*

public |java.math.BigDecimal| negate()

Returns a BigDecimal whose value is (-this), and whose scale is this.scale(). 


    Returns: 
*java.math.BigDecimal.negate(MathContext)*

public |java.math.BigDecimal| negate(java.math.MathContext mc)

Returns a BigDecimal whose value is (-this), with rounding according to the 
context settings. 

    mc - the context to use. 

    Returns: -this, rounded as necessary. 
*java.math.BigDecimal.plus()*

public |java.math.BigDecimal| plus()

Returns a BigDecimal whose value is (+this), and whose scale is this.scale(). 

This method, which simply returns this BigDecimal is included for symmetry with 
the unary minus method (|java.math.BigDecimal|) . 


    Returns: 
*java.math.BigDecimal.plus(MathContext)*

public |java.math.BigDecimal| plus(java.math.MathContext mc)

Returns a BigDecimal whose value is (+this), with rounding according to the 
context settings. 

The effect of this method is identical to that of the (|java.math.BigDecimal|) 
method. 

    mc - the context to use. 

    Returns: this, rounded as necessary. A zero result will have a scale of 0. 
*java.math.BigDecimal.pow(int)*

public |java.math.BigDecimal| pow(int n)

Returns a BigDecimal whose value is (thisn), The power is computed exactly, to 
unlimited precision. 

The parameter n must be in the range 0 through 999999999, inclusive. 
ZERO.pow(0) returns (|java.math.BigDecimal|) . 

Note that future releases may expand the allowable exponent range of this 
method. 

    n - power to raise this BigDecimal to. 

    Returns: 
*java.math.BigDecimal.pow(int,MathContext)*

public |java.math.BigDecimal| pow(
  int n,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (thisn). The current implementation uses 
the core algorithm defined in ANSI standard X3.274-1996 with rounding according 
to the context settings. In general, the returned numerical value is within two 
ulps of the exact numerical value for the chosen precision. Note that future 
releases may use a different algorithm with a decreased allowable error bound 
and increased allowable exponent range. 

The X3.274-1996 algorithm is: 

An ArithmeticException exception is thrown if 

abs(n) > 999999999 mc.precision == 0 and n < 0 mc.precision > 0 and n has more 
than mc.precision decimal digits 

if n is zero, (|java.math.BigDecimal|) is returned even if this is zero, 
otherwise 

if n is positive, the result is calculated via the repeated squaring technique 
into a single accumulator. The individual multiplications with the accumulator 
use the same math context settings as in mc except for a precision increased to 
mc.precision + elength + 1 where elength is the number of decimal digits in n. 

if n is negative, the result is calculated as if n were positive; this value is 
then divided into one using the working precision specified above. 

The final value from either the positive or negative case is then rounded to 
the destination precision. 



    n - power to raise this BigDecimal to. 
    mc - the context to use. 

    Returns: thisn using the ANSI standard X3.274-1996 algorithm 
*java.math.BigDecimal.precision()*

public int precision()

Returns the precision of this BigDecimal. (The precision is the number of 
digits in the unscaled value.) 

The precision of a zero value is 1. 


    Returns: the precision of this BigDecimal. 
*java.math.BigDecimal.remainder(BigDecimal)*

public |java.math.BigDecimal| remainder(java.math.BigDecimal divisor)

Returns a BigDecimal whose value is (this % divisor). 

The remainder is given by 
this.subtract(this.divideToIntegralValue(divisor).multiply(divisor)). Note that 
this is not the modulo operation (the result can be negative). 

    divisor - value by which this BigDecimal is to be divided. 

    Returns: this % divisor. 
*java.math.BigDecimal.remainder(BigDecimal,MathContext)*

public |java.math.BigDecimal| remainder(
  java.math.BigDecimal divisor,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (this % divisor), with rounding according 
to the context settings. The MathContext settings affect the implicit divide 
used to compute the remainder. The remainder computation itself is by 
definition exact. Therefore, the remainder may contain more than 
mc.getPrecision() digits. 

The remainder is given by this.subtract(this.divideToIntegralValue(divisor, 
mc).multiply(divisor)). Note that this is not the modulo operation (the result 
can be negative). 

    divisor - value by which this BigDecimal is to be divided. 
    mc - the context to use. 

    Returns: this % divisor, rounded as necessary. 
*java.math.BigDecimal.round(MathContext)*

public |java.math.BigDecimal| round(java.math.MathContext mc)

Returns a BigDecimal rounded according to the MathContext settings. If the 
precision setting is 0 then no rounding takes place. 

The effect of this method is identical to that of the (|java.math.BigDecimal|) 
method. 

    mc - the context to use. 

    Returns: a BigDecimal rounded according to the MathContext settings. 
*java.math.BigDecimal.scale()*

public int scale()

Returns the scale of this BigDecimal. If zero or positive, the scale is the 
number of digits to the right of the decimal point. If negative, the unscaled 
value of the number is multiplied by ten to the power of the negation of the 
scale. For example, a scale of -3 means the unscaled value is multiplied by 
1000. 


    Returns: the scale of this BigDecimal. 
*java.math.BigDecimal.scaleByPowerOfTen(int)*

public |java.math.BigDecimal| scaleByPowerOfTen(int n)

Returns a BigDecimal whose numerical value is equal to (this * 10n). The scale 
of the result is (this.scale() - n). 


*java.math.BigDecimal.setScale(int)*

public |java.math.BigDecimal| setScale(int newScale)

Returns a BigDecimal whose scale is the specified value, and whose value is 
numerically equal to this BigDecimal's. Throws an ArithmeticException if this 
is not possible. 

This call is typically used to increase the scale, in which case it is 
guaranteed that there exists a BigDecimal of the specified scale and the 
correct value. The call can also be used to reduce the scale if the caller 
knows that the BigDecimal has sufficiently many zeros at the end of its 
fractional part (i.e., factors of ten in its integer value) to allow for the 
rescaling without changing its value. 

This method returns the same result as the two-argument versions of setScale, 
but saves the caller the trouble of specifying a rounding mode in cases where 
it is irrelevant. 

Note that since BigDecimal objects are immutable, calls of this method do not 
result in the original object being modified, contrary to the usual convention 
of having methods named setX mutate field X. Instead, setScale returns an 
object with the proper scale; the returned object may or may not be newly 
allocated. 

    newScale - scale of the BigDecimal value to be returned. 

    Returns: a BigDecimal whose scale is the specified value, and whose unscaled value is 
             determined by multiplying or dividing this BigDecimal's unscaled 
             value by the appropriate power of ten to maintain its overall 
             value. 
*java.math.BigDecimal.setScale(int,int)*

public |java.math.BigDecimal| setScale(
  int newScale,
  int roundingMode)

Returns a BigDecimal whose scale is the specified value, and whose unscaled 
value is determined by multiplying or dividing this BigDecimal's unscaled value 
by the appropriate power of ten to maintain its overall value. If the scale is 
reduced by the operation, the unscaled value must be divided (rather than 
multiplied), and the value may be changed; in this case, the specified rounding 
mode is applied to the division. 

Note that since BigDecimal objects are immutable, calls of this method do not 
result in the original object being modified, contrary to the usual convention 
of having methods named setX mutate field X. Instead, setScale returns an 
object with the proper scale; the returned object may or may not be newly 
allocated. 

The new (|java.math.BigDecimal|) method should be used in preference to this 
legacy method. 

    newScale - scale of the BigDecimal value to be returned. 
    roundingMode - The rounding mode to apply. 

    Returns: a BigDecimal whose scale is the specified value, and whose unscaled value is 
             determined by multiplying or dividing this BigDecimal's unscaled 
             value by the appropriate power of ten to maintain its overall 
             value. 
*java.math.BigDecimal.setScale(int,RoundingMode)*

public |java.math.BigDecimal| setScale(
  int newScale,
  java.math.RoundingMode roundingMode)

Returns a BigDecimal whose scale is the specified value, and whose unscaled 
value is determined by multiplying or dividing this BigDecimal's unscaled value 
by the appropriate power of ten to maintain its overall value. If the scale is 
reduced by the operation, the unscaled value must be divided (rather than 
multiplied), and the value may be changed; in this case, the specified rounding 
mode is applied to the division. 

    newScale - scale of the BigDecimal value to be returned. 
    roundingMode - The rounding mode to apply. 

    Returns: a BigDecimal whose scale is the specified value, and whose unscaled value is 
             determined by multiplying or dividing this BigDecimal's unscaled 
             value by the appropriate power of ten to maintain its overall 
             value. 
*java.math.BigDecimal.shortValueExact()*

public short shortValueExact()

Converts this BigDecimal to a short, checking for lost information. If this 
BigDecimal has a nonzero fractional part or is out of the possible range for a 
short result then an ArithmeticException is thrown. 


    Returns: this BigDecimal converted to a short. 
*java.math.BigDecimal.signum()*

public int signum()

Returns the signum function of this BigDecimal. 


    Returns: -1, 0, or 1 as the value of this BigDecimal is negative, zero, or positive. 
*java.math.BigDecimal.stripTrailingZeros()*

public |java.math.BigDecimal| stripTrailingZeros()

Returns a BigDecimal which is numerically equal to this one but with any 
trailing zeros removed from the representation. For example, stripping the 
trailing zeros from the BigDecimal value 600.0, which has [BigInteger, scale] 
components equals to [6000, 1], yields 6E2 with [BigInteger, scale] components 
equals to [6, -2] 


    Returns: a numerically equal BigDecimal with any trailing zeros removed. 
*java.math.BigDecimal.subtract(BigDecimal)*

public |java.math.BigDecimal| subtract(java.math.BigDecimal subtrahend)

Returns a BigDecimal whose value is (this - subtrahend), and whose scale is 
max(this.scale(), subtrahend.scale()). 

    subtrahend - value to be subtracted from this BigDecimal. 

    Returns: this - subtrahend 
*java.math.BigDecimal.subtract(BigDecimal,MathContext)*

public |java.math.BigDecimal| subtract(
  java.math.BigDecimal subtrahend,
  java.math.MathContext mc)

Returns a BigDecimal whose value is (this - subtrahend), with rounding 
according to the context settings. 

If subtrahend is zero then this, rounded if necessary, is used as the result. 
If this is zero then the result is subtrahend.negate(mc). 

    subtrahend - value to be subtracted from this BigDecimal. 
    mc - the context to use. 

    Returns: this - subtrahend, rounded as necessary. 
*java.math.BigDecimal.toBigInteger()*

public |java.math.BigInteger| toBigInteger()

Converts this BigDecimal to a BigInteger. This conversion is analogous to a 
narrowing primitive conversion from double to long as defined in the Java 
Language Specification: any fractional part of this BigDecimal will be 
discarded. Note that this conversion can lose information about the precision 
of the BigDecimal value. 

To have an exception thrown if the conversion is inexact (in other words if a 
nonzero fractional part is discarded), use the (|java.math.BigDecimal|) method. 


    Returns: this BigDecimal converted to a BigInteger. 
*java.math.BigDecimal.toBigIntegerExact()*

public |java.math.BigInteger| toBigIntegerExact()

Converts this BigDecimal to a BigInteger, checking for lost information. An 
exception is thrown if this BigDecimal has a nonzero fractional part. 


    Returns: this BigDecimal converted to a BigInteger. 
*java.math.BigDecimal.toEngineeringString()*

public |java.lang.String| toEngineeringString()

Returns a string representation of this BigDecimal, using engineering notation 
if an exponent is needed. 

Returns a string that represents the BigDecimal as described in the 
(|java.math.BigDecimal|) method, except that if exponential notation is used, 
the power of ten is adjusted to be a multiple of three (engineering notation) 
such that the integer part of nonzero values will be in the range 1 through 
999. If exponential notation is used for zero values, a decimal point and one 
or two fractional zero digits are used so that the scale of the zero value is 
preserved. Note that unlike the output of (|java.math.BigDecimal|) , the output 
of this method is not guaranteed to recover the same [integer, scale] pair of 
this BigDecimal if the output string is converting back to a BigDecimal using 
the string constructor(|java.math.BigDecimal|) . The result of this method 
meets the weaker constraint of always producing a numerically equal result from 
applying the string constructor to the method's output. 


    Returns: string representation of this BigDecimal, using engineering notation if an 
             exponent is needed. 
*java.math.BigDecimal.toPlainString()*

public |java.lang.String| toPlainString()

Returns a string representation of this BigDecimal without an exponent field. 
For values with a positive scale, the number of digits to the right of the 
decimal point is used to indicate scale. For values with a zero or negative 
scale, the resulting string is generated as if the value were converted to a 
numerically equal value with zero scale and as if all the trailing zeros of the 
zero scale value were present in the result. 

The entire string is prefixed by a minus sign character '-' ('u002D') if the 
unscaled value is less than zero. No sign character is prefixed if the unscaled 
value is zero or positive. 

Note that if the result of this method is passed to the string 
constructor(|java.math.BigDecimal|) , only the numerical value of this 
BigDecimal will necessarily be recovered; the representation of the new 
BigDecimal may have a different scale. In particular, if this BigDecimal has a 
positive scale, the string resulting from this method will have a scale of zero 
when processed by the string constructor. 

(This method behaves analogously to the toString method in 1.4 and earlier 
releases.) 


    Returns: a string representation of this BigDecimal without an exponent field. 
*java.math.BigDecimal.toString()*

public |java.lang.String| toString()

Returns the string representation of this BigDecimal, using scientific notation 
if an exponent is needed. 

A standard canonical string form of the BigDecimal is created as though by the 
following steps: first, the absolute value of the unscaled value of the 
BigDecimal is converted to a string in base ten using the characters '0' 
through '9' with no leading zeros (except if its value is zero, in which case a 
single '0' character is used). 

Next, an adjusted exponent is calculated; this is the negated scale, plus the 
number of characters in the converted unscaled value, less one. That is, 
-scale+(ulength-1), where ulength is the length of the absolute value of the 
unscaled value in decimal digits (its precision). 

If the scale is greater than or equal to zero and the adjusted exponent is 
greater than or equal to -6, the number will be converted to a character form 
without using exponential notation. In this case, if the scale is zero then no 
decimal point is added and if the scale is positive a decimal point will be 
inserted with the scale specifying the number of characters to the right of the 
decimal point. '0' characters are added to the left of the converted unscaled 
value as necessary. If no character precedes the decimal point after this 
insertion then a conventional '0' character is prefixed. 

Otherwise (that is, if the scale is negative, or the adjusted exponent is less 
than -6), the number will be converted to a character form using exponential 
notation. In this case, if the converted BigInteger has more than one digit a 
decimal point is inserted after the first digit. An exponent in character form 
is then suffixed to the converted unscaled value (perhaps with inserted decimal 
point); this comprises the letter 'E' followed immediately by the adjusted 
exponent converted to a character form. The latter is in base ten, using the 
characters '0' through '9' with no leading zeros, and is always prefixed by a 
sign character '-' ('u002D') if the adjusted exponent is negative, '+' 
('u002B') otherwise). 

Finally, the entire string is prefixed by a minus sign character '-' ('u002D') 
if the unscaled value is less than zero. No sign character is prefixed if the 
unscaled value is zero or positive. 

Examples: For each representation [unscaled value, scale] on the left, the 
resulting string is shown on the right. 

[123,0] 123 [-123,0] -123 [123,-1] 1.23E+3 [123,-3] 1.23E+5 [123,1] 12.3 
[123,5] 0.00123 [123,10] 1.23E-8 [-123,12] -1.23E-10 

Notes: 

There is a one-to-one mapping between the distinguishable BigDecimal values and 
the result of this conversion. That is, every distinguishable BigDecimal value 
(unscaled value and scale) has a unique string representation as a result of 
using toString. If that string representation is converted back to a BigDecimal 
using the (|java.math.BigDecimal|) constructor, then the original value will be 
recovered. 

The string produced for a given number is always the same; it is not affected 
by locale. This means that it can be used as a canonical string representation 
for exchanging decimal data, or as a key for a Hashtable, etc. Locale-sensitive 
number formatting and parsing is handled by the (|java.text.NumberFormat|) 
class and its subclasses. 

The (|java.math.BigDecimal|) method may be used for presenting numbers with 
exponents in engineering notation, and the setScale(|java.math.BigDecimal|) 
method may be used for rounding a BigDecimal so it has a known number of digits 
after the decimal point. 

The digit-to-character mapping provided by Character.forDigit is used. 




    Returns: string representation of this BigDecimal. 
*java.math.BigDecimal.ulp()*

public |java.math.BigDecimal| ulp()

Returns the size of an ulp, a unit in the last place, of this BigDecimal. An 
ulp of a nonzero BigDecimal value is the positive distance between this value 
and the BigDecimal value next larger in magnitude with the same number of 
digits. An ulp of a zero value is numerically equal to 1 with the scale of 
this. The result is stored with the same scale as this so the result for zero 
and nonzero values is equal to [1, this.scale()]. 


    Returns: the size of an ulp of this 
*java.math.BigDecimal.unscaledValue()*

public |java.math.BigInteger| unscaledValue()

Returns a BigInteger whose value is the unscaled value of this BigDecimal. 
(Computes (this * 10this.scale()).) 


    Returns: the unscaled value of this BigDecimal. 
*java.math.BigDecimal.valueOf(double)*

public static |java.math.BigDecimal| valueOf(double val)

Translates a double into a BigDecimal, using the double's canonical string 
representation provided by the (|java.lang.Double|) method. 

Note: This is generally the preferred way to convert a double (or float) into a 
BigDecimal, as the value returned is equal to that resulting from constructing 
a BigDecimal from the result of using (|java.lang.Double|) . 

    val - double to convert to a BigDecimal. 

    Returns: a BigDecimal whose value is equal to or approximately equal to the value of 
             val. 
*java.math.BigDecimal.valueOf(long)*

public static |java.math.BigDecimal| valueOf(long val)

Translates a long value into a BigDecimal with a scale of zero. This static 
factory method is provided in preference to a (long) constructor because it 
allows for reuse of frequently used BigDecimal values. 

    val - value of the BigDecimal. 

    Returns: a BigDecimal whose value is val. 
*java.math.BigDecimal.valueOf(long,int)*

public static |java.math.BigDecimal| valueOf(
  long unscaledVal,
  int scale)

Translates a long unscaled value and an int scale into a BigDecimal. This 
static factory method is provided in preference to a (long, int) constructor 
because it allows for reuse of frequently used BigDecimal values.. 

    unscaledVal - unscaled value of the BigDecimal. 
    scale - scale of the BigDecimal. 

    Returns: a BigDecimal whose value is (unscaledVal 10-scale). 

