*javax.swing.JViewport* *JViewport* The "viewport" or "porthole" through which y

public class JViewport
  extends    |javax.swing.JComponent|
  implements |javax.accessibility.Accessible|

|javax.swing.JViewport_Description|
|javax.swing.JViewport_Fields|
|javax.swing.JViewport_Constructors|
|javax.swing.JViewport_Methods|

================================================================================

*javax.swing.JViewport_Fields*
|boolean_javax.swing.JViewport.backingStore|
|int_javax.swing.JViewport.BACKINGSTORE_SCROLL_MODE|
|java.awt.Image_javax.swing.JViewport.backingStoreImage|
|int_javax.swing.JViewport.BLIT_SCROLL_MODE|
|boolean_javax.swing.JViewport.isViewSizeSet|
|java.awt.Point_javax.swing.JViewport.lastPaintPosition|
|boolean_javax.swing.JViewport.scrollUnderway|
|int_javax.swing.JViewport.SIMPLE_SCROLL_MODE|

*javax.swing.JViewport_Constructors*
|javax.swing.JViewport()|Creates a JViewport.

*javax.swing.JViewport_Methods*
|javax.swing.JViewport.addChangeListener(ChangeListener)|Adds a ChangeListener 
|javax.swing.JViewport.addImpl(Component,Object,int)|Sets the JViewport's one l
|javax.swing.JViewport.computeBlit(int,int,Point,Point,Dimension,Rectangle)|Com
|javax.swing.JViewport.createLayoutManager()|Subclassers can override this to i
|javax.swing.JViewport.createViewListener()|Creates a listener for the view.
|javax.swing.JViewport.firePropertyChange(String,Object,Object)|Notifies listen
|javax.swing.JViewport.fireStateChanged()|Notifies all ChangeListeners when the
|javax.swing.JViewport.getAccessibleContext()|Gets the AccessibleContext associ
|javax.swing.JViewport.getChangeListeners()|Returns an array of all the ChangeL
|javax.swing.JViewport.getExtentSize()|Returns the size of the visible part of 
|javax.swing.JViewport.getInsets()|Returns the insets (border) dimensions as (0
|javax.swing.JViewport.getInsets(Insets)|Returns an Insets object containing th
|javax.swing.JViewport.getScrollMode()|Returns the current scrolling mode.
|javax.swing.JViewport.getUI()|Returns the Lobject that renders this component.
|javax.swing.JViewport.getUIClassID()|Returns a string that specifies the name 
|javax.swing.JViewport.getView()|Returns the JViewport's one child or null.
|javax.swing.JViewport.getViewPosition()|Returns the view coordinates that appe
|javax.swing.JViewport.getViewRect()|Returns a rectangle whose origin is getVie
|javax.swing.JViewport.getViewSize()|If the view's size hasn't been explicitly 
|javax.swing.JViewport.isBackingStoreEnabled()|Returns true if this viewport is
|javax.swing.JViewport.isOptimizedDrawingEnabled()|The JViewport overrides the 
|javax.swing.JViewport.paint(Graphics)|Depending on whether the backingStore is
|javax.swing.JViewport.paramString()|Returns a string representation of this JV
|javax.swing.JViewport.remove(Component)|Removes the Viewports one lightweight 
|javax.swing.JViewport.removeChangeListener(ChangeListener)|Removes a ChangeLis
|javax.swing.JViewport.repaint(long,int,int,int,int)|Always repaint in the pare
|javax.swing.JViewport.reshape(int,int,int,int)|Sets the bounds of this viewpor
|javax.swing.JViewport.scrollRectToVisible(Rectangle)|Scrolls the view so that 
|javax.swing.JViewport.setBackingStoreEnabled(boolean)|If true if this viewport
|javax.swing.JViewport.setBorder(Border)|The viewport "scrolls" its child (call
|javax.swing.JViewport.setExtentSize(Dimension)|Sets the size of the visible pa
|javax.swing.JViewport.setScrollMode(int)|Used to control the method of scrolli
|javax.swing.JViewport.setUI(ViewportUI)|Sets the Lobject that renders this com
|javax.swing.JViewport.setView(Component)|Sets the JViewport's one lightweight 
|javax.swing.JViewport.setViewPosition(Point)|Sets the view coordinates that ap
|javax.swing.JViewport.setViewSize(Dimension)|Sets the size of the view.
|javax.swing.JViewport.toViewCoordinates(Dimension)|Converts a size in pixel co
|javax.swing.JViewport.toViewCoordinates(Point)|Converts a point in pixel coord
|javax.swing.JViewport.updateUI()|Resets the UI property to a value from the cu

*javax.swing.JViewport_Description*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*boolean_javax.swing.JViewport.backingStore*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*int_javax.swing.JViewport.BACKINGSTORE_SCROLL_MODE*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*java.awt.Image_javax.swing.JViewport.backingStoreImage*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*int_javax.swing.JViewport.BLIT_SCROLL_MODE*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*boolean_javax.swing.JViewport.isViewSizeSet*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*java.awt.Point_javax.swing.JViewport.lastPaintPosition*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*boolean_javax.swing.JViewport.scrollUnderway*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*int_javax.swing.JViewport.SIMPLE_SCROLL_MODE*

The "viewport" or "porthole" through which you see the underlying information. 
When you scroll, what moves is the viewport. It is like peering through a 
camera's viewfinder. Moving the viewfinder upwards brings new things into view 
at the top of the picture and loses things that were at the bottom. 

By default, JViewport is opaque. To change this, use the setOpaque method. 

NOTE:We have implemented a faster scrolling algorithm that does not require a 
buffer to draw in. The algorithm works as follows: The view and parent view and 
checked to see if they are JComponents, if they aren't, stop and repaint the 
whole viewport. If the viewport is obscured by an ancestor, stop and repaint 
the whole viewport. Compute the region that will become visible, if it is as 
big as the viewport, stop and repaint the whole view region. Obtain the 
ancestor Window's graphics and do a copyArea on the scrolled region. Message 
the view to repaint the newly visible region. The next time paint is invoked on 
the viewport, if the clip region is smaller than the viewport size a timer is 
kicked off to repaint the whole region. 

In general this approach is much faster. Compared to the backing store approach 
this avoids the overhead of maintaining an offscreen buffer and having to do 
two copyAreas. Compared to the non backing store case this approach will 
greatly reduce the painted region. 

This approach can cause slower times than the backing store approach when the 
viewport is obscured by another window, or partially offscreen. When another 
window obscures the viewport the copyArea will copy garbage and a paint event 
will be generated by the system to inform us we need to paint the newly exposed 
region. The only way to handle this is to repaint the whole viewport, which can 
cause slower performance than the backing store case. In most applications very 
rarely will the user be scrolling while the viewport is obscured by another 
window or offscreen, so this optimization is usually worth the performance hit 
when obscured. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 



*javax.swing.JViewport()*

public JViewport()

Creates a JViewport. 


*javax.swing.JViewport.addChangeListener(ChangeListener)*

public void addChangeListener(javax.swing.event.ChangeListener l)

Adds a ChangeListener to the list that is notified each time the view's size, 
position, or the viewport's extent size has changed. 

    l - the ChangeListener to add 

*javax.swing.JViewport.addImpl(Component,Object,int)*

protected void addImpl(
  java.awt.Component child,
  java.lang.Object constraints,
  int index)

Sets the JViewport's one lightweight child, which can be null. (Since there is 
only one child which occupies the entire viewport, the constraints and index 
arguments are ignored.) 

    child - the lightweight child of the viewport 
    constraints - the constraints to be respected 
    index - the index 

*javax.swing.JViewport.computeBlit(int,int,Point,Point,Dimension,Rectangle)*

protected boolean computeBlit(
  int dx,
  int dy,
  java.awt.Point blitFrom,
  java.awt.Point blitTo,
  java.awt.Dimension blitSize,
  java.awt.Rectangle blitPaint)

Computes the parameters for a blit where the backing store image currently 
contains oldLoc in the upper left hand corner and we're scrolling to newLoc. 
The parameters are modified to return the values required for the blit. 

    dx - the horizontal delta 
    dy - the vertical delta 
    blitFrom - the Point we're blitting from 
    blitTo - the Point we're blitting to 
    blitSize - the Dimension of the area to blit 
    blitPaint - the area to blit 

    Returns: true if the parameters are modified and we're ready to blit; false otherwise 
*javax.swing.JViewport.createLayoutManager()*

protected |java.awt.LayoutManager| createLayoutManager()

Subclassers can override this to install a different layout manager (or null) 
in the constructor. Returns the LayoutManager to install on the JViewport. 


    Returns: a LayoutManager 
*javax.swing.JViewport.createViewListener()*

protected |javax.swing.JViewport.ViewListener| createViewListener()

Creates a listener for the view. 


    Returns: a ViewListener 
*javax.swing.JViewport.firePropertyChange(String,Object,Object)*

protected void firePropertyChange(
  java.lang.String propertyName,
  java.lang.Object oldValue,
  java.lang.Object newValue)

Notifies listeners of a property change. This is subclassed to update the 
windowBlit property. (The putClientProperty property is final). 

    propertyName - a string containing the property name 
    oldValue - the old value of the property 
    newValue - the new value of the property 

*javax.swing.JViewport.fireStateChanged()*

protected void fireStateChanged()

Notifies all ChangeListeners when the views size, position, or the viewports 
extent size has changed. 


*javax.swing.JViewport.getAccessibleContext()*

public |javax.accessibility.AccessibleContext| getAccessibleContext()

Gets the AccessibleContext associated with this JViewport. For viewports, the 
AccessibleContext takes the form of an AccessibleJViewport. A new 
AccessibleJViewport instance is created if necessary. 


    Returns: an AccessibleJViewport that serves as the AccessibleContext of this JViewport 
*javax.swing.JViewport.getChangeListeners()*

public |javax.swing.event.ChangeListener| getChangeListeners()

Returns an array of all the ChangeListeners added to this JViewport with 
addChangeListener(). 


    Returns: all of the ChangeListeners added or an empty array if no listeners have been 
             added 
*javax.swing.JViewport.getExtentSize()*

public |java.awt.Dimension| getExtentSize()

Returns the size of the visible part of the view in view coordinates. 


    Returns: a Dimension object giving the size of the view 
*javax.swing.JViewport.getInsets()*

public final |java.awt.Insets| getInsets()

Returns the insets (border) dimensions as (0,0,0,0), since borders are not 
supported on a JViewport. 


    Returns: a Rectange of zero dimension and zero origin 
*javax.swing.JViewport.getInsets(Insets)*

public final |java.awt.Insets| getInsets(java.awt.Insets insets)

Returns an Insets object containing this JViewports inset values. The passed-in 
Insets object will be reinitialized, and all existing values within this object 
are overwritten. 

    insets - the Insets object which can be reused 

    Returns: this viewports inset values 
*javax.swing.JViewport.getScrollMode()*

public int getScrollMode()

Returns the current scrolling mode. 


    Returns: the scrollMode property 
*javax.swing.JViewport.getUI()*

public |javax.swing.plaf.ViewportUI| getUI()

Returns the Lobject that renders this component. 


    Returns: a ViewportUI object 
*javax.swing.JViewport.getUIClassID()*

public |java.lang.String| getUIClassID()

Returns a string that specifies the name of the Lclass that renders this 
component. 


    Returns: the string "ViewportUI" 
*javax.swing.JViewport.getView()*

public |java.awt.Component| getView()

Returns the JViewport's one child or null. 


    Returns: the viewports child, or null if none exists 
*javax.swing.JViewport.getViewPosition()*

public |java.awt.Point| getViewPosition()

Returns the view coordinates that appear in the upper left hand corner of the 
viewport, or 0,0 if there's no view. 


    Returns: a Point object giving the upper left coordinates 
*javax.swing.JViewport.getViewRect()*

public |java.awt.Rectangle| getViewRect()

Returns a rectangle whose origin is getViewPosition and size is getExtentSize. 
This is the visible part of the view, in view coordinates. 


    Returns: a Rectangle giving the visible part of the view using view coordinates. 
*javax.swing.JViewport.getViewSize()*

public |java.awt.Dimension| getViewSize()

If the view's size hasn't been explicitly set, return the preferred size, 
otherwise return the view's current size. If there is no view, return 0,0. 


    Returns: a Dimension object specifying the size of the view 
*javax.swing.JViewport.isBackingStoreEnabled()*

public boolean isBackingStoreEnabled()

Returns true if this viewport is maintaining an offscreen image of its 
contents. 


    Returns: true if scrollMode is BACKINGSTORE_SCROLL_MODE 
*javax.swing.JViewport.isOptimizedDrawingEnabled()*

public boolean isOptimizedDrawingEnabled()

The JViewport overrides the default implementation of this method (in 
JComponent) to return false. This ensures that the drawing machinery will call 
the Viewport's paint implementation rather than messaging the JViewport's 
children directly. 


    Returns: 
*javax.swing.JViewport.paint(Graphics)*

public void paint(java.awt.Graphics g)

Depending on whether the backingStore is enabled, either paint the image 
through the backing store or paint just the recently exposed part, using the 
backing store to "blit" the remainder. 

The term "blit" is the pronounced version of the PDP-10 BLT (BLock Transfer) 
instruction, which copied a block of bits. (In case you were curious.) 

    g - the Graphics context within which to paint 

*javax.swing.JViewport.paramString()*

protected |java.lang.String| paramString()

Returns a string representation of this JViewport. This method is intended to 
be used only for debugging purposes, and the content and format of the returned 
string may vary between implementations. The returned string may be empty but 
may not be null. 


    Returns: a string representation of this JViewport 
*javax.swing.JViewport.remove(Component)*

public void remove(java.awt.Component child)

Removes the Viewports one lightweight child. 


*javax.swing.JViewport.removeChangeListener(ChangeListener)*

public void removeChangeListener(javax.swing.event.ChangeListener l)

Removes a ChangeListener from the list that's notified each time the views 
size, position, or the viewports extent size has changed. 

    l - the ChangeListener to remove 

*javax.swing.JViewport.repaint(long,int,int,int,int)*

public void repaint(
  long tm,
  int x,
  int y,
  int w,
  int h)

Always repaint in the parents coordinate system to make sure only one paint is 
performed by the RepaintManager. 

    tm - maximum time in milliseconds before update 
    x - the x coordinate (pixels over from left) 
    y - the y coordinate (pixels down from top) 
    w - the width 
    h - the height 

*javax.swing.JViewport.reshape(int,int,int,int)*

public void reshape(
  int x,
  int y,
  int w,
  int h)

Sets the bounds of this viewport. If the viewport's width or height has 
changed, fire a StateChanged event. 

    x - left edge of the origin 
    y - top edge of the origin 
    w - width in pixels 
    h - height in pixels 

*javax.swing.JViewport.scrollRectToVisible(Rectangle)*

public void scrollRectToVisible(java.awt.Rectangle contentRect)

Scrolls the view so that Rectangle within the view becomes visible. 

This attempts to validate the view before scrolling if the view is currently 
not valid - isValid returns false. To avoid excessive validation when the 
containment hierarchy is being created this will not validate if one of the 
ancestors does not have a peer, or there is no validate root ancestor, or one 
of the ancestors is not a Window or Applet. 

Note that this method will not scroll outside of the valid viewport; for 
example, if contentRect is larger than the viewport, scrolling will be confined 
to the viewport's bounds. 

    contentRect - the Rectangle to display 

*javax.swing.JViewport.setBackingStoreEnabled(boolean)*

public void setBackingStoreEnabled(boolean enabled)

If true if this viewport will maintain an offscreen image of its contents. The 
image is used to reduce the cost of small one dimensional changes to the 
viewPosition. Rather than repainting the entire viewport we use 
Graphics.copyArea to effect some of the scroll. 

    enabled - if true, maintain an offscreen backing store 

*javax.swing.JViewport.setBorder(Border)*

public final void setBorder(javax.swing.border.Border border)

The viewport "scrolls" its child (called the "view") by the normal parent/child 
clipping (typically the view is moved in the opposite direction of the scroll). 
A non-null border, or non-zero insets, isn't supported, to prevent the geometry 
of this component from becoming complex enough to inhibit subclassing. To 
create a JViewport with a border, add it to a JPanel that has a border. Note: 
If border is non-null, this method will throw an exception as borders are not 
supported on a JViewPort. 

    border - the Border to set 

*javax.swing.JViewport.setExtentSize(Dimension)*

public void setExtentSize(java.awt.Dimension newExtent)

Sets the size of the visible part of the view using view coordinates. 

    newExtent - a Dimension object specifying the size of the view 

*javax.swing.JViewport.setScrollMode(int)*

public void setScrollMode(int mode)

Used to control the method of scrolling the viewport contents. You may want to 
change this mode to get maximum performance for your use case. 

    mode - one of the following values: 

JViewport.BLIT_SCROLL_MODE JViewport.BACKINGSTORE_SCROLL_MODE 
       JViewport.SIMPLE_SCROLL_MODE 

*javax.swing.JViewport.setUI(ViewportUI)*

public void setUI(javax.swing.plaf.ViewportUI ui)

Sets the Lobject that renders this component. 

    ui - the ViewportUI Lobject 

*javax.swing.JViewport.setView(Component)*

public void setView(java.awt.Component view)

Sets the JViewport's one lightweight child (view), which can be null. 

    view - the viewport's new lightweight child 

*javax.swing.JViewport.setViewPosition(Point)*

public void setViewPosition(java.awt.Point p)

Sets the view coordinates that appear in the upper left hand corner of the 
viewport, does nothing if there's no view. 

    p - a Point object giving the upper left coordinates 

*javax.swing.JViewport.setViewSize(Dimension)*

public void setViewSize(java.awt.Dimension newSize)

Sets the size of the view. A state changed event will be fired. 

    newSize - a Dimension object specifying the new size of the view 

*javax.swing.JViewport.toViewCoordinates(Dimension)*

public |java.awt.Dimension| toViewCoordinates(java.awt.Dimension size)

Converts a size in pixel coordinates to view coordinates. Subclasses of 
viewport that support "logical coordinates" will override this method. 

    size - a Dimension object using pixel coordinates 

    Returns: a Dimension object converted to view coordinates 
*javax.swing.JViewport.toViewCoordinates(Point)*

public |java.awt.Point| toViewCoordinates(java.awt.Point p)

Converts a point in pixel coordinates to view coordinates. Subclasses of 
viewport that support "logical coordinates" will override this method. 

    p - a Point object using pixel coordinates 

    Returns: a Point object converted to view coordinates 
*javax.swing.JViewport.updateUI()*

public void updateUI()

Resets the UI property to a value from the current look and feel. 



