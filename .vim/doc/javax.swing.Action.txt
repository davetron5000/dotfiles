*javax.swing.Action* *Action* The Action interface provides a useful extension t

public interface interface Action

  implements |java.awt.event.ActionListener|

|javax.swing.Action_Description|
|javax.swing.Action_Fields|
|javax.swing.Action_Constructors|
|javax.swing.Action_Methods|

================================================================================

*javax.swing.Action_Fields*
|java.lang.String_javax.swing.Action.ACCELERATOR_KEY|
|java.lang.String_javax.swing.Action.ACTION_COMMAND_KEY|
|java.lang.String_javax.swing.Action.DEFAULT|
|java.lang.String_javax.swing.Action.LONG_DESCRIPTION|
|java.lang.String_javax.swing.Action.MNEMONIC_KEY|
|java.lang.String_javax.swing.Action.NAME|
|java.lang.String_javax.swing.Action.SHORT_DESCRIPTION|
|java.lang.String_javax.swing.Action.SMALL_ICON|

*javax.swing.Action_Methods*
|javax.swing.Action.addPropertyChangeListener(PropertyChangeListener)|Adds a Pr
|javax.swing.Action.getValue(String)|Gets one of this object's properties  usin
|javax.swing.Action.isEnabled()|Returns the enabled state of the Action.
|javax.swing.Action.putValue(String,Object)|Sets one of this object's propertie
|javax.swing.Action.removePropertyChangeListener(PropertyChangeListener)|Remove
|javax.swing.Action.setEnabled(boolean)|Sets the enabled state of the Action.

*javax.swing.Action_Description*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.ACCELERATOR_KEY*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.ACTION_COMMAND_KEY*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.DEFAULT*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.LONG_DESCRIPTION*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.MNEMONIC_KEY*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.NAME*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.SHORT_DESCRIPTION*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 


*java.lang.String_javax.swing.Action.SMALL_ICON*

The Action interface provides a useful extension to the ActionListener 
interface in cases where the same functionality may be accessed by several 
controls. 

In addition to the actionPerformed method defined by the ActionListener 
interface, this interface allows the application to define, in a single place: 

One or more text strings that describe the function. These strings can be used, 
for example, to display the flyover text for a button or to set the text in a 
menu item. One or more icons that depict the function. These icons can be used 
for the images in a menu control, or for composite entries in a more 
sophisticated user interface. The enabled/disabled state of the functionality. 
Instead of having to separately disable the menu item and the toolbar button, 
the application can disable the function that implements this interface. All 
components which are registered as listeners for the state change then know to 
disable event generation for that item and to modify the display accordingly. 

Certain containers, including menus and tool bars, know how to add an Action 
object. When an Action object is added to such a container, the container: 

Creates a component that is appropriate for that container (a tool bar creates 
a button component, for example). Gets the appropriate property(s) from the 
Action object to customize the component (for example, the icon image and 
flyover text). Checks the initial state of the Action object to determine if it 
is enabled or disabled, and renders the component in the appropriate fashion. 
Registers a listener with the Action object so that is notified of state 
changes. When the Action object changes from enabled to disabled, or back, the 
container makes the appropriate revisions to the event-generation mechanisms 
and renders the component accordingly. 

For example, both a menu item and a toolbar button could access a Cut action 
object. The text associated with the object is specified as "Cut", and an image 
depicting a pair of scissors is specified as its icon. The Cut action-object 
can then be added to a menu and to a tool bar. Each container does the 
appropriate things with the object, and invokes its actionPerformed method when 
the component associated with it is activated. The application can then disable 
or enable the application object without worrying about what user-interface 
components are connected to it. 

This interface can be added to an existing class or used to create an adapter 
(typically, by subclassing AbstractAction). The Action object can then be added 
to multiple Action-aware containers and connected to Action-capable components. 
The GUI controls can then be activated or deactivated all at once by invoking 
the Action object's setEnabled method. 

Note that Action implementations tend to be more expensive in terms of storage 
than a typical ActionListener, which does not offer the benefits of centralized 
control of functionality and broadcast of property changes. For this reason, 
you should take care to only use Actions where their benefits are desired, and 
use simple ActionListeners elsewhere. 



*javax.swing.Action.addPropertyChangeListener(PropertyChangeListener)*

public void addPropertyChangeListener(java.beans.PropertyChangeListener listener)

Adds a PropertyChange listener. Containers and attached components use these 
methods to register interest in this Action object. When its enabled state or 
other property changes, the registered listeners are informed of the change. 

    listener - a PropertyChangeListener object 

*javax.swing.Action.getValue(String)*

public |java.lang.Object| getValue(java.lang.String key)

Gets one of this object's properties using the associated key. 


*javax.swing.Action.isEnabled()*

public boolean isEnabled()

Returns the enabled state of the Action. When enabled, any component associated 
with this object is active and able to fire this object's actionPerformed 
method. 


    Returns: true if this Action is enabled 
*javax.swing.Action.putValue(String,Object)*

public void putValue(
  java.lang.String key,
  java.lang.Object value)

Sets one of this object's properties using the associated key. If the value has 
changed, a PropertyChangeEvent is sent to listeners. 

    key - a String containing the key 
    value - an Object value 

*javax.swing.Action.removePropertyChangeListener(PropertyChangeListener)*

public void removePropertyChangeListener(java.beans.PropertyChangeListener listener)

Removes a PropertyChange listener. 

    listener - a PropertyChangeListener object 

*javax.swing.Action.setEnabled(boolean)*

public void setEnabled(boolean b)

Sets the enabled state of the Action. When enabled, any component associated 
with this object is active and able to fire this object's actionPerformed 
method. If the value has changed, a PropertyChangeEvent is sent to listeners. 

    b - true to enable this Action, false to disable it 


