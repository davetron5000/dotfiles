*java.util.concurrent.ArrayBlockingQueue* *ArrayBlockingQueue* A boundedBlocking

public class ArrayBlockingQueue
  extends    |java.util.AbstractQueue|
  implements |java.util.concurrent.BlockingQueue|
             |java.io.Serializable|

|java.util.concurrent.ArrayBlockingQueue_Description|
|java.util.concurrent.ArrayBlockingQueue_Fields|
|java.util.concurrent.ArrayBlockingQueue_Constructors|
|java.util.concurrent.ArrayBlockingQueue_Methods|

================================================================================

*java.util.concurrent.ArrayBlockingQueue_Constructors*
|java.util.concurrent.ArrayBlockingQueue(int)|Creates an ArrayBlockingQueue wit
|java.util.concurrent.ArrayBlockingQueue(int,boolean)|Creates an ArrayBlockingQ
|java.util.concurrent.ArrayBlockingQueue(int,boolean,Collection)|Creates an Arr

*java.util.concurrent.ArrayBlockingQueue_Methods*
|java.util.concurrent.ArrayBlockingQueue.clear()|Atomically removes all of the 
|java.util.concurrent.ArrayBlockingQueue.contains(Object)|
|java.util.concurrent.ArrayBlockingQueue.drainTo(Collection)|
|java.util.concurrent.ArrayBlockingQueue.drainTo(Collection,int)|
|java.util.concurrent.ArrayBlockingQueue.iterator()|Returns an iterator over th
|java.util.concurrent.ArrayBlockingQueue.offer(E)|Inserts the specified element
|java.util.concurrent.ArrayBlockingQueue.offer(E,long,TimeUnit)|Inserts the spe
|java.util.concurrent.ArrayBlockingQueue.peek()|
|java.util.concurrent.ArrayBlockingQueue.poll()|
|java.util.concurrent.ArrayBlockingQueue.poll(long,TimeUnit)|
|java.util.concurrent.ArrayBlockingQueue.put(E)|Adds the specified element to t
|java.util.concurrent.ArrayBlockingQueue.remainingCapacity()|Returns the number
|java.util.concurrent.ArrayBlockingQueue.remove(Object)|Removes a single instan
|java.util.concurrent.ArrayBlockingQueue.size()|Returns the number of elements 
|java.util.concurrent.ArrayBlockingQueue.take()|
|java.util.concurrent.ArrayBlockingQueue.toArray()|
|java.util.concurrent.ArrayBlockingQueue.toArray(T[])|
|java.util.concurrent.ArrayBlockingQueue.toString()|

*java.util.concurrent.ArrayBlockingQueue_Description*

A bounded blocking queue(|java.util.concurrent.BlockingQueue|) backed by an 
array. This queue orders elements FIFO (first-in-first-out). The head of the 
queue is that element that has been on the queue the longest time. The tail of 
the queue is that element that has been on the queue the shortest time. New 
elements are inserted at the tail of the queue, and the queue retrieval 
operations obtain elements at the head of the queue. 

This is a classic bounded buffer, in which a fixed-sized array holds elements 
inserted by producers and extracted by consumers. Once created, the capacity 
cannot be increased. Attempts to put an element to a full queue will result in 
the put operation blocking; attempts to retrieve an element from an empty queue 
will similarly block. 

This class supports an optional fairness policy for ordering waiting producer 
and consumer threads. By default, this ordering is not guaranteed. However, a 
queue constructed with fairness set to true grants threads access in FIFO 
order. Fairness generally decreases throughput but reduces variability and 
avoids starvation. 

This class and its iterator implement all of the optional methods of the 
(|java.util.Collection|) and (|java.util.Iterator|) interfaces. 

This class is a member of the <a href="/../guide/collections/index.html"> Java 
Collections Framework. 


*java.util.concurrent.ArrayBlockingQueue(int)*

public ArrayBlockingQueue(int capacity)

Creates an ArrayBlockingQueue with the given (fixed) capacity and default 
access policy. 

    capacity - the capacity of this queue 

*java.util.concurrent.ArrayBlockingQueue(int,boolean)*

public ArrayBlockingQueue(
  int capacity,
  boolean fair)

Creates an ArrayBlockingQueue with the given (fixed) capacity and the specified 
access policy. 

    capacity - the capacity of this queue 
    fair - if true then queue accesses for threads blocked on insertion or removal, are 
       processed in FIFO order; if false the access order is unspecified. 

*java.util.concurrent.ArrayBlockingQueue(int,boolean,Collection)*

public ArrayBlockingQueue(
  int capacity,
  boolean fair,
  java.util.Collection c)

Creates an ArrayBlockingQueue with the given (fixed) capacity, the specified 
access policy and initially containing the elements of the given collection, 
added in traversal order of the collection's iterator. 

    capacity - the capacity of this queue 
    fair - if true then queue accesses for threads blocked on insertion or removal, are 
       processed in FIFO order; if false the access order is unspecified. 
    c - the collection of elements to initially contain 

*java.util.concurrent.ArrayBlockingQueue.clear()*

public void clear()

Atomically removes all of the elements from this queue. The queue will be empty 
after this call returns. 


*java.util.concurrent.ArrayBlockingQueue.contains(Object)*

public boolean contains(java.lang.Object o)




*java.util.concurrent.ArrayBlockingQueue.drainTo(Collection)*

public int drainTo(java.util.Collection c)




*java.util.concurrent.ArrayBlockingQueue.drainTo(Collection,int)*

public int drainTo(
  java.util.Collection c,
  int maxElements)




*java.util.concurrent.ArrayBlockingQueue.iterator()*

public |java.util.Iterator| iterator()

Returns an iterator over the elements in this queue in proper sequence. The 
returned Iterator is a "weakly consistent" iterator that will never throw 
(|java.util.ConcurrentModificationException|) , and guarantees to traverse 
elements as they existed upon construction of the iterator, and may (but is not 
guaranteed to) reflect any modifications subsequent to construction. 


    Returns: an iterator over the elements in this queue in proper sequence. 
*java.util.concurrent.ArrayBlockingQueue.offer(E)*

public boolean offer(java.lang.Object o)

Inserts the specified element at the tail of this queue if possible, returning 
immediately if this queue is full. 

    o - the element to add. 

    Returns: true if it was possible to add the element to this queue, else false 
*java.util.concurrent.ArrayBlockingQueue.offer(E,long,TimeUnit)*

public boolean offer(
  java.lang.Object o,
  long timeout,
  java.util.concurrent.TimeUnit unit)
  throws |java.lang.InterruptedException|
         
Inserts the specified element at the tail of this queue, waiting if necessary 
up to the specified wait time for space to become available. 

    o - the element to add 
    timeout - how long to wait before giving up, in units of unit 
    unit - a TimeUnit determining how to interpret the timeout parameter 

    Returns: true if successful, or false if the specified waiting time elapses before space 
             is available. 
*java.util.concurrent.ArrayBlockingQueue.peek()*

public |java.lang.Object| peek()




*java.util.concurrent.ArrayBlockingQueue.poll()*

public |java.lang.Object| poll()




*java.util.concurrent.ArrayBlockingQueue.poll(long,TimeUnit)*

public |java.lang.Object| poll(
  long timeout,
  java.util.concurrent.TimeUnit unit)
  throws |java.lang.InterruptedException|
         



*java.util.concurrent.ArrayBlockingQueue.put(E)*

public void put(java.lang.Object o)
  throws |java.lang.InterruptedException|
         
Adds the specified element to the tail of this queue, waiting if necessary for 
space to become available. 

    o - the element to add 

*java.util.concurrent.ArrayBlockingQueue.remainingCapacity()*

public int remainingCapacity()

Returns the number of elements that this queue can ideally (in the absence of 
memory or resource constraints) accept without blocking. This is always equal 
to the initial capacity of this queue less the current size of this queue. Note 
that you cannot always tell if an attempt to add an element will succeed by 
inspecting remainingCapacity because it may be the case that a waiting consumer 
is ready to take an element out of an otherwise full queue. 


*java.util.concurrent.ArrayBlockingQueue.remove(Object)*

public boolean remove(java.lang.Object o)

Removes a single instance of the specified element from this queue, if it is 
present. 


*java.util.concurrent.ArrayBlockingQueue.size()*

public int size()

Returns the number of elements in this queue. 


    Returns: the number of elements in this queue. 
*java.util.concurrent.ArrayBlockingQueue.take()*

public |java.lang.Object| take()
  throws |java.lang.InterruptedException|
         



*java.util.concurrent.ArrayBlockingQueue.toArray()*

public |java.lang.Object| toArray()




*java.util.concurrent.ArrayBlockingQueue.toArray(T[])*

public |java.lang.Object| toArray(java.lang.Object[] a)




*java.util.concurrent.ArrayBlockingQueue.toString()*

public |java.lang.String| toString()





