*java.util.GregorianCalendar* *GregorianCalendar* GregorianCalendar is a concret

public class GregorianCalendar
  extends    |java.util.Calendar|

|java.util.GregorianCalendar_Description|
|java.util.GregorianCalendar_Fields|
|java.util.GregorianCalendar_Constructors|
|java.util.GregorianCalendar_Methods|

================================================================================

*java.util.GregorianCalendar_Fields*
|int_java.util.GregorianCalendar.AD|
|int_java.util.GregorianCalendar.BC|

*java.util.GregorianCalendar_Constructors*
|java.util.GregorianCalendar()|Constructs a default GregorianCalendar using the
|java.util.GregorianCalendar(int,int,int)|Constructs a GregorianCalendar with t
|java.util.GregorianCalendar(int,int,int,int,int)|Constructs a GregorianCalenda
|java.util.GregorianCalendar(int,int,int,int,int,int)|Constructs a GregorianCal
|java.util.GregorianCalendar(Locale)|Constructs a GregorianCalendar based on th
|java.util.GregorianCalendar(TimeZone)|Constructs a GregorianCalendar based on 
|java.util.GregorianCalendar(TimeZone,Locale)|Constructs a GregorianCalendar ba

*java.util.GregorianCalendar_Methods*
|java.util.GregorianCalendar.add(int,int)|Adds the specified (signed) amount of
|java.util.GregorianCalendar.clone()|
|java.util.GregorianCalendar.computeFields()|Converts the time value (milliseco
|java.util.GregorianCalendar.computeTime()|Converts calendar field values to th
|java.util.GregorianCalendar.equals(Object)|Compares this GregorianCalendar to 
|java.util.GregorianCalendar.getActualMaximum(int)|Returns the maximum value th
|java.util.GregorianCalendar.getActualMinimum(int)|Returns the minimum value th
|java.util.GregorianCalendar.getGreatestMinimum(int)|Returns the highest minimu
|java.util.GregorianCalendar.getGregorianChange()|Gets the Gregorian Calendar c
|java.util.GregorianCalendar.getLeastMaximum(int)|Returns the lowest maximum va
|java.util.GregorianCalendar.getMaximum(int)|Returns the maximum value for the 
|java.util.GregorianCalendar.getMinimum(int)|Returns the minimum value for the 
|java.util.GregorianCalendar.getTimeZone()|
|java.util.GregorianCalendar.hashCode()|Generates the hash code for this Gregor
|java.util.GregorianCalendar.isLeapYear(int)|Determines if the given year is a 
|java.util.GregorianCalendar.roll(int,boolean)|Adds or subtracts (up/down) a si
|java.util.GregorianCalendar.roll(int,int)|Adds a signed amount to the specifie
|java.util.GregorianCalendar.setGregorianChange(Date)|Sets the GregorianCalenda
|java.util.GregorianCalendar.setTimeZone(TimeZone)|

*java.util.GregorianCalendar_Description*

GregorianCalendar is a concrete subclass of Calendar and provides the standard 
calendar system used by most of the world. 

GregorianCalendar is a hybrid calendar that supports both the Julian and 
Gregorian calendar systems with the support of a single discontinuity, which 
corresponds by default to the Gregorian date when the Gregorian calendar was 
instituted (October 15, 1582 in some countries, later in others). The cutover 
date may be changed by the caller by calling 
setGregorianChange()(|java.util.GregorianCalendar|) . 

Historically, in those countries which adopted the Gregorian calendar first, 
October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). 
This calendar models this correctly. Before the Gregorian cutover, 
GregorianCalendar implements the Julian calendar. The only difference between 
the Gregorian and the Julian calendar is the leap year rule. The Julian 
calendar specifies leap years every four years, whereas the Gregorian calendar 
omits century years which are not divisible by 400. 

GregorianCalendar implements proleptic Gregorian and Julian calendars. That is, 
dates are computed by extrapolating the current rules indefinitely far backward 
and forward in time. As a result, GregorianCalendar may be used for all years 
to generate meaningful and consistent results. However, dates obtained using 
GregorianCalendar are historically accurate only from March 1, 4 AD onward, 
when modern Julian calendar rules were adopted. Before this date, leap year 
rules were applied irregularly, and before 45 BC the Julian calendar did not 
even exist. 

Prior to the institution of the Gregorian calendar, New Year's Day was March 
25. To avoid confusion, this calendar always uses January 1. A manual 
adjustment may be made if desired for dates that are prior to the Gregorian 
changeover and which fall between January 1 and March 24. 

Values calculated for the WEEK_OF_YEAR field range from 1 to 53. Week 1 for a 
year is the earliest seven day period starting on getFirstDayOfWeek() that 
contains at least getMinimalDaysInFirstWeek() days from that year. It thus 
depends on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and 
the day of the week of January 1. Weeks between week 1 of one year and week 1 
of the following year are numbered sequentially from 2 to 52 or 53 (as needed). 

For example, January 1, 1998 was a Thursday. If getFirstDayOfWeek() is MONDAY 
and getMinimalDaysInFirstWeek() is 4 (these are the values reflecting ISO 8601 
and many national standards), then week 1 of 1998 starts on December 29, 1997, 
and ends on January 4, 1998. If, however, getFirstDayOfWeek() is SUNDAY, then 
week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the 
first three days of 1998 then are part of week 53 of 1997. 

Values calculated for the WEEK_OF_MONTH field range from 0 to 6. Week 1 of a 
month (the days with WEEK_OF_MONTH = 1) is the earliest set of at least 
getMinimalDaysInFirstWeek() contiguous days in that month, ending on the day 
before getFirstDayOfWeek(). Unlike week 1 of a year, week 1 of a month may be 
shorter than 7 days, need not start on getFirstDayOfWeek(), and will not 
include days of the previous month. Days of a month before week 1 have a 
WEEK_OF_MONTH of 0. 

For example, if getFirstDayOfWeek() is SUNDAY and getMinimalDaysInFirstWeek() 
is 4, then the first week of January 1998 is Sunday, January 4 through 
Saturday, January 10. These days have a WEEK_OF_MONTH of 1. Thursday, January 1 
through Saturday, January 3 have a WEEK_OF_MONTH of 0. If 
getMinimalDaysInFirstWeek() is changed to 3, then January 1 through January 3 
have a WEEK_OF_MONTH of 1. 

The clear methods set calendar field(s) undefined. GregorianCalendar uses the 
following default value for each calendar field if its value is undefined. 



Field 

Default Value 



ERA 

AD 



YEAR 

1970 



MONTH 

JANUARY 



DAY_OF_MONTH 

1 



DAY_OF_WEEK 

the first day of week 



WEEK_OF_MONTH 

0 



DAY_OF_WEEK_IN_MONTH 

1 



AM_PM 

AM 



HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND 

0 



Default values are not applicable for the fields not listed above. 

Example: 



// get the supported ids for GMT-08:00 (Pacific Standard Time) String[] ids = 
TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000); // if no ids were returned, 
something is wrong. get out. if (ids.length == 0) System.exit(0); 

// begin output System.out.println("Current Time"); 

// create a Pacific Standard Time time zone SimpleTimeZone pdt = new 
SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]); 

// set up rules for daylight savings time pdt.setStartRule(Calendar.APRIL, 1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); pdt.setEndRule(Calendar.OCTOBER, -1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); 

// create a GregorianCalendar with the Pacific Daylight time zone // and the 
current date and time Calendar calendar = new GregorianCalendar(pdt); Date 
trialTime = new Date(); calendar.setTime(trialTime); 

// print out a bunch of interesting things System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); 

System.out.println("Current Time, with hour reset to 3"); 
calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override 
calendar.set(Calendar.HOUR, 3); System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours 




*int_java.util.GregorianCalendar.AD*

GregorianCalendar is a concrete subclass of Calendar and provides the standard 
calendar system used by most of the world. 

GregorianCalendar is a hybrid calendar that supports both the Julian and 
Gregorian calendar systems with the support of a single discontinuity, which 
corresponds by default to the Gregorian date when the Gregorian calendar was 
instituted (October 15, 1582 in some countries, later in others). The cutover 
date may be changed by the caller by calling 
setGregorianChange()(|java.util.GregorianCalendar|) . 

Historically, in those countries which adopted the Gregorian calendar first, 
October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). 
This calendar models this correctly. Before the Gregorian cutover, 
GregorianCalendar implements the Julian calendar. The only difference between 
the Gregorian and the Julian calendar is the leap year rule. The Julian 
calendar specifies leap years every four years, whereas the Gregorian calendar 
omits century years which are not divisible by 400. 

GregorianCalendar implements proleptic Gregorian and Julian calendars. That is, 
dates are computed by extrapolating the current rules indefinitely far backward 
and forward in time. As a result, GregorianCalendar may be used for all years 
to generate meaningful and consistent results. However, dates obtained using 
GregorianCalendar are historically accurate only from March 1, 4 AD onward, 
when modern Julian calendar rules were adopted. Before this date, leap year 
rules were applied irregularly, and before 45 BC the Julian calendar did not 
even exist. 

Prior to the institution of the Gregorian calendar, New Year's Day was March 
25. To avoid confusion, this calendar always uses January 1. A manual 
adjustment may be made if desired for dates that are prior to the Gregorian 
changeover and which fall between January 1 and March 24. 

Values calculated for the WEEK_OF_YEAR field range from 1 to 53. Week 1 for a 
year is the earliest seven day period starting on getFirstDayOfWeek() that 
contains at least getMinimalDaysInFirstWeek() days from that year. It thus 
depends on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and 
the day of the week of January 1. Weeks between week 1 of one year and week 1 
of the following year are numbered sequentially from 2 to 52 or 53 (as needed). 

For example, January 1, 1998 was a Thursday. If getFirstDayOfWeek() is MONDAY 
and getMinimalDaysInFirstWeek() is 4 (these are the values reflecting ISO 8601 
and many national standards), then week 1 of 1998 starts on December 29, 1997, 
and ends on January 4, 1998. If, however, getFirstDayOfWeek() is SUNDAY, then 
week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the 
first three days of 1998 then are part of week 53 of 1997. 

Values calculated for the WEEK_OF_MONTH field range from 0 to 6. Week 1 of a 
month (the days with WEEK_OF_MONTH = 1) is the earliest set of at least 
getMinimalDaysInFirstWeek() contiguous days in that month, ending on the day 
before getFirstDayOfWeek(). Unlike week 1 of a year, week 1 of a month may be 
shorter than 7 days, need not start on getFirstDayOfWeek(), and will not 
include days of the previous month. Days of a month before week 1 have a 
WEEK_OF_MONTH of 0. 

For example, if getFirstDayOfWeek() is SUNDAY and getMinimalDaysInFirstWeek() 
is 4, then the first week of January 1998 is Sunday, January 4 through 
Saturday, January 10. These days have a WEEK_OF_MONTH of 1. Thursday, January 1 
through Saturday, January 3 have a WEEK_OF_MONTH of 0. If 
getMinimalDaysInFirstWeek() is changed to 3, then January 1 through January 3 
have a WEEK_OF_MONTH of 1. 

The clear methods set calendar field(s) undefined. GregorianCalendar uses the 
following default value for each calendar field if its value is undefined. 



Field 

Default Value 



ERA 

AD 



YEAR 

1970 



MONTH 

JANUARY 



DAY_OF_MONTH 

1 



DAY_OF_WEEK 

the first day of week 



WEEK_OF_MONTH 

0 



DAY_OF_WEEK_IN_MONTH 

1 



AM_PM 

AM 



HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND 

0 



Default values are not applicable for the fields not listed above. 

Example: 



// get the supported ids for GMT-08:00 (Pacific Standard Time) String[] ids = 
TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000); // if no ids were returned, 
something is wrong. get out. if (ids.length == 0) System.exit(0); 

// begin output System.out.println("Current Time"); 

// create a Pacific Standard Time time zone SimpleTimeZone pdt = new 
SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]); 

// set up rules for daylight savings time pdt.setStartRule(Calendar.APRIL, 1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); pdt.setEndRule(Calendar.OCTOBER, -1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); 

// create a GregorianCalendar with the Pacific Daylight time zone // and the 
current date and time Calendar calendar = new GregorianCalendar(pdt); Date 
trialTime = new Date(); calendar.setTime(trialTime); 

// print out a bunch of interesting things System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); 

System.out.println("Current Time, with hour reset to 3"); 
calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override 
calendar.set(Calendar.HOUR, 3); System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours 




*int_java.util.GregorianCalendar.BC*

GregorianCalendar is a concrete subclass of Calendar and provides the standard 
calendar system used by most of the world. 

GregorianCalendar is a hybrid calendar that supports both the Julian and 
Gregorian calendar systems with the support of a single discontinuity, which 
corresponds by default to the Gregorian date when the Gregorian calendar was 
instituted (October 15, 1582 in some countries, later in others). The cutover 
date may be changed by the caller by calling 
setGregorianChange()(|java.util.GregorianCalendar|) . 

Historically, in those countries which adopted the Gregorian calendar first, 
October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). 
This calendar models this correctly. Before the Gregorian cutover, 
GregorianCalendar implements the Julian calendar. The only difference between 
the Gregorian and the Julian calendar is the leap year rule. The Julian 
calendar specifies leap years every four years, whereas the Gregorian calendar 
omits century years which are not divisible by 400. 

GregorianCalendar implements proleptic Gregorian and Julian calendars. That is, 
dates are computed by extrapolating the current rules indefinitely far backward 
and forward in time. As a result, GregorianCalendar may be used for all years 
to generate meaningful and consistent results. However, dates obtained using 
GregorianCalendar are historically accurate only from March 1, 4 AD onward, 
when modern Julian calendar rules were adopted. Before this date, leap year 
rules were applied irregularly, and before 45 BC the Julian calendar did not 
even exist. 

Prior to the institution of the Gregorian calendar, New Year's Day was March 
25. To avoid confusion, this calendar always uses January 1. A manual 
adjustment may be made if desired for dates that are prior to the Gregorian 
changeover and which fall between January 1 and March 24. 

Values calculated for the WEEK_OF_YEAR field range from 1 to 53. Week 1 for a 
year is the earliest seven day period starting on getFirstDayOfWeek() that 
contains at least getMinimalDaysInFirstWeek() days from that year. It thus 
depends on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and 
the day of the week of January 1. Weeks between week 1 of one year and week 1 
of the following year are numbered sequentially from 2 to 52 or 53 (as needed). 

For example, January 1, 1998 was a Thursday. If getFirstDayOfWeek() is MONDAY 
and getMinimalDaysInFirstWeek() is 4 (these are the values reflecting ISO 8601 
and many national standards), then week 1 of 1998 starts on December 29, 1997, 
and ends on January 4, 1998. If, however, getFirstDayOfWeek() is SUNDAY, then 
week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the 
first three days of 1998 then are part of week 53 of 1997. 

Values calculated for the WEEK_OF_MONTH field range from 0 to 6. Week 1 of a 
month (the days with WEEK_OF_MONTH = 1) is the earliest set of at least 
getMinimalDaysInFirstWeek() contiguous days in that month, ending on the day 
before getFirstDayOfWeek(). Unlike week 1 of a year, week 1 of a month may be 
shorter than 7 days, need not start on getFirstDayOfWeek(), and will not 
include days of the previous month. Days of a month before week 1 have a 
WEEK_OF_MONTH of 0. 

For example, if getFirstDayOfWeek() is SUNDAY and getMinimalDaysInFirstWeek() 
is 4, then the first week of January 1998 is Sunday, January 4 through 
Saturday, January 10. These days have a WEEK_OF_MONTH of 1. Thursday, January 1 
through Saturday, January 3 have a WEEK_OF_MONTH of 0. If 
getMinimalDaysInFirstWeek() is changed to 3, then January 1 through January 3 
have a WEEK_OF_MONTH of 1. 

The clear methods set calendar field(s) undefined. GregorianCalendar uses the 
following default value for each calendar field if its value is undefined. 



Field 

Default Value 



ERA 

AD 



YEAR 

1970 



MONTH 

JANUARY 



DAY_OF_MONTH 

1 



DAY_OF_WEEK 

the first day of week 



WEEK_OF_MONTH 

0 



DAY_OF_WEEK_IN_MONTH 

1 



AM_PM 

AM 



HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND 

0 



Default values are not applicable for the fields not listed above. 

Example: 



// get the supported ids for GMT-08:00 (Pacific Standard Time) String[] ids = 
TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000); // if no ids were returned, 
something is wrong. get out. if (ids.length == 0) System.exit(0); 

// begin output System.out.println("Current Time"); 

// create a Pacific Standard Time time zone SimpleTimeZone pdt = new 
SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]); 

// set up rules for daylight savings time pdt.setStartRule(Calendar.APRIL, 1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); pdt.setEndRule(Calendar.OCTOBER, -1, 
Calendar.SUNDAY, 2 * 60 * 60 * 1000); 

// create a GregorianCalendar with the Pacific Daylight time zone // and the 
current date and time Calendar calendar = new GregorianCalendar(pdt); Date 
trialTime = new Date(); calendar.setTime(trialTime); 

// print out a bunch of interesting things System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); 

System.out.println("Current Time, with hour reset to 3"); 
calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override 
calendar.set(Calendar.HOUR, 3); System.out.println("ERA: " + 
calendar.get(Calendar.ERA)); System.out.println("YEAR: " + 
calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + 
calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + 
calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + 
calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + 
calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + 
calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + 
calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + 
calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: 
" + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " 
+ calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + 
calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + 
calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + 
calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + 
calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + 
calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + 
(calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours 
System.out.println("DST_OFFSET: " + 
(calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours 





*java.util.GregorianCalendar()*

public GregorianCalendar()

Constructs a default GregorianCalendar using the current time in the default 
time zone with the default locale. 


*java.util.GregorianCalendar(int,int,int)*

public GregorianCalendar(
  int year,
  int month,
  int dayOfMonth)

Constructs a GregorianCalendar with the given date set in the default time zone 
with the default locale. 

    year - the value used to set the YEAR calendar field in the calendar. 
    month - the value used to set the MONTH calendar field in the calendar. Month value is 
       0-based. e.g., 0 for January. 
    dayOfMonth - the value used to set the DAY_OF_MONTH calendar field in the calendar. 

*java.util.GregorianCalendar(int,int,int,int,int)*

public GregorianCalendar(
  int year,
  int month,
  int dayOfMonth,
  int hourOfDay,
  int minute)

Constructs a GregorianCalendar with the given date and time set for the default 
time zone with the default locale. 

    year - the value used to set the YEAR calendar field in the calendar. 
    month - the value used to set the MONTH calendar field in the calendar. Month value is 
       0-based. e.g., 0 for January. 
    dayOfMonth - the value used to set the DAY_OF_MONTH calendar field in the calendar. 
    hourOfDay - the value used to set the HOUR_OF_DAY calendar field in the calendar. 
    minute - the value used to set the MINUTE calendar field in the calendar. 

*java.util.GregorianCalendar(int,int,int,int,int,int)*

public GregorianCalendar(
  int year,
  int month,
  int dayOfMonth,
  int hourOfDay,
  int minute,
  int second)

Constructs a GregorianCalendar with the given date and time set for the default 
time zone with the default locale. 

    year - the value used to set the YEAR calendar field in the calendar. 
    month - the value used to set the MONTH calendar field in the calendar. Month value is 
       0-based. e.g., 0 for January. 
    dayOfMonth - the value used to set the DAY_OF_MONTH calendar field in the calendar. 
    hourOfDay - the value used to set the HOUR_OF_DAY calendar field in the calendar. 
    minute - the value used to set the MINUTE calendar field in the calendar. 
    second - the value used to set the SECOND calendar field in the calendar. 

*java.util.GregorianCalendar(Locale)*

public GregorianCalendar(java.util.Locale aLocale)

Constructs a GregorianCalendar based on the current time in the default time 
zone with the given locale. 

    aLocale - the given locale. 

*java.util.GregorianCalendar(TimeZone)*

public GregorianCalendar(java.util.TimeZone zone)

Constructs a GregorianCalendar based on the current time in the given time zone 
with the default locale. 

    zone - the given time zone. 

*java.util.GregorianCalendar(TimeZone,Locale)*

public GregorianCalendar(
  java.util.TimeZone zone,
  java.util.Locale aLocale)

Constructs a GregorianCalendar based on the current time in the given time zone 
with the given locale. 

    zone - the given time zone. 
    aLocale - the given locale. 

*java.util.GregorianCalendar.add(int,int)*

public void add(
  int field,
  int amount)

Adds the specified (signed) amount of time to the given calendar field, based 
on the calendar's rules. 

Add rule 1. The value of field after the call minus the value of field before 
the call is amount, modulo any overflow that has occurred in field. Overflow 
occurs when a field value exceeds its range and, as a result, the next larger 
field is incremented or decremented and the field value is adjusted back into 
its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field is changed, then its value is adjusted to be as 
close as possible to its expected value. A smaller field represents a smaller 
unit of time. HOUR is a smaller field than DAY_OF_MONTH. No adjustment is made 
to smaller fields that are not expected to be invariant. The calendar system 
determines what fields are expected to be invariant. 

    field - the calendar field. 
    amount - the amount of date or time to be added to the field. 

*java.util.GregorianCalendar.clone()*

public |java.lang.Object| clone()




*java.util.GregorianCalendar.computeFields()*

protected void computeFields()

Converts the time value (millisecond offset from the Epoch) to calendar field 
values. The time is not recomputed first; to recompute the time, then the 
fields, call the complete method. 


*java.util.GregorianCalendar.computeTime()*

protected void computeTime()

Converts calendar field values to the time value (millisecond offset from the 
Epoch). 


*java.util.GregorianCalendar.equals(Object)*

public boolean equals(java.lang.Object obj)

Compares this GregorianCalendar to the specified Object. The result is true if 
and only if the argument is a GregorianCalendar object that represents the same 
time value (millisecond offset from the Epoch) under the same Calendar 
parameters and Gregorian change date as this object. 

    obj - the object to compare with. 

    Returns: true if this object is equal to obj; false otherwise. 
*java.util.GregorianCalendar.getActualMaximum(int)*

public int getActualMaximum(int field)

Returns the maximum value that this calendar field could have, taking into 
consideration the given time value and the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. For example, if the date of this 
instance is February 1, 2004, the actual maximum value of the DAY_OF_MONTH 
field is 29 because 2004 is a leap year, and if the date of this instance is 
February 1, 2005, it's 28. 

    field - the calendar field 

    Returns: the maximum of the given field for the time value of this GregorianCalendar 
*java.util.GregorianCalendar.getActualMinimum(int)*

public int getActualMinimum(int field)

Returns the minimum value that this calendar field could have, taking into 
consideration the given time value and the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. 

For example, if the Gregorian change date is January 10, 1970 and the date of 
this GregorianCalendar is January 20, 1970, the actual minimum value of the 
DAY_OF_MONTH field is 10 because the previous date of January 10, 1970 is 
December 27, 1996 (in the Julian calendar). Therefore, December 28, 1969 to 
January 9, 1970 don't exist. 

    field - the calendar field 

    Returns: the minimum of the given field for the time value of this GregorianCalendar 
*java.util.GregorianCalendar.getGreatestMinimum(int)*

public int getGreatestMinimum(int field)

Returns the highest minimum value for the given calendar field of this 
GregorianCalendar instance. The highest minimum value is defined as the largest 
value returned by (|java.util.GregorianCalendar|) for any possible time value, 
taking into consideration the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. 

    field - the calendar field. 

    Returns: the highest minimum value for the given calendar field. 
*java.util.GregorianCalendar.getGregorianChange()*

public final |java.util.Date| getGregorianChange()

Gets the Gregorian Calendar change date. This is the point when the switch from 
Julian dates to Gregorian dates occurred. Default is October 15, 1582 
(Gregorian). Previous to this, dates will be in the Julian calendar. 


    Returns: the Gregorian cutover date for this GregorianCalendar object. 
*java.util.GregorianCalendar.getLeastMaximum(int)*

public int getLeastMaximum(int field)

Returns the lowest maximum value for the given calendar field of this 
GregorianCalendar instance. The lowest maximum value is defined as the smallest 
value returned by (|java.util.GregorianCalendar|) for any possible time value, 
taking into consideration the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. 

    field - the calendar field 

    Returns: the lowest maximum value for the given calendar field. 
*java.util.GregorianCalendar.getMaximum(int)*

public int getMaximum(int field)

Returns the maximum value for the given calendar field of this 
GregorianCalendar instance. The maximum value is defined as the largest value 
returned by the get(|java.util.Calendar|) method for any possible time value, 
taking into consideration the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. 

    field - the calendar field. 

    Returns: the maximum value for the given calendar field. 
*java.util.GregorianCalendar.getMinimum(int)*

public int getMinimum(int field)

Returns the minimum value for the given calendar field of this 
GregorianCalendar instance. The minimum value is defined as the smallest value 
returned by the get(|java.util.Calendar|) method for any possible time value, 
taking into consideration the current values of the 
getFirstDayOfWeek(|java.util.Calendar|) , 
getMinimalDaysInFirstWeek(|java.util.Calendar|) , 
getGregorianChange(|java.util.GregorianCalendar|) and 
getTimeZone(|java.util.Calendar|) methods. 

    field - the calendar field. 

    Returns: the minimum value for the given calendar field. 
*java.util.GregorianCalendar.getTimeZone()*

public |java.util.TimeZone| getTimeZone()




*java.util.GregorianCalendar.hashCode()*

public int hashCode()

Generates the hash code for this GregorianCalendar object. 


*java.util.GregorianCalendar.isLeapYear(int)*

public boolean isLeapYear(int year)

Determines if the given year is a leap year. Returns true if the given year is 
a leap year. To specify BC year numbers, 1 - year number must be given. For 
example, year BC 4 is specified as -3. 

    year - the given year. 

    Returns: true if the given year is a leap year; false otherwise. 
*java.util.GregorianCalendar.roll(int,boolean)*

public void roll(
  int field,
  boolean up)

Adds or subtracts (up/down) a single unit of time on the given time field 
without changing larger fields. 

Example: Consider a GregorianCalendar originally set to December 31, 1999. 
Calling roll(Calendar.MONTH, true)(|java.util.GregorianCalendar|) sets the 
calendar to January 31, 1999. The YEAR field is unchanged because it is a 
larger field than MONTH. 

    up - indicates if the value of the specified calendar field is to be rolled up or 
       rolled down. Use true if rolling up, false otherwise. 

*java.util.GregorianCalendar.roll(int,int)*

public void roll(
  int field,
  int amount)

Adds a signed amount to the specified calendar field without changing larger 
fields. A negative roll amount means to subtract from field without changing 
larger fields. If the specified amount is 0, this method performs nothing. 

This method calls (|java.util.GregorianCalendar|) before adding the amount so 
that all the calendar fields are normalized. If there is any calendar field 
having an out-of-range value in non-lenient mode, then an 
IllegalArgumentException is thrown. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling roll(Calendar.MONTH, 8) sets the calendar to April 30, 1999. Using a 
GregorianCalendar, the DAY_OF_MONTH field cannot be 31 in the month April. 
DAY_OF_MONTH is set to the closest possible value, 30. The YEAR field maintains 
the value of 1999 because it is a larger field than MONTH. 

Example: Consider a GregorianCalendar originally set to Sunday June 6, 1999. 
Calling roll(Calendar.WEEK_OF_MONTH, -1) sets the calendar to Tuesday June 1, 
1999, whereas calling add(Calendar.WEEK_OF_MONTH, -1) sets the calendar to 
Sunday May 30, 1999. This is because the roll rule imposes an additional 
constraint: The MONTH must not change when the WEEK_OF_MONTH is rolled. Taken 
together with add rule 1, the resultant date must be between Tuesday June 1 and 
Saturday June 5. According to add rule 2, the DAY_OF_WEEK, an invariant when 
changing the WEEK_OF_MONTH, is set to Tuesday, the closest possible value to 
Sunday (where Sunday is the first day of the week). 

    field - the calendar field. 
    amount - the signed amount to add to field. 

*java.util.GregorianCalendar.setGregorianChange(Date)*

public void setGregorianChange(java.util.Date date)

Sets the GregorianCalendar change date. This is the point when the switch from 
Julian dates to Gregorian dates occurred. Default is October 15, 1582 
(Gregorian). Previous to this, dates will be in the Julian calendar. 

To obtain a pure Julian calendar, set the change date to Date(Long.MAX_VALUE). 
To obtain a pure Gregorian calendar, set the change date to 
Date(Long.MIN_VALUE). 

    date - the given Gregorian cutover date. 

*java.util.GregorianCalendar.setTimeZone(TimeZone)*

public void setTimeZone(java.util.TimeZone zone)





