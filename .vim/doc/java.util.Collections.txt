*java.util.Collections* *Collections* This class consists exclusively of static 

public class Collections
  extends    |java.lang.Object|

|java.util.Collections_Description|
|java.util.Collections_Fields|
|java.util.Collections_Constructors|
|java.util.Collections_Methods|

================================================================================

*java.util.Collections_Fields*
|java.util.List_java.util.Collections.EMPTY_LIST|
|java.util.Map_java.util.Collections.EMPTY_MAP|
|java.util.Set_java.util.Collections.EMPTY_SET|

*java.util.Collections_Methods*
|java.util.Collections.addAll(Collection,T[])|Adds all of the specified element
|java.util.Collections.binarySearch(List,T)|Searches the specified list for the
|java.util.Collections.binarySearch(List,T,Comparator)|Searches the specified l
|java.util.Collections.checkedCollection(Collection,Class)|Returns a dynamicall
|java.util.Collections.checkedList(List,Class)|Returns a dynamically typesafe v
|java.util.Collections.checkedMap(Map,Class,Class)|Returns a dynamically typesa
|java.util.Collections.checkedSet(Set,Class)|Returns a dynamically typesafe vie
|java.util.Collections.checkedSortedMap(SortedMap,Class,Class)|Returns a dynami
|java.util.Collections.checkedSortedSet(SortedSet,Class)|Returns a dynamically 
|java.util.Collections.copy(List,List)|Copies all of the elements from one list
|java.util.Collections.disjoint(Collection,Collection)|Returns true if the two 
|java.util.Collections.emptyList()|Returns the empty list (immutable).
|java.util.Collections.emptyMap()|Returns the empty map (immutable).
|java.util.Collections.emptySet()|Returns the empty set (immutable).
|java.util.Collections.enumeration(Collection)|Returns an enumeration over the 
|java.util.Collections.fill(List,T)|Replaces all of the elements of the specifi
|java.util.Collections.frequency(Collection,Object)|Returns the number of eleme
|java.util.Collections.indexOfSubList(List,List)|Returns the starting position 
|java.util.Collections.lastIndexOfSubList(List,List)|Returns the starting posit
|java.util.Collections.list(Enumeration)|Returns an array list containing the e
|java.util.Collections.max(Collection)|Returns the maximum element of the given
|java.util.Collections.max(Collection,Comparator)|Returns the maximum element o
|java.util.Collections.min(Collection)|Returns the minimum element of the given
|java.util.Collections.min(Collection,Comparator)|Returns the minimum element o
|java.util.Collections.nCopies(int,T)|Returns an immutable list consisting of n
|java.util.Collections.replaceAll(List,T,T)|Replaces all occurrences of one spe
|java.util.Collections.reverse(List)|Reverses the order of the elements in the 
|java.util.Collections.reverseOrder()|Returns a comparator that imposes the rev
|java.util.Collections.reverseOrder(Comparator)|Returns a comparator that impos
|java.util.Collections.rotate(List,int)|Rotates the elements in the specified l
|java.util.Collections.shuffle(List)|Randomly permutes the specified list using
|java.util.Collections.shuffle(List,Random)|Randomly permute the specified list
|java.util.Collections.singleton(T)|Returns an immutable set containing only th
|java.util.Collections.singletonList(T)|Returns an immutable list containing on
|java.util.Collections.singletonMap(K,V)|Returns an immutable map, mapping only
|java.util.Collections.sort(List)|Sorts the specified list into ascending order
|java.util.Collections.sort(List,Comparator)|Sorts the specified list according
|java.util.Collections.swap(List,int,int)|Swaps the elements at the specified p
|java.util.Collections.synchronizedCollection(Collection)|Returns a synchronize
|java.util.Collections.synchronizedList(List)|Returns a synchronized (thread-sa
|java.util.Collections.synchronizedMap(Map)|Returns a synchronized (thread-safe
|java.util.Collections.synchronizedSet(Set)|Returns a synchronized (thread-safe
|java.util.Collections.synchronizedSortedMap(SortedMap)|Returns a synchronized 
|java.util.Collections.synchronizedSortedSet(SortedSet)|Returns a synchronized 
|java.util.Collections.unmodifiableCollection(Collection)|Returns an unmodifiab
|java.util.Collections.unmodifiableList(List)|Returns an unmodifiable view of t
|java.util.Collections.unmodifiableMap(Map)|Returns an unmodifiable view of the
|java.util.Collections.unmodifiableSet(Set)|Returns an unmodifiable view of the
|java.util.Collections.unmodifiableSortedMap(SortedMap)|Returns an unmodifiable
|java.util.Collections.unmodifiableSortedSet(SortedSet)|Returns an unmodifiable

*java.util.Collections_Description*

This class consists exclusively of static methods that operate on or return 
collections. It contains polymorphic algorithms that operate on collections, 
"wrappers", which return a new collection backed by a specified collection, and 
a few other odds and ends. 

The methods of this class all throw a NullPointerException if the collections 
or class objects provided to them are null. 

The documentation for the polymorphic algorithms contained in this class 
generally includes a brief description of the implementation. Such descriptions 
should be regarded as implementation notes, rather than parts of the 
specification. Implementors should feel free to substitute other algorithms, so 
long as the specification itself is adhered to. (For example, the algorithm 
used by sort does not have to be a mergesort, but it does have to be stable.) 

The "destructive" algorithms contained in this class, that is, the algorithms 
that modify the collection on which they operate, are specified to throw 
UnsupportedOperationException if the collection does not support the 
appropriate mutation primitive(s), such as the set method. These algorithms 
may, but are not required to, throw this exception if an invocation would have 
no effect on the collection. For example, invoking the sort method on an 
unmodifiable list that is already sorted may or may not throw 
UnsupportedOperationException. 

This class is a member of the <a href="/../guide/collections/index.html"> Java 
Collections Framework. 


*java.util.List_java.util.Collections.EMPTY_LIST*

This class consists exclusively of static methods that operate on or return 
collections. It contains polymorphic algorithms that operate on collections, 
"wrappers", which return a new collection backed by a specified collection, and 
a few other odds and ends. 

The methods of this class all throw a NullPointerException if the collections 
or class objects provided to them are null. 

The documentation for the polymorphic algorithms contained in this class 
generally includes a brief description of the implementation. Such descriptions 
should be regarded as implementation notes, rather than parts of the 
specification. Implementors should feel free to substitute other algorithms, so 
long as the specification itself is adhered to. (For example, the algorithm 
used by sort does not have to be a mergesort, but it does have to be stable.) 

The "destructive" algorithms contained in this class, that is, the algorithms 
that modify the collection on which they operate, are specified to throw 
UnsupportedOperationException if the collection does not support the 
appropriate mutation primitive(s), such as the set method. These algorithms 
may, but are not required to, throw this exception if an invocation would have 
no effect on the collection. For example, invoking the sort method on an 
unmodifiable list that is already sorted may or may not throw 
UnsupportedOperationException. 

This class is a member of the <a href="/../guide/collections/index.html"> Java 
Collections Framework. 


*java.util.Map_java.util.Collections.EMPTY_MAP*

This class consists exclusively of static methods that operate on or return 
collections. It contains polymorphic algorithms that operate on collections, 
"wrappers", which return a new collection backed by a specified collection, and 
a few other odds and ends. 

The methods of this class all throw a NullPointerException if the collections 
or class objects provided to them are null. 

The documentation for the polymorphic algorithms contained in this class 
generally includes a brief description of the implementation. Such descriptions 
should be regarded as implementation notes, rather than parts of the 
specification. Implementors should feel free to substitute other algorithms, so 
long as the specification itself is adhered to. (For example, the algorithm 
used by sort does not have to be a mergesort, but it does have to be stable.) 

The "destructive" algorithms contained in this class, that is, the algorithms 
that modify the collection on which they operate, are specified to throw 
UnsupportedOperationException if the collection does not support the 
appropriate mutation primitive(s), such as the set method. These algorithms 
may, but are not required to, throw this exception if an invocation would have 
no effect on the collection. For example, invoking the sort method on an 
unmodifiable list that is already sorted may or may not throw 
UnsupportedOperationException. 

This class is a member of the <a href="/../guide/collections/index.html"> Java 
Collections Framework. 


*java.util.Set_java.util.Collections.EMPTY_SET*

This class consists exclusively of static methods that operate on or return 
collections. It contains polymorphic algorithms that operate on collections, 
"wrappers", which return a new collection backed by a specified collection, and 
a few other odds and ends. 

The methods of this class all throw a NullPointerException if the collections 
or class objects provided to them are null. 

The documentation for the polymorphic algorithms contained in this class 
generally includes a brief description of the implementation. Such descriptions 
should be regarded as implementation notes, rather than parts of the 
specification. Implementors should feel free to substitute other algorithms, so 
long as the specification itself is adhered to. (For example, the algorithm 
used by sort does not have to be a mergesort, but it does have to be stable.) 

The "destructive" algorithms contained in this class, that is, the algorithms 
that modify the collection on which they operate, are specified to throw 
UnsupportedOperationException if the collection does not support the 
appropriate mutation primitive(s), such as the set method. These algorithms 
may, but are not required to, throw this exception if an invocation would have 
no effect on the collection. For example, invoking the sort method on an 
unmodifiable list that is already sorted may or may not throw 
UnsupportedOperationException. 

This class is a member of the <a href="/../guide/collections/index.html"> Java 
Collections Framework. 



*java.util.Collections.addAll(Collection,T[])*

public static boolean addAll(
  java.util.Collection c,
  java.lang.Object[] a)

Adds all of the specified elements to the specified collection. Elements to be 
added may be specified individually or as an array. The behavior of this 
convenience method is identical to that of c.addAll(Arrays.asList(elements)), 
but this method is likely to run significantly faster under most 
implementations. 

When elements are specified individually, this method provides a convenient way 
to add a few elements to an existing collection: 

Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 

    c - the collection into which elements are to be inserted 
    a - the elements to insert into c 

    Returns: true if the collection changed as a result of the call 
*java.util.Collections.binarySearch(List,T)*

public static int binarySearch(
  java.util.List list,
  java.lang.Object key)

Searches the specified list for the specified object using the binary search 
algorithm. The list must be sorted into ascending order according to the 
natural ordering of its elements (as by the sort(List) method, above) prior to 
making this call. If it is not sorted, the results are undefined. If the list 
contains multiple elements equal to the specified object, there is no guarantee 
which one will be found. 

This method runs in log(n) time for a "random access" list (which provides 
near-constant-time positional access). If the specified list does not implement 
the (|java.util.RandomAccess|) interface and is large, this method will do an 
iterator-based binary search that performs O(n) link traversals and O(log n) 
element comparisons. 

    list - the list to be searched. 
    key - the key to be searched for. 

    Returns: index of the search key, if it is contained in the list; otherwise, 
             (-(insertion point) - 1). The insertion point is defined as the 
             point at which the key would be inserted into the list: the index 
             of the first element greater than the key, or list.size(), if all 
             elements in the list are less than the specified key. Note that 
             this guarantees that the return value will be >= 0 if and only if 
             the key is found. 
*java.util.Collections.binarySearch(List,T,Comparator)*

public static int binarySearch(
  java.util.List list,
  java.lang.Object key,
  java.util.Comparator c)

Searches the specified list for the specified object using the binary search 
algorithm. The list must be sorted into ascending order according to the 
specified comparator (as by the Sort(List, Comparator) method, above), prior to 
making this call. If it is not sorted, the results are undefined. If the list 
contains multiple elements equal to the specified object, there is no guarantee 
which one will be found. 

This method runs in log(n) time for a "random access" list (which provides 
near-constant-time positional access). If the specified list does not implement 
the (|java.util.RandomAccess|) interface and is large, this method will do an 
iterator-based binary search that performs O(n) link traversals and O(log n) 
element comparisons. 

    list - the list to be searched. 
    key - the key to be searched for. 
    c - the comparator by which the list is ordered. A null value indicates that the 
       elements' natural ordering should be used. 

    Returns: index of the search key, if it is contained in the list; otherwise, 
             (-(insertion point) - 1). The insertion point is defined as the 
             point at which the key would be inserted into the list: the index 
             of the first element greater than the key, or list.size(), if all 
             elements in the list are less than the specified key. Note that 
             this guarantees that the return value will be >= 0 if and only if 
             the key is found. 
*java.util.Collections.checkedCollection(Collection,Class)*

public static |java.util.Collection| checkedCollection(
  java.util.Collection c,
  java.lang.Class type)

Returns a dynamically typesafe view of the specified collection. Any attempt to 
insert an element of the wrong type will result in an immediate 
ClassCastException. Assuming a collection contains no incorrectly typed 
elements prior to the time a dynamically typesafe view is generated, and that 
all subsequent access to the collection takes place through the view, it is 
guaranteed that the collection cannot contain an incorrectly typed element. 

The generics mechanism in the language provides compile-time (static) type 
checking, but it is possible to defeat this mechanism with unchecked casts. 
Usually this is not a problem, as the compiler issues warnings on all such 
unchecked operations. There are, however, times when static type checking alone 
is not sufficient. For example, suppose a collection is passed to a third-party 
library and it is imperative that the library code not corrupt the collection 
by inserting an element of the wrong type. 

Another use of dynamically typesafe views is debugging. Suppose a program fails 
with a ClassCastException, indicating that an incorrectly typed element was put 
into a parameterized collection. Unfortunately, the exception can occur at any 
time after the erroneous element is inserted, so it typically provides little 
or no information as to the real source of the problem. If the problem is 
reproducible, one can quickly determine its source by temporarily modifying the 
program to wrap the collection with a dynamically typesafe view. For example, 
this declaration: 

Collection<String> c = new HashSet<String>(); 

may be replaced temporarily by this one: 

Collection<String> c = Collections.checkedCollection( new HashSet<String>(), 
String.class); 

Running the program again will cause it to fail at the point where an 
incorrectly typed element is inserted into the collection, clearly identifying 
the source of the problem. Once the problem is fixed, the modified declaration 
may be reverted back to the original. 

The returned collection does not pass the hashCode and equals operations 
through to the backing collection, but relies on Object's equals and hashCode 
methods. This is necessary to preserve the contracts of these operations in the 
case that the backing collection is a set or a list. 

The returned collection will be serializable if the specified collection is 
serializable. 

    c - the collection for which a dynamically typesafe view is to be returned 
    type - the type of element that c is permitted to hold 

    Returns: a dynamically typesafe view of the specified collection 
*java.util.Collections.checkedList(List,Class)*

public static |java.util.List| checkedList(
  java.util.List list,
  java.lang.Class type)

Returns a dynamically typesafe view of the specified list. Any attempt to 
insert an element of the wrong type will result in an immediate 
ClassCastException. Assuming a list contains no incorrectly typed elements 
prior to the time a dynamically typesafe view is generated, and that all 
subsequent access to the list takes place through the view, it is guaranteed 
that the list cannot contain an incorrectly typed element. 

A discussion of the use of dynamically typesafe views may be found in the 
documentation for the checkedCollection(|java.util.Collections|) method. 

The returned list will be serializable if the specified list is serializable. 

    list - the list for which a dynamically typesafe view is to be returned 
    type - the type of element that list is permitted to hold 

    Returns: a dynamically typesafe view of the specified list 
*java.util.Collections.checkedMap(Map,Class,Class)*

public static |java.util.Map| checkedMap(
  java.util.Map m,
  java.lang.Class keyType,
  java.lang.Class valueType)

Returns a dynamically typesafe view of the specified map. Any attempt to insert 
a mapping whose key or value have the wrong type will result in an immediate 
ClassCastException. Similarly, any attempt to modify the value currently 
associated with a key will result in an immediate ClassCastException, whether 
the modification is attempted directly through the map itself, or through a 
(|java.util.Map.Entry|) instance obtained from the map's entry 
set(|java.util.Map|) view. 

Assuming a map contains no incorrectly typed keys or values prior to the time a 
dynamically typesafe view is generated, and that all subsequent access to the 
map takes place through the view (or one of its collection views), it is 
guaranteed that the map cannot contain an incorrectly typed key or value. 

A discussion of the use of dynamically typesafe views may be found in the 
documentation for the checkedCollection(|java.util.Collections|) method. 

The returned map will be serializable if the specified map is serializable. 

    m - the map for which a dynamically typesafe view is to be returned 
    keyType - the type of key that m is permitted to hold 
    valueType - the type of value that m is permitted to hold 

    Returns: a dynamically typesafe view of the specified map 
*java.util.Collections.checkedSet(Set,Class)*

public static |java.util.Set| checkedSet(
  java.util.Set s,
  java.lang.Class type)

Returns a dynamically typesafe view of the specified set. Any attempt to insert 
an element of the wrong type will result in an immediate ClassCastException. 
Assuming a set contains no incorrectly typed elements prior to the time a 
dynamically typesafe view is generated, and that all subsequent access to the 
set takes place through the view, it is guaranteed that the set cannot contain 
an incorrectly typed element. 

A discussion of the use of dynamically typesafe views may be found in the 
documentation for the checkedCollection(|java.util.Collections|) method. 

The returned set will be serializable if the specified set is serializable. 

    s - the set for which a dynamically typesafe view is to be returned 
    type - the type of element that s is permitted to hold 

    Returns: a dynamically typesafe view of the specified set 
*java.util.Collections.checkedSortedMap(SortedMap,Class,Class)*

public static |java.util.SortedMap| checkedSortedMap(
  java.util.SortedMap m,
  java.lang.Class keyType,
  java.lang.Class valueType)

Returns a dynamically typesafe view of the specified sorted map. Any attempt to 
insert a mapping whose key or value have the wrong type will result in an 
immediate ClassCastException. Similarly, any attempt to modify the value 
currently associated with a key will result in an immediate ClassCastException, 
whether the modification is attempted directly through the map itself, or 
through a (|java.util.Map.Entry|) instance obtained from the map's entry 
set(|java.util.Map|) view. 

Assuming a map contains no incorrectly typed keys or values prior to the time a 
dynamically typesafe view is generated, and that all subsequent access to the 
map takes place through the view (or one of its collection views), it is 
guaranteed that the map cannot contain an incorrectly typed key or value. 

A discussion of the use of dynamically typesafe views may be found in the 
documentation for the checkedCollection(|java.util.Collections|) method. 

The returned map will be serializable if the specified map is serializable. 

    m - the map for which a dynamically typesafe view is to be returned 
    keyType - the type of key that m is permitted to hold 
    valueType - the type of value that m is permitted to hold 

    Returns: a dynamically typesafe view of the specified map 
*java.util.Collections.checkedSortedSet(SortedSet,Class)*

public static |java.util.SortedSet| checkedSortedSet(
  java.util.SortedSet s,
  java.lang.Class type)

Returns a dynamically typesafe view of the specified sorted set. Any attempt to 
insert an element of the wrong type will result in an immediate 
ClassCastException. Assuming a sorted set contains no incorrectly typed 
elements prior to the time a dynamically typesafe view is generated, and that 
all subsequent access to the sorted set takes place through the view, it is 
guaranteed that the sorted set cannot contain an incorrectly typed element. 

A discussion of the use of dynamically typesafe views may be found in the 
documentation for the checkedCollection(|java.util.Collections|) method. 

The returned sorted set will be serializable if the specified sorted set is 
serializable. 

    s - the sorted set for which a dynamically typesafe view is to be returned 
    type - the type of element that s is permitted to hold 

    Returns: a dynamically typesafe view of the specified sorted set 
*java.util.Collections.copy(List,List)*

public static void copy(
  java.util.List dest,
  java.util.List src)

Copies all of the elements from one list into another. After the operation, the 
index of each copied element in the destination list will be identical to its 
index in the source list. The destination list must be at least as long as the 
source list. If it is longer, the remaining elements in the destination list 
are unaffected. 

This method runs in linear time. 

    dest - The destination list. 
    src - The source list. 

*java.util.Collections.disjoint(Collection,Collection)*

public static boolean disjoint(
  java.util.Collection c1,
  java.util.Collection c2)

Returns true if the two specified collections have no elements in common. 

Care must be exercised if this method is used on collections that do not comply 
with the general contract for Collection. Implementations may elect to iterate 
over either collection and test for containment in the other collection (or to 
perform any equivalent computation). If either collection uses a nonstandard 
equality test (as does a (|java.util.SortedSet|) whose ordering is not 
compatible with equals, or the key set of an (|java.util.IdentityHashMap|) ), 
both collections must use the same nonstandard equality test, or the result of 
this method is undefined. 

Note that it is permissible to pass the same collection in both parameters, in 
which case the method will return true if and only if the collection is empty. 

    c1 - a collection 
    c2 - a collection 

*java.util.Collections.emptyList()*

public static final |java.util.List| emptyList()

Returns the empty list (immutable). This list is serializable. 

This example illustrates the type-safe way to obtain an empty list: 

List<String> s = Collections.emptyList(); 

Implementation note: Implementations of this method need not create a separate 
List object for each call. Using this method is likely to have comparable cost 
to using the like-named field. (Unlike this method, the field does not provide 
type safety.) 


*java.util.Collections.emptyMap()*

public static final |java.util.Map| emptyMap()

Returns the empty map (immutable). This map is serializable. 

This example illustrates the type-safe way to obtain an empty set: 

Map<String, Date> s = Collections.emptyMap(); 

Implementation note: Implementations of this method need not create a separate 
Map object for each call. Using this method is likely to have comparable cost 
to using the like-named field. (Unlike this method, the field does not provide 
type safety.) 


*java.util.Collections.emptySet()*

public static final |java.util.Set| emptySet()

Returns the empty set (immutable). This set is serializable. Unlike the 
like-named field, this method is parameterized. 

This example illustrates the type-safe way to obtain an empty set: 

Set<String> s = Collections.emptySet(); 

Implementation note: Implementations of this method need not create a separate 
Set object for each call. Using this method is likely to have comparable cost 
to using the like-named field. (Unlike this method, the field does not provide 
type safety.) 


*java.util.Collections.enumeration(Collection)*

public static |java.util.Enumeration| enumeration(java.util.Collection c)

Returns an enumeration over the specified collection. This provides 
interoperability with legacy APIs that require an enumeration as input. 

    c - the collection for which an enumeration is to be returned. 

    Returns: an enumeration over the specified collection. 
*java.util.Collections.fill(List,T)*

public static void fill(
  java.util.List list,
  java.lang.Object obj)

Replaces all of the elements of the specified list with the specified element. 

This method runs in linear time. 

    list - the list to be filled with the specified element. 
    obj - The element with which to fill the specified list. 

*java.util.Collections.frequency(Collection,Object)*

public static int frequency(
  java.util.Collection c,
  java.lang.Object o)

Returns the number of elements in the specified collection equal to the 
specified object. More formally, returns the number of elements e in the 
collection such that (o == null ? e == null : o.equals(e)). 

    c - the collection in which to determine the frequency of o 
    o - the object whose frequency is to be determined 

*java.util.Collections.indexOfSubList(List,List)*

public static int indexOfSubList(
  java.util.List source,
  java.util.List target)

Returns the starting position of the first occurrence of the specified target 
list within the specified source list, or -1 if there is no such occurrence. 
More formally, returns the lowest index i such that source.subList(i, 
i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 
if target.size() > source.size().) 

This implementation uses the "brute force" technique of scanning over the 
source list, looking for a match with the target at each location in turn. 

    source - the list in which to search for the first occurrence of target. 
    target - the list to search for as a subList of source. 

    Returns: the starting position of the first occurrence of the specified target list 
             within the specified source list, or -1 if there is no such 
             occurrence. 
*java.util.Collections.lastIndexOfSubList(List,List)*

public static int lastIndexOfSubList(
  java.util.List source,
  java.util.List target)

Returns the starting position of the last occurrence of the specified target 
list within the specified source list, or -1 if there is no such occurrence. 
More formally, returns the highest index i such that source.subList(i, 
i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 
if target.size() > source.size().) 

This implementation uses the "brute force" technique of iterating over the 
source list, looking for a match with the target at each location in turn. 

    source - the list in which to search for the last occurrence of target. 
    target - the list to search for as a subList of source. 

    Returns: the starting position of the last occurrence of the specified target list 
             within the specified source list, or -1 if there is no such 
             occurrence. 
*java.util.Collections.list(Enumeration)*

public static |java.util.ArrayList| list(java.util.Enumeration e)

Returns an array list containing the elements returned by the specified 
enumeration in the order they are returned by the enumeration. This method 
provides interoperability between legacy APIs that return enumerations and new 
APIs that require collections. 

    e - enumeration providing elements for the returned array list 

    Returns: an array list containing the elements returned by the specified enumeration. 
*java.util.Collections.max(Collection)*

public static |java.lang.Object| max(java.util.Collection coll)

Returns the maximum element of the given collection, according to the natural 
ordering of its elements. All elements in the collection must implement the 
Comparable interface. Furthermore, all elements in the collection must be 
mutually comparable (that is, e1.compareTo(e2) must not throw a 
ClassCastException for any elements e1 and e2 in the collection). 

This method iterates over the entire collection, hence it requires time 
proportional to the size of the collection. 

    coll - the collection whose maximum element is to be determined. 

    Returns: the maximum element of the given collection, according to the natural ordering 
             of its elements. 
*java.util.Collections.max(Collection,Comparator)*

public static |java.lang.Object| max(
  java.util.Collection coll,
  java.util.Comparator comp)

Returns the maximum element of the given collection, according to the order 
induced by the specified comparator. All elements in the collection must be 
mutually comparable by the specified comparator (that is, comp.compare(e1, e2) 
must not throw a ClassCastException for any elements e1 and e2 in the 
collection). 

This method iterates over the entire collection, hence it requires time 
proportional to the size of the collection. 

    coll - the collection whose maximum element is to be determined. 
    comp - the comparator with which to determine the maximum element. A null value 
       indicates that the elements' natural ordering should be used. 

    Returns: the maximum element of the given collection, according to the specified 
             comparator. 
*java.util.Collections.min(Collection)*

public static |java.lang.Object| min(java.util.Collection coll)

Returns the minimum element of the given collection, according to the natural 
ordering of its elements. All elements in the collection must implement the 
Comparable interface. Furthermore, all elements in the collection must be 
mutually comparable (that is, e1.compareTo(e2) must not throw a 
ClassCastException for any elements e1 and e2 in the collection). 

This method iterates over the entire collection, hence it requires time 
proportional to the size of the collection. 

    coll - the collection whose minimum element is to be determined. 

    Returns: the minimum element of the given collection, according to the natural ordering 
             of its elements. 
*java.util.Collections.min(Collection,Comparator)*

public static |java.lang.Object| min(
  java.util.Collection coll,
  java.util.Comparator comp)

Returns the minimum element of the given collection, according to the order 
induced by the specified comparator. All elements in the collection must be 
mutually comparable by the specified comparator (that is, comp.compare(e1, e2) 
must not throw a ClassCastException for any elements e1 and e2 in the 
collection). 

This method iterates over the entire collection, hence it requires time 
proportional to the size of the collection. 

    coll - the collection whose minimum element is to be determined. 
    comp - the comparator with which to determine the minimum element. A null value 
       indicates that the elements' natural ordering should be used. 

    Returns: the minimum element of the given collection, according to the specified 
             comparator. 
*java.util.Collections.nCopies(int,T)*

public static |java.util.List| nCopies(
  int n,
  java.lang.Object o)

Returns an immutable list consisting of n copies of the specified object. The 
newly allocated data object is tiny (it contains a single reference to the data 
object). This method is useful in combination with the List.addAll method to 
grow lists. The returned list is serializable. 

    n - the number of elements in the returned list. 
    o - the element to appear repeatedly in the returned list. 

    Returns: an immutable list consisting of n copies of the specified object. 
*java.util.Collections.replaceAll(List,T,T)*

public static boolean replaceAll(
  java.util.List list,
  java.lang.Object oldVal,
  java.lang.Object newVal)

Replaces all occurrences of one specified value in a list with another. More 
formally, replaces with newVal each element e in list such that (oldVal==null ? 
e==null : oldVal.equals(e)). (This method has no effect on the size of the 
list.) 

    list - the list in which replacement is to occur. 
    oldVal - the old value to be replaced. 
    newVal - the new value with which oldVal is to be replaced. 

    Returns: true if list contained one or more elements e such that (oldVal==null ? e==null 
             : oldVal.equals(e)). 
*java.util.Collections.reverse(List)*

public static void reverse(java.util.List list)

Reverses the order of the elements in the specified list. 

This method runs in linear time. 

    list - the list whose elements are to be reversed. 

*java.util.Collections.reverseOrder()*

public static |java.util.Comparator| reverseOrder()

Returns a comparator that imposes the reverse of the natural ordering on a 
collection of objects that implement the Comparable interface. (The natural 
ordering is the ordering imposed by the objects' own compareTo method.) This 
enables a simple idiom for sorting (or maintaining) collections (or arrays) of 
objects that implement the Comparable interface in reverse-natural-order. For 
example, suppose a is an array of strings. Then: 

Arrays.sort(a, Collections.reverseOrder()); 

sorts the array in reverse-lexicographic (alphabetical) order. 

The returned comparator is serializable. 


    Returns: a comparator that imposes the reverse of the natural ordering on a collection 
             of objects that implement the Comparable interface. 
*java.util.Collections.reverseOrder(Comparator)*

public static |java.util.Comparator| reverseOrder(java.util.Comparator cmp)

Returns a comparator that imposes the reverse ordering of the specified 
comparator. If the specified comparator is null, this method is equivalent to 
(|java.util.Collections|) (in other words, it returns a comparator that imposes 
the reverse of the natural ordering on a collection of objects that implement 
the Comparable interface). 

The returned comparator is serializable (assuming the specified comparator is 
also serializable or null). 


    Returns: a comparator that imposes the reverse ordering of the specified comparator. 
*java.util.Collections.rotate(List,int)*

public static void rotate(
  java.util.List list,
  int distance)

Rotates the elements in the specified list by the specified distance. After 
calling this method, the element at index i will be the element previously at 
index (i - distance) mod list.size(), for all values of i between 0 and 
list.size()-1, inclusive. (This method has no effect on the size of the list.) 

For example, suppose list comprises [t, a, n, k, s]. After invoking 
Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will 
comprise [s, t, a, n, k]. 

Note that this method can usefully be applied to sublists to move one or more 
elements within a list while preserving the order of the remaining elements. 
For example, the following idiom moves the element at index j forward to 
position k (which must be greater than or equal to j): 

Collections.rotate(list.subList(j, k+1), -1); 

To make this concrete, suppose list comprises [a, b, c, d, e]. To move the 
element at index 1 (b) forward two positions, perform the following invocation: 

Collections.rotate(l.subList(1, 4), -1); 

The resulting list is [a, c, d, b, e]. 

To move more than one element forward, increase the absolute value of the 
rotation distance. To move elements backward, use a positive shift distance. 

If the specified list is small or implements the (|java.util.RandomAccess|) 
interface, this implementation exchanges the first element into the location it 
should go, and then repeatedly exchanges the displaced element into the 
location it should go until a displaced element is swapped into the first 
element. If necessary, the process is repeated on the second and successive 
elements, until the rotation is complete. If the specified list is large and 
doesn't implement the RandomAccess interface, this implementation breaks the 
list into two sublist views around index -distance mod size. Then the 
(|java.util.Collections|) method is invoked on each sublist view, and finally 
it is invoked on the entire list. For a more complete description of both 
algorithms, see Section 2.3 of Jon Bentley's Programming Pearls 
(Addison-Wesley, 1986). 

    list - the list to be rotated. 
    distance - the distance to rotate the list. There are no constraints on this value; it may 
       be zero, negative, or greater than list.size(). 

*java.util.Collections.shuffle(List)*

public static void shuffle(java.util.List list)

Randomly permutes the specified list using a default source of randomness. All 
permutations occur with approximately equal likelihood. 

The hedge "approximately" is used in the foregoing description because default 
source of randomness is only approximately an unbiased source of independently 
chosen bits. If it were a perfect source of randomly chosen bits, then the 
algorithm would choose permutations with perfect uniformity. 

This implementation traverses the list backwards, from the last element up to 
the second, repeatedly swapping a randomly selected element into the "current 
position". Elements are randomly selected from the portion of the list that 
runs from the first element to the current position, inclusive. 

This method runs in linear time. If the specified list does not implement the 
(|java.util.RandomAccess|) interface and is large, this implementation dumps 
the specified list into an array before shuffling it, and dumps the shuffled 
array back into the list. This avoids the quadratic behavior that would result 
from shuffling a "sequential access" list in place. 

    list - the list to be shuffled. 

*java.util.Collections.shuffle(List,Random)*

public static void shuffle(
  java.util.List list,
  java.util.Random rnd)

Randomly permute the specified list using the specified source of randomness. 
All permutations occur with equal likelihood assuming that the source of 
randomness is fair. 

This implementation traverses the list backwards, from the last element up to 
the second, repeatedly swapping a randomly selected element into the "current 
position". Elements are randomly selected from the portion of the list that 
runs from the first element to the current position, inclusive. 

This method runs in linear time. If the specified list does not implement the 
(|java.util.RandomAccess|) interface and is large, this implementation dumps 
the specified list into an array before shuffling it, and dumps the shuffled 
array back into the list. This avoids the quadratic behavior that would result 
from shuffling a "sequential access" list in place. 

    list - the list to be shuffled. 
    rnd - the source of randomness to use to shuffle the list. 

*java.util.Collections.singleton(T)*

public static |java.util.Set| singleton(java.lang.Object o)

Returns an immutable set containing only the specified object. The returned set 
is serializable. 

    o - the sole object to be stored in the returned set. 

    Returns: an immutable set containing only the specified object. 
*java.util.Collections.singletonList(T)*

public static |java.util.List| singletonList(java.lang.Object o)

Returns an immutable list containing only the specified object. The returned 
list is serializable. 

    o - the sole object to be stored in the returned list. 

    Returns: an immutable list containing only the specified object. 
*java.util.Collections.singletonMap(K,V)*

public static |java.util.Map| singletonMap(
  java.lang.Object key,
  java.lang.Object value)

Returns an immutable map, mapping only the specified key to the specified 
value. The returned map is serializable. 

    key - the sole key to be stored in the returned map. 
    value - the value to which the returned map maps key. 

    Returns: an immutable map containing only the specified key-value mapping. 
*java.util.Collections.sort(List)*

public static void sort(java.util.List list)

Sorts the specified list into ascending order, according to the natural 
ordering of its elements. All elements in the list must implement the 
Comparable interface. Furthermore, all elements in the list must be mutually 
comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for 
any elements e1 and e2 in the list). 

This sort is guaranteed to be stable: equal elements will not be reordered as a 
result of the sort. 

The specified list must be modifiable, but need not be resizable. 

The sorting algorithm is a modified mergesort (in which the merge is omitted if 
the highest element in the low sublist is less than the lowest element in the 
high sublist). This algorithm offers guaranteed n log(n) performance. 

This implementation dumps the specified list into an array, sorts the array, 
and iterates over the list resetting each element from the corresponding 
position in the array. This avoids the n2 log(n) performance that would result 
from attempting to sort a linked list in place. 

    list - the list to be sorted. 

*java.util.Collections.sort(List,Comparator)*

public static void sort(
  java.util.List list,
  java.util.Comparator c)

Sorts the specified list according to the order induced by the specified 
comparator. All elements in the list must be mutually comparable using the 
specified comparator (that is, c.compare(e1, e2) must not throw a 
ClassCastException for any elements e1 and e2 in the list). 

This sort is guaranteed to be stable: equal elements will not be reordered as a 
result of the sort. 

The sorting algorithm is a modified mergesort (in which the merge is omitted if 
the highest element in the low sublist is less than the lowest element in the 
high sublist). This algorithm offers guaranteed n log(n) performance. 

The specified list must be modifiable, but need not be resizable. This 
implementation dumps the specified list into an array, sorts the array, and 
iterates over the list resetting each element from the corresponding position 
in the array. This avoids the n2 log(n) performance that would result from 
attempting to sort a linked list in place. 

    list - the list to be sorted. 
    c - the comparator to determine the order of the list. A null value indicates that 
       the elements' natural ordering should be used. 

*java.util.Collections.swap(List,int,int)*

public static void swap(
  java.util.List list,
  int i,
  int j)

Swaps the elements at the specified positions in the specified list. (If the 
specified positions are equal, invoking this method leaves the list unchanged.) 

    list - The list in which to swap elements. 
    i - the index of one element to be swapped. 
    j - the index of the other element to be swapped. 

*java.util.Collections.synchronizedCollection(Collection)*

public static |java.util.Collection| synchronizedCollection(java.util.Collection c)

Returns a synchronized (thread-safe) collection backed by the specified 
collection. In order to guarantee serial access, it is critical that all access 
to the backing collection is accomplished through the returned collection. 

It is imperative that the user manually synchronize on the returned collection 
when iterating over it: 

Collection c = Collections.synchronizedCollection(myCollection); ... 
synchronized(c) { Iterator i = c.iterator(); // Must be in the synchronized 
block while (i.hasNext()) foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned collection does not pass the hashCode and equals operations 
through to the backing collection, but relies on Object's equals and hashCode 
methods. This is necessary to preserve the contracts of these operations in the 
case that the backing collection is a set or a list. 

The returned collection will be serializable if the specified collection is 
serializable. 

    c - the collection to be "wrapped" in a synchronized collection. 

    Returns: a synchronized view of the specified collection. 
*java.util.Collections.synchronizedList(List)*

public static |java.util.List| synchronizedList(java.util.List list)

Returns a synchronized (thread-safe) list backed by the specified list. In 
order to guarantee serial access, it is critical that all access to the backing 
list is accomplished through the returned list. 

It is imperative that the user manually synchronize on the returned list when 
iterating over it: 

List list = Collections.synchronizedList(new ArrayList()); ... 
synchronized(list) { Iterator i = list.iterator(); // Must be in synchronized 
block while (i.hasNext()) foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned list will be serializable if the specified list is serializable. 

    list - the list to be "wrapped" in a synchronized list. 

    Returns: a synchronized view of the specified list. 
*java.util.Collections.synchronizedMap(Map)*

public static |java.util.Map| synchronizedMap(java.util.Map m)

Returns a synchronized (thread-safe) map backed by the specified map. In order 
to guarantee serial access, it is critical that all access to the backing map 
is accomplished through the returned map. 

It is imperative that the user manually synchronize on the returned map when 
iterating over any of its collection views: 

Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // 
Needn't be in synchronized block ... synchronized(m) { // Synchronizing on m, 
not s! Iterator i = s.iterator(); // Must be in synchronized block while 
(i.hasNext()) foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned map will be serializable if the specified map is serializable. 

    m - the map to be "wrapped" in a synchronized map. 

    Returns: a synchronized view of the specified map. 
*java.util.Collections.synchronizedSet(Set)*

public static |java.util.Set| synchronizedSet(java.util.Set s)

Returns a synchronized (thread-safe) set backed by the specified set. In order 
to guarantee serial access, it is critical that all access to the backing set 
is accomplished through the returned set. 

It is imperative that the user manually synchronize on the returned set when 
iterating over it: 

Set s = Collections.synchronizedSet(new HashSet()); ... synchronized(s) { 
Iterator i = s.iterator(); // Must be in the synchronized block while 
(i.hasNext()) foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned set will be serializable if the specified set is serializable. 

    s - the set to be "wrapped" in a synchronized set. 

    Returns: a synchronized view of the specified set. 
*java.util.Collections.synchronizedSortedMap(SortedMap)*

public static |java.util.SortedMap| synchronizedSortedMap(java.util.SortedMap m)

Returns a synchronized (thread-safe) sorted map backed by the specified sorted 
map. In order to guarantee serial access, it is critical that all access to the 
backing sorted map is accomplished through the returned sorted map (or its 
views). 

It is imperative that the user manually synchronize on the returned sorted map 
when iterating over any of its collection views, or the collections views of 
any of its subMap, headMap or tailMap views. 

SortedMap m = Collections.synchronizedSortedMap(new HashSortedMap()); ... Set s 
= m.keySet(); // Needn't be in synchronized block ... synchronized(m) { // 
Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in 
synchronized block while (i.hasNext()) foo(i.next()); } 

or: 

SortedMap m = Collections.synchronizedSortedMap(new HashSortedMap()); SortedMap 
m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in 
synchronized block ... synchronized(m) { // Synchronizing on m, not m2 or s2! 
Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) 
foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned sorted map will be serializable if the specified sorted map is 
serializable. 

    m - the sorted map to be "wrapped" in a synchronized sorted map. 

    Returns: a synchronized view of the specified sorted map. 
*java.util.Collections.synchronizedSortedSet(SortedSet)*

public static |java.util.SortedSet| synchronizedSortedSet(java.util.SortedSet s)

Returns a synchronized (thread-safe) sorted set backed by the specified sorted 
set. In order to guarantee serial access, it is critical that all access to the 
backing sorted set is accomplished through the returned sorted set (or its 
views). 

It is imperative that the user manually synchronize on the returned sorted set 
when iterating over it or any of its subSet, headSet, or tailSet views. 

SortedSet s = Collections.synchronizedSortedSet(new HashSortedSet()); ... 
synchronized(s) { Iterator i = s.iterator(); // Must be in the synchronized 
block while (i.hasNext()) foo(i.next()); } 

or: 

SortedSet s = Collections.synchronizedSortedSet(new HashSortedSet()); SortedSet 
s2 = s.headSet(foo); ... synchronized(s) { // Note: s, not s2!!! Iterator i = 
s2.iterator(); // Must be in the synchronized block while (i.hasNext()) 
foo(i.next()); } 

Failure to follow this advice may result in non-deterministic behavior. 

The returned sorted set will be serializable if the specified sorted set is 
serializable. 

    s - the sorted set to be "wrapped" in a synchronized sorted set. 

    Returns: a synchronized view of the specified sorted set. 
*java.util.Collections.unmodifiableCollection(Collection)*

public static |java.util.Collection| unmodifiableCollection(java.util.Collection c)

Returns an unmodifiable view of the specified collection. This method allows 
modules to provide users with "read-only" access to internal collections. Query 
operations on the returned collection "read through" to the specified 
collection, and attempts to modify the returned collection, whether direct or 
via its iterator, result in an UnsupportedOperationException. 

The returned collection does not pass the hashCode and equals operations 
through to the backing collection, but relies on Object's equals and hashCode 
methods. This is necessary to preserve the contracts of these operations in the 
case that the backing collection is a set or a list. 

The returned collection will be serializable if the specified collection is 
serializable. 

    c - the collection for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified collection. 
*java.util.Collections.unmodifiableList(List)*

public static |java.util.List| unmodifiableList(java.util.List list)

Returns an unmodifiable view of the specified list. This method allows modules 
to provide users with "read-only" access to internal lists. Query operations on 
the returned list "read through" to the specified list, and attempts to modify 
the returned list, whether direct or via its iterator, result in an 
UnsupportedOperationException. 

The returned list will be serializable if the specified list is serializable. 
Similarly, the returned list will implement (|java.util.RandomAccess|) if the 
specified list does. 

    list - the list for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified list. 
*java.util.Collections.unmodifiableMap(Map)*

public static |java.util.Map| unmodifiableMap(java.util.Map m)

Returns an unmodifiable view of the specified map. This method allows modules 
to provide users with "read-only" access to internal maps. Query operations on 
the returned map "read through" to the specified map, and attempts to modify 
the returned map, whether direct or via its collection views, result in an 
UnsupportedOperationException. 

The returned map will be serializable if the specified map is serializable. 

    m - the map for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified map. 
*java.util.Collections.unmodifiableSet(Set)*

public static |java.util.Set| unmodifiableSet(java.util.Set s)

Returns an unmodifiable view of the specified set. This method allows modules 
to provide users with "read-only" access to internal sets. Query operations on 
the returned set "read through" to the specified set, and attempts to modify 
the returned set, whether direct or via its iterator, result in an 
UnsupportedOperationException. 

The returned set will be serializable if the specified set is serializable. 

    s - the set for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified set. 
*java.util.Collections.unmodifiableSortedMap(SortedMap)*

public static |java.util.SortedMap| unmodifiableSortedMap(java.util.SortedMap m)

Returns an unmodifiable view of the specified sorted map. This method allows 
modules to provide users with "read-only" access to internal sorted maps. Query 
operations on the returned sorted map "read through" to the specified sorted 
map. Attempts to modify the returned sorted map, whether direct, via its 
collection views, or via its subMap, headMap, or tailMap views, result in an 
UnsupportedOperationException. 

The returned sorted map will be serializable if the specified sorted map is 
serializable. 

    m - the sorted map for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified sorted map. 
*java.util.Collections.unmodifiableSortedSet(SortedSet)*

public static |java.util.SortedSet| unmodifiableSortedSet(java.util.SortedSet s)

Returns an unmodifiable view of the specified sorted set. This method allows 
modules to provide users with "read-only" access to internal sorted sets. Query 
operations on the returned sorted set "read through" to the specified sorted 
set. Attempts to modify the returned sorted set, whether direct, via its 
iterator, or via its subSet, headSet, or tailSet views, result in an 
UnsupportedOperationException. 

The returned sorted set will be serializable if the specified sorted set is 
serializable. 

    s - the sorted set for which an unmodifiable view is to be returned. 

    Returns: an unmodifiable view of the specified sorted set. 

