*java.util.Calendar* *Calendar* The Calendar class is an abstract class that pro

public abstract class Calendar
  extends    |java.lang.Object|
  implements |java.io.Serializable|
             |java.lang.Cloneable|
             |java.lang.Comparable|

|java.util.Calendar_Description|
|java.util.Calendar_Fields|
|java.util.Calendar_Constructors|
|java.util.Calendar_Methods|

================================================================================

*java.util.Calendar_Fields*
|int_java.util.Calendar.AM|
|int_java.util.Calendar.AM_PM|
|int_java.util.Calendar.APRIL|
|boolean_java.util.Calendar.areFieldsSet|
|int_java.util.Calendar.AUGUST|
|int_java.util.Calendar.DATE|
|int_java.util.Calendar.DAY_OF_MONTH|
|int_java.util.Calendar.DAY_OF_WEEK|
|int_java.util.Calendar.DAY_OF_WEEK_IN_MONTH|
|int_java.util.Calendar.DAY_OF_YEAR|
|int_java.util.Calendar.DECEMBER|
|int_java.util.Calendar.DST_OFFSET|
|int_java.util.Calendar.ERA|
|int_java.util.Calendar.FEBRUARY|
|int_java.util.Calendar.FIELD_COUNT|
|int[]_java.util.Calendar.fields|
|int_java.util.Calendar.FRIDAY|
|int_java.util.Calendar.HOUR|
|int_java.util.Calendar.HOUR_OF_DAY|
|boolean[]_java.util.Calendar.isSet|
|boolean_java.util.Calendar.isTimeSet|
|int_java.util.Calendar.JANUARY|
|int_java.util.Calendar.JULY|
|int_java.util.Calendar.JUNE|
|int_java.util.Calendar.MARCH|
|int_java.util.Calendar.MAY|
|int_java.util.Calendar.MILLISECOND|
|int_java.util.Calendar.MINUTE|
|int_java.util.Calendar.MONDAY|
|int_java.util.Calendar.MONTH|
|int_java.util.Calendar.NOVEMBER|
|int_java.util.Calendar.OCTOBER|
|int_java.util.Calendar.PM|
|int_java.util.Calendar.SATURDAY|
|int_java.util.Calendar.SECOND|
|int_java.util.Calendar.SEPTEMBER|
|int_java.util.Calendar.SUNDAY|
|int_java.util.Calendar.THURSDAY|
|long_java.util.Calendar.time|
|int_java.util.Calendar.TUESDAY|
|int_java.util.Calendar.UNDECIMBER|
|int_java.util.Calendar.WEDNESDAY|
|int_java.util.Calendar.WEEK_OF_MONTH|
|int_java.util.Calendar.WEEK_OF_YEAR|
|int_java.util.Calendar.YEAR|
|int_java.util.Calendar.ZONE_OFFSET|

*java.util.Calendar_Constructors*
|java.util.Calendar()|Constructs a Calendar with the default time zone  and loc
|java.util.Calendar(TimeZone,Locale)|Constructs a calendar with the specified t

*java.util.Calendar_Methods*
|java.util.Calendar.add(int,int)|Adds or subtracts the specified amount of time
|java.util.Calendar.after(Object)|Returns whether this Calendar represents a ti
|java.util.Calendar.before(Object)|Returns whether this Calendar represents a t
|java.util.Calendar.clear()|Sets all the calendar field values and the time val
|java.util.Calendar.clear(int)|Sets the given calendar field value and the time
|java.util.Calendar.clone()|Creates and returns a copy of this object.
|java.util.Calendar.compareTo(Calendar)|Compares the time values (millisecond o
|java.util.Calendar.complete()|Fills in any unset fields in the calendar fields
|java.util.Calendar.computeFields()|Converts the current millisecond time value
|java.util.Calendar.computeTime()|Converts the current calendar field values in
|java.util.Calendar.equals(Object)|Compares this Calendar to the specified  Obj
|java.util.Calendar.get(int)|Returns the value of the given calendar field.
|java.util.Calendar.getActualMaximum(int)|Returns the maximum value that the sp
|java.util.Calendar.getActualMinimum(int)|Returns the minimum value that the sp
|java.util.Calendar.getAvailableLocales()|Returns an array of all locales for w
|java.util.Calendar.getFirstDayOfWeek()|Gets what the first day of the week is;
|java.util.Calendar.getGreatestMinimum(int)|Returns the highest minimum value f
|java.util.Calendar.getInstance()|Gets a calendar using the default time zone a
|java.util.Calendar.getInstance(Locale)|Gets a calendar using the default time 
|java.util.Calendar.getInstance(TimeZone)|Gets a calendar using the specified t
|java.util.Calendar.getInstance(TimeZone,Locale)|Gets a calendar with the speci
|java.util.Calendar.getLeastMaximum(int)|Returns the lowest maximum value for t
|java.util.Calendar.getMaximum(int)|Returns the maximum value for the given cal
|java.util.Calendar.getMinimalDaysInFirstWeek()|Gets what the minimal days requ
|java.util.Calendar.getMinimum(int)|Returns the minimum value for the given cal
|java.util.Calendar.getTime()|Returns a Date object representing this  Calendar
|java.util.Calendar.getTimeInMillis()|Returns this Calendar's time value in mil
|java.util.Calendar.getTimeZone()|Gets the time zone.
|java.util.Calendar.hashCode()|Returns a hash code for this calendar.
|java.util.Calendar.internalGet(int)|Returns the value of the given calendar fi
|java.util.Calendar.isLenient()|Tells whether date/time interpretation is to be
|java.util.Calendar.isSet(int)|Determines if the given calendar field has a val
|java.util.Calendar.roll(int,boolean)|Adds or subtracts (up/down) a single unit
|java.util.Calendar.roll(int,int)|Adds the specified (signed) amount to the spe
|java.util.Calendar.set(int,int)|Sets the given calendar field to the given val
|java.util.Calendar.set(int,int,int)|Sets the values for the calendar fields YE
|java.util.Calendar.set(int,int,int,int,int)|Sets the values for the calendar f
|java.util.Calendar.set(int,int,int,int,int,int)|Sets the values for the fields
|java.util.Calendar.setFirstDayOfWeek(int)|Sets what the first day of the week 
|java.util.Calendar.setLenient(boolean)|Specifies whether or not date/time inte
|java.util.Calendar.setMinimalDaysInFirstWeek(int)|Sets what the minimal days r
|java.util.Calendar.setTime(Date)|Sets this Calendar's time with the given Date
|java.util.Calendar.setTimeInMillis(long)|Sets this Calendar's current time fro
|java.util.Calendar.setTimeZone(TimeZone)|Sets the time zone with the given tim
|java.util.Calendar.toString()|Return a string representation of this calendar.

*java.util.Calendar_Description*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.AM*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.AM_PM*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.APRIL*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*boolean_java.util.Calendar.areFieldsSet*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.AUGUST*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DATE*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DAY_OF_MONTH*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DAY_OF_WEEK*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DAY_OF_WEEK_IN_MONTH*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DAY_OF_YEAR*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DECEMBER*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.DST_OFFSET*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.ERA*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.FEBRUARY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.FIELD_COUNT*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int[]_java.util.Calendar.fields*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.FRIDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.HOUR*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.HOUR_OF_DAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*boolean[]_java.util.Calendar.isSet*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*boolean_java.util.Calendar.isTimeSet*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.JANUARY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.JULY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.JUNE*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MARCH*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MILLISECOND*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MINUTE*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MONDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.MONTH*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.NOVEMBER*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.OCTOBER*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.PM*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.SATURDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.SECOND*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.SEPTEMBER*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.SUNDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.THURSDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*long_java.util.Calendar.time*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.TUESDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.UNDECIMBER*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.WEDNESDAY*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.WEEK_OF_MONTH*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.WEEK_OF_YEAR*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.YEAR*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 


*int_java.util.Calendar.ZONE_OFFSET*

The Calendar class is an abstract class that provides methods for converting 
between a specific instant in time and a set of calendar 
fields(|java.util.Calendar|) such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so 
on, and for manipulating the calendar fields, such as getting the date of the 
next week. An instant in time can be represented by a millisecond value that is 
an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). 

The class also provides additional fields and methods for implementing a 
concrete calendar system outside the package. Those fields and methods are 
defined as protected. 

Like other locale-sensitive classes, Calendar provides a class method, 
getInstance, for getting a generally useful object of this type. Calendar's 
getInstance method returns a Calendar object whose calendar fields have been 
initialized with the current date and time: 



Calendar rightNow = Calendar.getInstance(); 



A Calendar object can produce all the calendar field values needed to implement 
the date-time formatting for a particular language and calendar style (for 
example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range 
of values returned by certain calendar fields, as well as their meaning. For 
example, the first month of the calendar system has value MONTH == JANUARY for 
all calendars. Other values are defined by the concrete subclass, such as ERA. 
See individual field documentation and subclass documentation for details. 

Getting and Setting Calendar Field Values 

The calendar field values can be set by calling the set methods. Any field 
values set in a Calendar will not be interpreted until it needs to calculate 
its time value (milliseconds from the Epoch) or values of the calendar fields. 
Calling the get, getTimeInMillis, getTime, add and roll involves such 
calculation. 

Leniency 

Calendar has two modes for interpreting the calendar fields, lenient and 
non-lenient. When a Calendar is in lenient mode, it accepts a wider range of 
calendar field values than it produces. When a Calendar recomputes calendar 
field values for return by get(), all of the calendar fields are normalized. 
For example, a lenient GregorianCalendar interprets MONTH == JANUARY, 
DAY_OF_MONTH == 32 as February 1. 

When a Calendar is in non-lenient mode, it throws an exception if there is any 
inconsistency in its calendar fields. For example, a GregorianCalendar always 
produces DAY_OF_MONTH values between 1 and the length of the month. A 
non-lenient GregorianCalendar throws an exception upon calculating its time or 
calendar field values if any out-of-range field value has been set. 

First Week 

Calendar defines a locale-specific seven day week using two parameters: the 
first day of the week and the minimal days in first week (from 1 to 7). These 
numbers are taken from the locale resource data when a Calendar is constructed. 
They may also be specified explicitly through the methods for setting their 
values. 

When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must 
determine the first week of the month or year as a reference point. The first 
week of a month or year is defined as the earliest seven day period beginning 
on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days 
of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks 
numbered 2, 3,... follow it. Note that the normalized numbering returned by 
get() may be different. For example, a specific Calendar subclass may designate 
the week before week 1 of a year as week n of the previous year. 

Calendar Fields Resolution 

When computing a date and time from the calendar fields, there may be 
insufficient information for the computation (such as only year and month with 
no day of month), or there may be inconsistent information (such as Tuesday, 
July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will 
resolve calendar field values to determine the date and time in the following 
way. 

If there is any conflict in calendar field values, Calendar gives priorities to 
calendar fields that have been set more recently. The following are the default 
combinations of the calendar fields. The most recent combination, as determined 
by the most recently set single field, will be used. 

For the date fields: 



YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + 
MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + 
DAY_OF_WEEK + WEEK_OF_YEAR 

For the time of day fields: 



HOUR_OF_DAY AM_PM + HOUR 

If there are any calendar fields whose values haven't been set in the selected 
field combination, Calendar uses their default values. The default value of 
each field may vary by concrete calendar systems. For example, in 
GregorianCalendar, the default of a field is the same as that of the start of 
the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc. 

Note: There are certain possible ambiguities in interpretation of certain 
singular times, which are resolved in the following ways: 

23:59 is the last minute of the day and 00:00 is the first minute of the next 
day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000. 

Although historically not precise, midnight also belongs to "am", and noon 
belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 
pm (noon) < 12:01 pm 

The date or time format strings are not part of the definition of a calendar, 
as those must be modifiable or overridable by the user at runtime. Use 
(|java.text.DateFormat|) to format dates. 

Field Manipulation 

The calendar fields can be changed using three methods: set(), add(), and 
roll(). 

set(f, value) changes calendar field f to value. In addition, it sets an 
internal member variable to indicate that calendar field f has been changed. 
Although calendar field f is changed immediately, the calendar's time value in 
milliseconds is not recomputed until the next call to get(), getTime(), 
getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do 
not trigger multiple, unnecessary computations. As a result of changing a 
calendar field using set(), other calendar fields may also change, depending on 
the calendar field, the calendar field value, and the calendar system. In 
addition, get(f) will not necessarily return value set by the call to the set 
method after the calendar fields have been recomputed. The specifics are 
determined by the concrete calendar class. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 
1999. This is a temporary internal representation that resolves to October 1, 
1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 
30) before the call to getTime() sets the date to September 30, 1999, since no 
recomputation occurs after set() itself. 

add(f, delta) adds delta to field f. This is equivalent to calling set(f, 
get(f) + delta) with two adjustments: 

Add rule 1. The value of field f after the call minus the value of field f 
before the call is delta, modulo any overflow that has occurred in field f. 
Overflow occurs when a field value exceeds its range and, as a result, the next 
larger field is incremented or decremented and the field value is adjusted back 
into its range. 

Add rule 2. If a smaller field is expected to be invariant, but it is 
impossible for it to be equal to its prior value because of changes in its 
minimum or maximum after field f is changed or other constraints, such as time 
zone offset changes, then its value is adjusted to be as close as possible to 
its expected value. A smaller field represents a smaller unit of time. HOUR is 
a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that 
are not expected to be invariant. The calendar system determines what fields 
are expected to be invariant. 

In addition, unlike set(), add() forces an immediate recomputation of the 
calendar's milliseconds and all fields. 

Example: Consider a GregorianCalendar originally set to August 31, 1999. 
Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add 
rule 1 sets the MONTH field to September, since adding 13 months to August 
gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September 
in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest 
possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by 
rule 2, since it is expected to change when the month changes in a 
GregorianCalendar. 

roll(f, delta) adds delta to field f without changing larger fields. This is 
equivalent to calling add(f, delta) with the following adjustment: 

Roll rule. Larger fields are unchanged after the call. A larger field 
represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR. 

Example: See (|java.util.GregorianCalendar|) . 

Usage model. To motivate the behavior of add() and roll(), consider a user 
interface component with increment and decrement buttons for the month, day, 
and year, and an underlying GregorianCalendar. If the interface reads January 
31, 1999 and the user presses the month increment button, what should it read? 
If the underlying implementation uses set(), it might read March 3, 1999. A 
better result would be February 28, 1999. Furthermore, if the user presses the 
month increment button again, it should read March 31, 1999, not March 28, 
1999. By saving the original date and using either add() or roll(), depending 
on whether larger fields should be affected, the user interface can behave as 
most users will intuitively expect. 



*java.util.Calendar()*

protected Calendar()

Constructs a Calendar with the default time zone and locale. 


*java.util.Calendar(TimeZone,Locale)*

protected Calendar(
  java.util.TimeZone zone,
  java.util.Locale aLocale)

Constructs a calendar with the specified time zone and locale. 

    zone - the time zone to use 
    aLocale - the locale for the week data 

*java.util.Calendar.add(int,int)*

public abstract void add(
  int field,
  int amount)

Adds or subtracts the specified amount of time to the given calendar field, 
based on the calendar's rules. For example, to subtract 5 days from the current 
time of the calendar, you can achieve it by calling: add(Calendar.DAY_OF_MONTH, 
-5). 

    field - the calendar field. 
    amount - the amount of date or time to be added to the field. 

*java.util.Calendar.after(Object)*

public boolean after(java.lang.Object when)

Returns whether this Calendar represents a time after the time represented by 
the specified Object. This method is equivalent to: 

compareTo(when) > 0 

if and only if when is a Calendar instance. Otherwise, the method returns 
false. 

    when - the Object to be compared 

    Returns: true if the time of this Calendar is after the time represented by when; false 
             otherwise. 
*java.util.Calendar.before(Object)*

public boolean before(java.lang.Object when)

Returns whether this Calendar represents a time before the time represented by 
the specified Object. This method is equivalent to: 

compareTo(when) 

if and only if when is a Calendar instance. Otherwise, the method returns 
false. 

    when - the Object to be compared 

    Returns: true if the time of this Calendar is before the time represented by when; false 
             otherwise. 
*java.util.Calendar.clear()*

public final void clear()

Sets all the calendar field values and the time value (millisecond offset from 
the Epoch) of this Calendar undefined. This means that 
isSet()(|java.util.Calendar|) will return false for all the calendar fields, 
and the date and time calculations will treat the fields as if they had never 
been set. A Calendar implementation class may use its specific default field 
values for date/time calculations. For example, GregorianCalendar uses 1970 if 
the YEAR field value is undefined. 


*java.util.Calendar.clear(int)*

public final void clear(int field)

Sets the given calendar field value and the time value (millisecond offset from 
the Epoch) of this Calendar undefined. This means that 
isSet(field)(|java.util.Calendar|) will return false, and the date and time 
calculations will treat the field as if it had never been set. A Calendar 
implementation class may use the field's specific default value for date and 
time calculations. 

The (|java.util.Calendar|) , (|java.util.Calendar|) and (|java.util.Calendar|) 
fields are handled independently and the the resolution rule for the time of 
day is applied. Clearing one of the fields doesn't reset the hour of day value 
of this Calendar. Use set(Calendar.HOUR_OF_DAY, 0)(|java.util.Calendar|) to 
reset the hour value. 

    field - the calendar field to be cleared. 

*java.util.Calendar.clone()*

public |java.lang.Object| clone()

Creates and returns a copy of this object. 


    Returns: a copy of this object. 
*java.util.Calendar.compareTo(Calendar)*

public int compareTo(java.util.Calendar anotherCalendar)

Compares the time values (millisecond offsets from the Epoch) represented by 
two Calendar objects. 

    anotherCalendar - the Calendar to be compared. 

    Returns: the value 0 if the time represented by the argument is equal to the time 
             represented by this Calendar; a value less than 0 if the time of 
             this Calendar is before the time represented by the argument; and 
             a value greater than 0 if the time of this Calendar is after the 
             time represented by the argument. 
*java.util.Calendar.complete()*

protected void complete()

Fills in any unset fields in the calendar fields. First, the 
(|java.util.Calendar|) method is called if the time value (millisecond offset 
from the Epoch) has not been calculated from calendar field values. Then, the 
(|java.util.Calendar|) method is called to calculate all calendar field values. 


*java.util.Calendar.computeFields()*

protected abstract void computeFields()

Converts the current millisecond time value (|java.util.Calendar|) to calendar 
field values in fields[](|java.util.Calendar|) . This allows you to sync up the 
calendar field values with a new time that is set for the calendar. The time is 
not recomputed first; to recompute the time, then the fields, call the 
(|java.util.Calendar|) method. 


*java.util.Calendar.computeTime()*

protected abstract void computeTime()

Converts the current calendar field values in fields[](|java.util.Calendar|) to 
the millisecond time value (|java.util.Calendar|) . 


*java.util.Calendar.equals(Object)*

public boolean equals(java.lang.Object obj)

Compares this Calendar to the specified Object. The result is true if and only 
if the argument is a Calendar object of the same calendar system that 
represents the same time value (millisecond offset from the Epoch) under the 
same Calendar parameters as this object. 

The Calendar parameters are the values represented by the isLenient, 
getFirstDayOfWeek, getMinimalDaysInFirstWeek and getTimeZone methods. If there 
is any difference in those parameters between the two Calendars, this method 
returns false. 

Use the compareTo(|java.util.Calendar|) method to compare only the time values. 

    obj - the object to compare with. 

    Returns: true if this object is equal to obj; false otherwise. 
*java.util.Calendar.get(int)*

public int get(int field)

Returns the value of the given calendar field. In lenient mode, all calendar 
fields are normalized. In non-lenient mode, all calendar fields are validated 
and this method throws an exception if any calendar fields have out-of-range 
values. The normalization and validation are handled by the 
(|java.util.Calendar|) method, which process is calendar system dependent. 

    field - the given calendar field. 

    Returns: the value for the given calendar field. 
*java.util.Calendar.getActualMaximum(int)*

public int getActualMaximum(int field)

Returns the maximum value that the specified calendar field could have, given 
the time value of this Calendar. For example, the actual maximum value of the 
MONTH field is 12 in some years, and 13 in other years in the Hebrew calendar 
system. 

The default implementation of this method uses an iterative algorithm to 
determine the actual maximum value for the calendar field. Subclasses should, 
if possible, override this with a more efficient implementation. 

    field - the calendar field 

    Returns: the maximum of the given calendar field for the time value of this Calendar 
*java.util.Calendar.getActualMinimum(int)*

public int getActualMinimum(int field)

Returns the minimum value that the specified calendar field could have, given 
the time value of this Calendar. 

The default implementation of this method uses an iterative algorithm to 
determine the actual minimum value for the calendar field. Subclasses should, 
if possible, override this with a more efficient implementation - in many 
cases, they can simply return getMinimum(). 

    field - the calendar field 

    Returns: the minimum of the given calendar field for the time value of this Calendar 
*java.util.Calendar.getAvailableLocales()*

public static synchronized |java.util.Locale| getAvailableLocales()

Returns an array of all locales for which the getInstance methods of this class 
can return localized instances. The array returned must contain at least a 
Locale instance equal to Locale.US(|java.util.Locale|) . 


    Returns: An array of locales for which localized Calendar instances are available. 
*java.util.Calendar.getFirstDayOfWeek()*

public int getFirstDayOfWeek()

Gets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in 
France. 


    Returns: the first day of the week. 
*java.util.Calendar.getGreatestMinimum(int)*

public abstract int getGreatestMinimum(int field)

Returns the highest minimum value for the given calendar field of this Calendar 
instance. The highest minimum value is defined as the largest value returned by 
(|java.util.Calendar|) for any possible time value. The greatest minimum value 
depends on calendar system specific parameters of the instance. 

    field - the calendar field. 

    Returns: the highest minimum value for the given calendar field. 
*java.util.Calendar.getInstance()*

public static |java.util.Calendar| getInstance()

Gets a calendar using the default time zone and locale. The Calendar returned 
is based on the current time in the default time zone with the default locale. 


    Returns: 
*java.util.Calendar.getInstance(Locale)*

public static |java.util.Calendar| getInstance(java.util.Locale aLocale)

Gets a calendar using the default time zone and specified locale. The Calendar 
returned is based on the current time in the default time zone with the given 
locale. 

    aLocale - the locale for the week data 

    Returns: 
*java.util.Calendar.getInstance(TimeZone)*

public static |java.util.Calendar| getInstance(java.util.TimeZone zone)

Gets a calendar using the specified time zone and default locale. The Calendar 
returned is based on the current time in the given time zone with the default 
locale. 

    zone - the time zone to use 

    Returns: 
*java.util.Calendar.getInstance(TimeZone,Locale)*

public static |java.util.Calendar| getInstance(
  java.util.TimeZone zone,
  java.util.Locale aLocale)

Gets a calendar with the specified time zone and locale. The Calendar returned 
is based on the current time in the given time zone with the given locale. 

    zone - the time zone to use 
    aLocale - the locale for the week data 

    Returns: 
*java.util.Calendar.getLeastMaximum(int)*

public abstract int getLeastMaximum(int field)

Returns the lowest maximum value for the given calendar field of this Calendar 
instance. The lowest maximum value is defined as the smallest value returned by 
(|java.util.Calendar|) for any possible time value. The least maximum value 
depends on calendar system specific parameters of the instance. For example, a 
Calendar for the Gregorian calendar system returns 28 for the DAY_OF_MONTH 
field, because the 28th is the last day of the shortest month of this calendar, 
February in a common year. 

    field - the calendar field. 

    Returns: the lowest maximum value for the given calendar field. 
*java.util.Calendar.getMaximum(int)*

public abstract int getMaximum(int field)

Returns the maximum value for the given calendar field of this Calendar 
instance. The maximum value is defined as the largest value returned by the 
get(|java.util.Calendar|) method for any possible time value. The maximum value 
depends on calendar system specific parameters of the instance. 

    field - the calendar field. 

    Returns: the maximum value for the given calendar field. 
*java.util.Calendar.getMinimalDaysInFirstWeek()*

public int getMinimalDaysInFirstWeek()

Gets what the minimal days required in the first week of the year are; e.g., if 
the first week is defined as one that contains the first day of the first month 
of a year, this method returns 1. If the minimal days required must be a full 
week, this method returns 7. 


    Returns: the minimal days required in the first week of the year. 
*java.util.Calendar.getMinimum(int)*

public abstract int getMinimum(int field)

Returns the minimum value for the given calendar field of this Calendar 
instance. The minimum value is defined as the smallest value returned by the 
get(|java.util.Calendar|) method for any possible time value. The minimum value 
depends on calendar system specific parameters of the instance. 

    field - the calendar field. 

    Returns: the minimum value for the given calendar field. 
*java.util.Calendar.getTime()*

public final |java.util.Date| getTime()

Returns a Date object representing this Calendar's time value (millisecond 
offset from the Epoch"). 


    Returns: a Date representing the time value. 
*java.util.Calendar.getTimeInMillis()*

public long getTimeInMillis()

Returns this Calendar's time value in milliseconds. 


    Returns: the current time as UTC milliseconds from the epoch. 
*java.util.Calendar.getTimeZone()*

public |java.util.TimeZone| getTimeZone()

Gets the time zone. 


    Returns: the time zone object associated with this calendar. 
*java.util.Calendar.hashCode()*

public int hashCode()

Returns a hash code for this calendar. 


    Returns: a hash code value for this object. 
*java.util.Calendar.internalGet(int)*

protected final int internalGet(int field)

Returns the value of the given calendar field. This method does not involve 
normalization or validation of the field value. 

    field - the given calendar field. 

    Returns: the value for the given calendar field. 
*java.util.Calendar.isLenient()*

public boolean isLenient()

Tells whether date/time interpretation is to be lenient. 


    Returns: true if the interpretation mode of this calendar is lenient; false otherwise. 
*java.util.Calendar.isSet(int)*

public final boolean isSet(int field)

Determines if the given calendar field has a value set, including cases that 
the value has been set by internal fields calculations triggered by a get 
method call. 


    Returns: true if the given calendar field has a value set; false otherwise. 
*java.util.Calendar.roll(int,boolean)*

public abstract void roll(
  int field,
  boolean up)

Adds or subtracts (up/down) a single unit of time on the given time field 
without changing larger fields. For example, to roll the current date up by one 
day, you can achieve it by calling: roll(Calendar.DATE, true). When rolling on 
the year or Calendar.YEAR field, it will roll the year value in the range 
between 1 and the value returned by calling getMaximum(Calendar.YEAR). When 
rolling on the month or Calendar.MONTH field, other fields like date might 
conflict and, need to be changed. For instance, rolling the month on the date 
01/31/96 will result in 02/29/96. When rolling on the hour-in-day or 
Calendar.HOUR_OF_DAY field, it will roll the hour value in the range between 0 
and 23, which is zero-based. 

    field - the time field. 
    up - indicates if the value of the specified time field is to be rolled up or rolled 
       down. Use true if rolling up, false otherwise. 

*java.util.Calendar.roll(int,int)*

public void roll(
  int field,
  int amount)

Adds the specified (signed) amount to the specified calendar field without 
changing larger fields. A negative amount means to roll down. 

NOTE: This default implementation on Calendar just repeatedly calls the version 
of roll()(|java.util.Calendar|) that rolls by one unit. This may not always do 
the right thing. For example, if the DAY_OF_MONTH field is 31, rolling through 
February will leave it set to 28. The GregorianCalendar version of this 
function takes care of this problem. Other subclasses should also provide 
overrides of this function that do the right thing. 

    field - the calendar field. 
    amount - the signed amount to add to the calendar field. 

*java.util.Calendar.set(int,int)*

public void set(
  int field,
  int value)

Sets the given calendar field to the given value. The value is not interpreted 
by this method regardless of the leniency mode. 

    field - the given calendar field. 
    value - the value to be set for the given calendar field. 

*java.util.Calendar.set(int,int,int)*

public final void set(
  int year,
  int month,
  int date)

Sets the values for the calendar fields YEAR, MONTH, and DAY_OF_MONTH. Previous 
values of other calendar fields are retained. If this is not desired, call 
(|java.util.Calendar|) first. 

    year - the value used to set the YEAR calendar field. 
    month - the value used to set the MONTH calendar field. Month value is 0-based. e.g., 0 
       for January. 
    date - the value used to set the DAY_OF_MONTH calendar field. 

*java.util.Calendar.set(int,int,int,int,int)*

public final void set(
  int year,
  int month,
  int date,
  int hourOfDay,
  int minute)

Sets the values for the calendar fields YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY, 
and MINUTE. Previous values of other fields are retained. If this is not 
desired, call (|java.util.Calendar|) first. 

    year - the value used to set the YEAR calendar field. 
    month - the value used to set the MONTH calendar field. Month value is 0-based. e.g., 0 
       for January. 
    date - the value used to set the DAY_OF_MONTH calendar field. 
    hourOfDay - the value used to set the HOUR_OF_DAY calendar field. 
    minute - the value used to set the MINUTE calendar field. 

*java.util.Calendar.set(int,int,int,int,int,int)*

public final void set(
  int year,
  int month,
  int date,
  int hourOfDay,
  int minute,
  int second)

Sets the values for the fields YEAR, MONTH, DAY_OF_MONTH, HOUR, MINUTE, and 
SECOND. Previous values of other fields are retained. If this is not desired, 
call (|java.util.Calendar|) first. 

    year - the value used to set the YEAR calendar field. 
    month - the value used to set the MONTH calendar field. Month value is 0-based. e.g., 0 
       for January. 
    date - the value used to set the DAY_OF_MONTH calendar field. 
    hourOfDay - the value used to set the HOUR_OF_DAY calendar field. 
    minute - the value used to set the MINUTE calendar field. 
    second - the value used to set the SECOND calendar field. 

*java.util.Calendar.setFirstDayOfWeek(int)*

public void setFirstDayOfWeek(int value)

Sets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in 
France. 

    value - the given first day of the week. 

*java.util.Calendar.setLenient(boolean)*

public void setLenient(boolean lenient)

Specifies whether or not date/time interpretation is to be lenient. With 
lenient interpretation, a date such as "February 942, 1996" will be treated as 
being equivalent to the 941st day after February 1, 1996. With strict 
(non-lenient) interpretation, such dates will cause an exception to be thrown. 
The default is lenient. 

    lenient - true if the lenient mode is to be turned on; false if it is to be turned off. 

*java.util.Calendar.setMinimalDaysInFirstWeek(int)*

public void setMinimalDaysInFirstWeek(int value)

Sets what the minimal days required in the first week of the year are; For 
example, if the first week is defined as one that contains the first day of the 
first month of a year, call this method with value 1. If it must be a full 
week, use value 7. 

    value - the given minimal days required in the first week of the year. 

*java.util.Calendar.setTime(Date)*

public final void setTime(java.util.Date date)

Sets this Calendar's time with the given Date. 

Note: Calling setTime() with Date(Long.MAX_VALUE) or Date(Long.MIN_VALUE) may 
yield incorrect field values from get(). 

    date - the given Date. 

*java.util.Calendar.setTimeInMillis(long)*

public void setTimeInMillis(long millis)

Sets this Calendar's current time from the given long value. 

    millis - the new time in UTC milliseconds from the epoch. 

*java.util.Calendar.setTimeZone(TimeZone)*

public void setTimeZone(java.util.TimeZone value)

Sets the time zone with the given time zone value. 

    value - the given time zone. 

*java.util.Calendar.toString()*

public |java.lang.String| toString()

Return a string representation of this calendar. This method is intended to be 
used only for debugging purposes, and the format of the returned string may 
vary between implementations. The returned string may be empty but may not be 
null. 


    Returns: a string representation of this calendar. 

