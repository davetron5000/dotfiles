*javax.swing.text.JTextComponent* *JTextComponent* JTextComponent is the base cl

public abstract class JTextComponent
  extends    |javax.swing.JComponent|
  implements |javax.swing.Scrollable|
             |javax.accessibility.Accessible|

|javax.swing.text.JTextComponent_Description|
|javax.swing.text.JTextComponent_Fields|
|javax.swing.text.JTextComponent_Constructors|
|javax.swing.text.JTextComponent_Methods|

================================================================================

*javax.swing.text.JTextComponent_Fields*
|java.lang.String_javax.swing.text.JTextComponent.DEFAULT_KEYMAP|
|java.lang.String_javax.swing.text.JTextComponent.FOCUS_ACCELERATOR_KEY|

*javax.swing.text.JTextComponent_Constructors*
|javax.swing.text.JTextComponent()|Creates a new JTextComponent.

*javax.swing.text.JTextComponent_Methods*
|javax.swing.text.JTextComponent.addCaretListener(CaretListener)|Adds a caret l
|javax.swing.text.JTextComponent.addInputMethodListener(InputMethodListener)|
|javax.swing.text.JTextComponent.addKeymap(String,Keymap)|Adds a new keymap int
|javax.swing.text.JTextComponent.copy()|Transfers the currently selected range 
|javax.swing.text.JTextComponent.cut()|Transfers the currently selected range i
|javax.swing.text.JTextComponent.fireCaretUpdate(CaretEvent)|Notifies all liste
|javax.swing.text.JTextComponent.getAccessibleContext()|Gets the AccessibleCont
|javax.swing.text.JTextComponent.getActions()|Fetches the command list for the 
|javax.swing.text.JTextComponent.getCaret()|Fetches the caret that allows text-
|javax.swing.text.JTextComponent.getCaretColor()|Fetches the current color used
|javax.swing.text.JTextComponent.getCaretListeners()|Returns an array of all th
|javax.swing.text.JTextComponent.getCaretPosition()|Returns the position of the
|javax.swing.text.JTextComponent.getDisabledTextColor()|Fetches the current col
|javax.swing.text.JTextComponent.getDocument()|Fetches the model associated wit
|javax.swing.text.JTextComponent.getDragEnabled()|Gets the dragEnabled property
|javax.swing.text.JTextComponent.getFocusAccelerator()|Returns the key accelera
|javax.swing.text.JTextComponent.getHighlighter()|Fetches the object responsibl
|javax.swing.text.JTextComponent.getInputMethodRequests()|
|javax.swing.text.JTextComponent.getKeymap()|Fetches the keymap currently activ
|javax.swing.text.JTextComponent.getKeymap(String)|Fetches a named keymap previ
|javax.swing.text.JTextComponent.getMargin()|Returns the margin between the tex
|javax.swing.text.JTextComponent.getNavigationFilter()|Returns the NavigationFi
|javax.swing.text.JTextComponent.getPreferredScrollableViewportSize()|Returns t
|javax.swing.text.JTextComponent.getScrollableBlockIncrement(Rectangle,int,int)|
|javax.swing.text.JTextComponent.getScrollableTracksViewportHeight()|Returns tr
|javax.swing.text.JTextComponent.getScrollableTracksViewportWidth()|Returns tru
|javax.swing.text.JTextComponent.getScrollableUnitIncrement(Rectangle,int,int)|
|javax.swing.text.JTextComponent.getSelectedText()|Returns the selected text co
|javax.swing.text.JTextComponent.getSelectedTextColor()|Fetches the current col
|javax.swing.text.JTextComponent.getSelectionColor()|Fetches the current color 
|javax.swing.text.JTextComponent.getSelectionEnd()|Returns the selected text's 
|javax.swing.text.JTextComponent.getSelectionStart()|Returns the selected text'
|javax.swing.text.JTextComponent.getText()|Returns the text contained in this T
|javax.swing.text.JTextComponent.getText(int,int)|Fetches a portion of the text
|javax.swing.text.JTextComponent.getToolTipText(MouseEvent)|Returns the string 
|javax.swing.text.JTextComponent.getUI()|Fetches the user-interface factory for
|javax.swing.text.JTextComponent.isEditable()|Returns the boolean indicating wh
|javax.swing.text.JTextComponent.loadKeymap(Keymap,JTextComponent.KeyBinding[],Action[])|
|javax.swing.text.JTextComponent.modelToView(int)|Converts the given location i
|javax.swing.text.JTextComponent.moveCaretPosition(int)|Moves the caret to a ne
|javax.swing.text.JTextComponent.paramString()|Returns a string representation 
|javax.swing.text.JTextComponent.paste()|Transfers the contents of the system c
|javax.swing.text.JTextComponent.processInputMethodEvent(InputMethodEvent)|
|javax.swing.text.JTextComponent.read(Reader,Object)|Initializes from a stream.
|javax.swing.text.JTextComponent.removeCaretListener(CaretListener)|Removes a c
|javax.swing.text.JTextComponent.removeKeymap(String)|Removes a named keymap pr
|javax.swing.text.JTextComponent.removeNotify()|
|javax.swing.text.JTextComponent.replaceSelection(String)|Replaces the currentl
|javax.swing.text.JTextComponent.select(int,int)|Selects the text between the s
|javax.swing.text.JTextComponent.selectAll()|Selects all the text in the TextCo
|javax.swing.text.JTextComponent.setCaret(Caret)|Sets the caret to be used.
|javax.swing.text.JTextComponent.setCaretColor(Color)|Sets the current color us
|javax.swing.text.JTextComponent.setCaretPosition(int)|Sets the position of the
|javax.swing.text.JTextComponent.setComponentOrientation(ComponentOrientation)|
|javax.swing.text.JTextComponent.setDisabledTextColor(Color)|Sets the current c
|javax.swing.text.JTextComponent.setDocument(Document)|Associates the editor wi
|javax.swing.text.JTextComponent.setDragEnabled(boolean)|Sets the dragEnabled p
|javax.swing.text.JTextComponent.setEditable(boolean)|Sets the specified boolea
|javax.swing.text.JTextComponent.setFocusAccelerator(char)|Sets the key acceler
|javax.swing.text.JTextComponent.setHighlighter(Highlighter)|Sets the highlight
|javax.swing.text.JTextComponent.setKeymap(Keymap)|Sets the keymap to use for b
|javax.swing.text.JTextComponent.setMargin(Insets)|Sets margin space between th
|javax.swing.text.JTextComponent.setNavigationFilter(NavigationFilter)|Sets the
|javax.swing.text.JTextComponent.setSelectedTextColor(Color)|Sets the current c
|javax.swing.text.JTextComponent.setSelectionColor(Color)|Sets the current colo
|javax.swing.text.JTextComponent.setSelectionEnd(int)|Sets the selection end to
|javax.swing.text.JTextComponent.setSelectionStart(int)|Sets the selection star
|javax.swing.text.JTextComponent.setText(String)|Sets the text of this TextComp
|javax.swing.text.JTextComponent.setUI(TextUI)|Sets the user-interface factory 
|javax.swing.text.JTextComponent.updateUI()|Reloads the pluggable UI.
|javax.swing.text.JTextComponent.viewToModel(Point)|Converts the given place in
|javax.swing.text.JTextComponent.write(Writer)|Stores the contents of the model

*javax.swing.text.JTextComponent_Description*

JTextComponent is the base class for swing text components. It tries to be 
compatible with the java.awt.TextComponent class where it can reasonably do so. 
Also provided are other services for additional flexibility (beyond the 
pluggable UI and bean support). You can find information on how to use the 
functionality this class provides in General Rules for Using Text Components, a 
section in The Java Tutorial. 



Caret Changes 

The caret is a pluggable object in swing text components. Notification of 
changes to the caret position and the selection are sent to implementations of 
the CaretListener interface that have been registered with the text component. 
The UI will install a default caret unless a customized caret has been set. By 
default the caret tracks all the document changes performed on the Event 
Dispatching Thread and updates it's position accordingly if an insertion occurs 
before or at the caret position or a removal occurs before the caret position. 
DefaultCaret tries to make itself visible which may lead to scrolling of a text 
component within JScrollPane. The default caret behavior can be changed by the 
(|javax.swing.text.DefaultCaret|) method. 

Note: Non-editable text components also have a caret though it may not be 
painted. 

Commands 

Text components provide a number of commands that can be used to manipulate the 
component. This is essentially the way that the component expresses its 
capabilities. These are expressed in terms of the swing Action interface, using 
the TextAction implementation. The set of commands supported by the text 
component can be found with the (|javax.swing.text.JTextComponent|) method. 
These actions can be bound to key events, fired from buttons, etc. 

Text Input 

The text components support flexible and internationalized text input, using 
keymaps and the input method framework, while maintaining compatibility with 
the AWT listener model. 

A (|javax.swing.text.Keymap|) lets an application bind key strokes to actions. 
In order to allow keymaps to be shared across multiple text components, they 
can use actions that extend TextAction. TextAction can determine which 
JTextComponent most recently has or had focus and therefore is the subject of 
the action (In the case that the ActionEvent sent to the action doesn't contain 
the target text component as its source). 

The input method framework lets text components interact with input methods, 
separate software components that preprocess events to let users enter 
thousands of different characters using keyboards with far fewer keys. 
JTextComponent is an active client of the framework, so it implements the 
preferred user interface for interacting with input methods. As a consequence, 
some key events do not reach the text component because they are handled by an 
input method, and some text input reaches the text component as committed text 
within an (|java.awt.event.InputMethodEvent|) instead of as a key event. The 
complete text input is the combination of the characters in keyTyped key events 
and committed text in input method events. 

The AWT listener model lets applications attach event listeners to components 
in order to bind events to actions. Swing encourages the use of keymaps instead 
of listeners, but maintains compatibility with listeners by giving the 
listeners a chance to steal an event by consuming it. 

Keyboard event and input method events are handled in the following stages, 
with each stage capable of consuming the event: 



Stage KeyEvent InputMethodEvent 1. input methods (generated here) 2. focus 
manager 



3. registered key listeners registered input method listeners 

4. 

input method handling in JTextComponent 

5. keymap handling using the current keymap 6. keyboard handling in JComponent 
(e.g. accelerators, component navigation, etc.) 



To maintain compatibility with applications that listen to key events but are 
not aware of input method events, the input method handling in stage 4 provides 
a compatibility mode for components that do not process input method events. 
For these components, the committed text is converted to keyTyped key events 
and processed in the key event pipeline starting at stage 3 instead of in the 
input method event pipeline. 

By default the component will create a keymap (named DEFAULT_KEYMAP) that is 
shared by all JTextComponent instances as the default keymap. Typically a 
look-and-feel implementation will install a different keymap that resolves to 
the default keymap for those bindings not found in the different keymap. The 
minimal bindings include: 

inserting content into the editor for the printable keys. removing content with 
the backspace and del keys. caret movement forward and backward 

Model/View Split 

The text components have a model-view split. A text component pulls together 
the objects used to represent the model, view, and controller. The text 
document model may be shared by other views which act as observers of the model 
(e.g. a document may be shared by multiple components). 



The model is defined by the (|javax.swing.text.Document|) interface. This is 
intended to provide a flexible text storage mechanism that tracks change during 
edits and can be extended to more sophisticated models. The model interfaces 
are meant to capture the capabilities of expression given by SGML, a system 
used to express a wide variety of content. Each modification to the document 
causes notification of the details of the change to be sent to all observers in 
the form of a (|javax.swing.event.DocumentEvent|) which allows the views to 
stay up to date with the model. This event is sent to observers that have 
implemented the (|javax.swing.event.DocumentListener|) interface and registered 
interest with the model being observed. 

Location Information 

The capability of determining the location of text in the view is provided. 
There are two methods, (|javax.swing.text.JTextComponent|) and 
(|javax.swing.text.JTextComponent|) for determining this information. 

Undo/Redo support 

Support for an edit history mechanism is provided to allow undo/redo 
operations. The text component does not itself provide the history buffer by 
default, but does provide the UndoableEdit records that can be used in 
conjunction with a history buffer to provide the undo/redo support. The support 
is provided by the Document model, which allows one to attach 
UndoableEditListener implementations. 

Thread Safety 

The swing text components provide some support of thread safe operations. 
Because of the high level of configurability of the text components, it is 
possible to circumvent the protection provided. The protection primarily comes 
from the model, so the documentation of AbstractDocument describes the 
assumptions of the protection provided. The methods that are safe to call 
asynchronously are marked with comments. 

Newlines 

For a discussion on how newlines are handled, see DefaultEditorKit. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*java.lang.String_javax.swing.text.JTextComponent.DEFAULT_KEYMAP*

JTextComponent is the base class for swing text components. It tries to be 
compatible with the java.awt.TextComponent class where it can reasonably do so. 
Also provided are other services for additional flexibility (beyond the 
pluggable UI and bean support). You can find information on how to use the 
functionality this class provides in General Rules for Using Text Components, a 
section in The Java Tutorial. 



Caret Changes 

The caret is a pluggable object in swing text components. Notification of 
changes to the caret position and the selection are sent to implementations of 
the CaretListener interface that have been registered with the text component. 
The UI will install a default caret unless a customized caret has been set. By 
default the caret tracks all the document changes performed on the Event 
Dispatching Thread and updates it's position accordingly if an insertion occurs 
before or at the caret position or a removal occurs before the caret position. 
DefaultCaret tries to make itself visible which may lead to scrolling of a text 
component within JScrollPane. The default caret behavior can be changed by the 
(|javax.swing.text.DefaultCaret|) method. 

Note: Non-editable text components also have a caret though it may not be 
painted. 

Commands 

Text components provide a number of commands that can be used to manipulate the 
component. This is essentially the way that the component expresses its 
capabilities. These are expressed in terms of the swing Action interface, using 
the TextAction implementation. The set of commands supported by the text 
component can be found with the (|javax.swing.text.JTextComponent|) method. 
These actions can be bound to key events, fired from buttons, etc. 

Text Input 

The text components support flexible and internationalized text input, using 
keymaps and the input method framework, while maintaining compatibility with 
the AWT listener model. 

A (|javax.swing.text.Keymap|) lets an application bind key strokes to actions. 
In order to allow keymaps to be shared across multiple text components, they 
can use actions that extend TextAction. TextAction can determine which 
JTextComponent most recently has or had focus and therefore is the subject of 
the action (In the case that the ActionEvent sent to the action doesn't contain 
the target text component as its source). 

The input method framework lets text components interact with input methods, 
separate software components that preprocess events to let users enter 
thousands of different characters using keyboards with far fewer keys. 
JTextComponent is an active client of the framework, so it implements the 
preferred user interface for interacting with input methods. As a consequence, 
some key events do not reach the text component because they are handled by an 
input method, and some text input reaches the text component as committed text 
within an (|java.awt.event.InputMethodEvent|) instead of as a key event. The 
complete text input is the combination of the characters in keyTyped key events 
and committed text in input method events. 

The AWT listener model lets applications attach event listeners to components 
in order to bind events to actions. Swing encourages the use of keymaps instead 
of listeners, but maintains compatibility with listeners by giving the 
listeners a chance to steal an event by consuming it. 

Keyboard event and input method events are handled in the following stages, 
with each stage capable of consuming the event: 



Stage KeyEvent InputMethodEvent 1. input methods (generated here) 2. focus 
manager 



3. registered key listeners registered input method listeners 

4. 

input method handling in JTextComponent 

5. keymap handling using the current keymap 6. keyboard handling in JComponent 
(e.g. accelerators, component navigation, etc.) 



To maintain compatibility with applications that listen to key events but are 
not aware of input method events, the input method handling in stage 4 provides 
a compatibility mode for components that do not process input method events. 
For these components, the committed text is converted to keyTyped key events 
and processed in the key event pipeline starting at stage 3 instead of in the 
input method event pipeline. 

By default the component will create a keymap (named DEFAULT_KEYMAP) that is 
shared by all JTextComponent instances as the default keymap. Typically a 
look-and-feel implementation will install a different keymap that resolves to 
the default keymap for those bindings not found in the different keymap. The 
minimal bindings include: 

inserting content into the editor for the printable keys. removing content with 
the backspace and del keys. caret movement forward and backward 

Model/View Split 

The text components have a model-view split. A text component pulls together 
the objects used to represent the model, view, and controller. The text 
document model may be shared by other views which act as observers of the model 
(e.g. a document may be shared by multiple components). 



The model is defined by the (|javax.swing.text.Document|) interface. This is 
intended to provide a flexible text storage mechanism that tracks change during 
edits and can be extended to more sophisticated models. The model interfaces 
are meant to capture the capabilities of expression given by SGML, a system 
used to express a wide variety of content. Each modification to the document 
causes notification of the details of the change to be sent to all observers in 
the form of a (|javax.swing.event.DocumentEvent|) which allows the views to 
stay up to date with the model. This event is sent to observers that have 
implemented the (|javax.swing.event.DocumentListener|) interface and registered 
interest with the model being observed. 

Location Information 

The capability of determining the location of text in the view is provided. 
There are two methods, (|javax.swing.text.JTextComponent|) and 
(|javax.swing.text.JTextComponent|) for determining this information. 

Undo/Redo support 

Support for an edit history mechanism is provided to allow undo/redo 
operations. The text component does not itself provide the history buffer by 
default, but does provide the UndoableEdit records that can be used in 
conjunction with a history buffer to provide the undo/redo support. The support 
is provided by the Document model, which allows one to attach 
UndoableEditListener implementations. 

Thread Safety 

The swing text components provide some support of thread safe operations. 
Because of the high level of configurability of the text components, it is 
possible to circumvent the protection provided. The protection primarily comes 
from the model, so the documentation of AbstractDocument describes the 
assumptions of the protection provided. The methods that are safe to call 
asynchronously are marked with comments. 

Newlines 

For a discussion on how newlines are handled, see DefaultEditorKit. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 


*java.lang.String_javax.swing.text.JTextComponent.FOCUS_ACCELERATOR_KEY*

JTextComponent is the base class for swing text components. It tries to be 
compatible with the java.awt.TextComponent class where it can reasonably do so. 
Also provided are other services for additional flexibility (beyond the 
pluggable UI and bean support). You can find information on how to use the 
functionality this class provides in General Rules for Using Text Components, a 
section in The Java Tutorial. 



Caret Changes 

The caret is a pluggable object in swing text components. Notification of 
changes to the caret position and the selection are sent to implementations of 
the CaretListener interface that have been registered with the text component. 
The UI will install a default caret unless a customized caret has been set. By 
default the caret tracks all the document changes performed on the Event 
Dispatching Thread and updates it's position accordingly if an insertion occurs 
before or at the caret position or a removal occurs before the caret position. 
DefaultCaret tries to make itself visible which may lead to scrolling of a text 
component within JScrollPane. The default caret behavior can be changed by the 
(|javax.swing.text.DefaultCaret|) method. 

Note: Non-editable text components also have a caret though it may not be 
painted. 

Commands 

Text components provide a number of commands that can be used to manipulate the 
component. This is essentially the way that the component expresses its 
capabilities. These are expressed in terms of the swing Action interface, using 
the TextAction implementation. The set of commands supported by the text 
component can be found with the (|javax.swing.text.JTextComponent|) method. 
These actions can be bound to key events, fired from buttons, etc. 

Text Input 

The text components support flexible and internationalized text input, using 
keymaps and the input method framework, while maintaining compatibility with 
the AWT listener model. 

A (|javax.swing.text.Keymap|) lets an application bind key strokes to actions. 
In order to allow keymaps to be shared across multiple text components, they 
can use actions that extend TextAction. TextAction can determine which 
JTextComponent most recently has or had focus and therefore is the subject of 
the action (In the case that the ActionEvent sent to the action doesn't contain 
the target text component as its source). 

The input method framework lets text components interact with input methods, 
separate software components that preprocess events to let users enter 
thousands of different characters using keyboards with far fewer keys. 
JTextComponent is an active client of the framework, so it implements the 
preferred user interface for interacting with input methods. As a consequence, 
some key events do not reach the text component because they are handled by an 
input method, and some text input reaches the text component as committed text 
within an (|java.awt.event.InputMethodEvent|) instead of as a key event. The 
complete text input is the combination of the characters in keyTyped key events 
and committed text in input method events. 

The AWT listener model lets applications attach event listeners to components 
in order to bind events to actions. Swing encourages the use of keymaps instead 
of listeners, but maintains compatibility with listeners by giving the 
listeners a chance to steal an event by consuming it. 

Keyboard event and input method events are handled in the following stages, 
with each stage capable of consuming the event: 



Stage KeyEvent InputMethodEvent 1. input methods (generated here) 2. focus 
manager 



3. registered key listeners registered input method listeners 

4. 

input method handling in JTextComponent 

5. keymap handling using the current keymap 6. keyboard handling in JComponent 
(e.g. accelerators, component navigation, etc.) 



To maintain compatibility with applications that listen to key events but are 
not aware of input method events, the input method handling in stage 4 provides 
a compatibility mode for components that do not process input method events. 
For these components, the committed text is converted to keyTyped key events 
and processed in the key event pipeline starting at stage 3 instead of in the 
input method event pipeline. 

By default the component will create a keymap (named DEFAULT_KEYMAP) that is 
shared by all JTextComponent instances as the default keymap. Typically a 
look-and-feel implementation will install a different keymap that resolves to 
the default keymap for those bindings not found in the different keymap. The 
minimal bindings include: 

inserting content into the editor for the printable keys. removing content with 
the backspace and del keys. caret movement forward and backward 

Model/View Split 

The text components have a model-view split. A text component pulls together 
the objects used to represent the model, view, and controller. The text 
document model may be shared by other views which act as observers of the model 
(e.g. a document may be shared by multiple components). 



The model is defined by the (|javax.swing.text.Document|) interface. This is 
intended to provide a flexible text storage mechanism that tracks change during 
edits and can be extended to more sophisticated models. The model interfaces 
are meant to capture the capabilities of expression given by SGML, a system 
used to express a wide variety of content. Each modification to the document 
causes notification of the details of the change to be sent to all observers in 
the form of a (|javax.swing.event.DocumentEvent|) which allows the views to 
stay up to date with the model. This event is sent to observers that have 
implemented the (|javax.swing.event.DocumentListener|) interface and registered 
interest with the model being observed. 

Location Information 

The capability of determining the location of text in the view is provided. 
There are two methods, (|javax.swing.text.JTextComponent|) and 
(|javax.swing.text.JTextComponent|) for determining this information. 

Undo/Redo support 

Support for an edit history mechanism is provided to allow undo/redo 
operations. The text component does not itself provide the history buffer by 
default, but does provide the UndoableEdit records that can be used in 
conjunction with a history buffer to provide the undo/redo support. The support 
is provided by the Document model, which allows one to attach 
UndoableEditListener implementations. 

Thread Safety 

The swing text components provide some support of thread safe operations. 
Because of the high level of configurability of the text components, it is 
possible to circumvent the protection provided. The protection primarily comes 
from the model, so the documentation of AbstractDocument describes the 
assumptions of the protection provided. The methods that are safe to call 
asynchronously are marked with comments. 

Newlines 

For a discussion on how newlines are handled, see DefaultEditorKit. 

Warning: Serialized objects of this class will not be compatible with future 
Swing releases. The current serialization support is appropriate for short term 
storage or RMI between applications running the same version of Swing. As of 
1.4, support for long term storage of all JavaBeansTM has been added to the 
java.beans package. Please see (|java.beans.XMLEncoder|) . 



*javax.swing.text.JTextComponent()*

public JTextComponent()

Creates a new JTextComponent. Listeners for caret events are established, and 
the pluggable UI installed. The component is marked as editable. No layout 
manager is used, because layout is managed by the view subsystem of text. The 
document model is set to null. 


*javax.swing.text.JTextComponent.addCaretListener(CaretListener)*

public void addCaretListener(javax.swing.event.CaretListener listener)

Adds a caret listener for notification of any changes to the caret. 

    listener - the listener to be added 

*javax.swing.text.JTextComponent.addInputMethodListener(InputMethodListener)*

public void addInputMethodListener(java.awt.event.InputMethodListener l)




*javax.swing.text.JTextComponent.addKeymap(String,Keymap)*

public static |javax.swing.text.Keymap| addKeymap(
  java.lang.String nm,
  javax.swing.text.Keymap parent)

Adds a new keymap into the keymap hierarchy. Keymap bindings resolve from 
bottom up so an attribute specified in a child will override an attribute 
specified in the parent. 

    nm - the name of the keymap (must be unique within the collection of named keymaps 
       in the document); the name may be null if the keymap is unnamed, but the 
       caller is responsible for managing the reference returned as an unnamed 
       keymap can't be fetched by name 
    parent - the parent keymap; this may be null if unspecified bindings need not be 
       resolved in some other keymap 

    Returns: 
*javax.swing.text.JTextComponent.copy()*

public void copy()

Transfers the currently selected range in the associated text model to the 
system clipboard, leaving the contents in the text model. The current selection 
remains intact. Does nothing for null selections. 


*javax.swing.text.JTextComponent.cut()*

public void cut()

Transfers the currently selected range in the associated text model to the 
system clipboard, removing the contents from the model. The current selection 
is reset. Does nothing for null selections. 


*javax.swing.text.JTextComponent.fireCaretUpdate(CaretEvent)*

protected void fireCaretUpdate(javax.swing.event.CaretEvent e)

Notifies all listeners that have registered interest for notification on this 
event type. The event instance is lazily created using the parameters passed 
into the fire method. The listener list is processed in a last-to-first manner. 

    e - the event 

*javax.swing.text.JTextComponent.getAccessibleContext()*

public |javax.accessibility.AccessibleContext| getAccessibleContext()

Gets the AccessibleContext associated with this JTextComponent. For text 
components, the AccessibleContext takes the form of an 
AccessibleJTextComponent. A new AccessibleJTextComponent instance is created if 
necessary. 


    Returns: an AccessibleJTextComponent that serves as the AccessibleContext of this 
             JTextComponent 
*javax.swing.text.JTextComponent.getActions()*

public |javax.swing.Action| getActions()

Fetches the command list for the editor. This is the list of commands supported 
by the plugged-in UI augmented by the collection of commands that the editor 
itself supports. These are useful for binding to events, such as in a keymap. 


    Returns: the command list 
*javax.swing.text.JTextComponent.getCaret()*

public |javax.swing.text.Caret| getCaret()

Fetches the caret that allows text-oriented navigation over the view. 


    Returns: 
*javax.swing.text.JTextComponent.getCaretColor()*

public |java.awt.Color| getCaretColor()

Fetches the current color used to render the caret. 


    Returns: 
*javax.swing.text.JTextComponent.getCaretListeners()*

public |javax.swing.event.CaretListener| getCaretListeners()

Returns an array of all the caret listeners registered on this text component. 


    Returns: all of this component's CaretListeners or an empty array if no caret listeners 
             are currently registered 
*javax.swing.text.JTextComponent.getCaretPosition()*

public int getCaretPosition()

Returns the position of the text insertion caret for the text component. 


    Returns: the position of the text insertion caret for the text component >= 0 
*javax.swing.text.JTextComponent.getDisabledTextColor()*

public |java.awt.Color| getDisabledTextColor()

Fetches the current color used to render the selected text. 


    Returns: 
*javax.swing.text.JTextComponent.getDocument()*

public |javax.swing.text.Document| getDocument()

Fetches the model associated with the editor. This is primarily for the UI to 
get at the minimal amount of state required to be a text editor. Subclasses 
will return the actual type of the model which will typically be something that 
extends Document. 


    Returns: 
*javax.swing.text.JTextComponent.getDragEnabled()*

public boolean getDragEnabled()

Gets the dragEnabled property. 


    Returns: the value of the dragEnabled property 
*javax.swing.text.JTextComponent.getFocusAccelerator()*

public char getFocusAccelerator()

Returns the key accelerator that will cause the receiving text component to get 
the focus. Return '\0' if no focus accelerator has been set. 


    Returns: 
*javax.swing.text.JTextComponent.getHighlighter()*

public |javax.swing.text.Highlighter| getHighlighter()

Fetches the object responsible for making highlights. 


    Returns: the highlighter 
*javax.swing.text.JTextComponent.getInputMethodRequests()*

public |java.awt.im.InputMethodRequests| getInputMethodRequests()




*javax.swing.text.JTextComponent.getKeymap()*

public |javax.swing.text.Keymap| getKeymap()

Fetches the keymap currently active in this text component. 


    Returns: 
*javax.swing.text.JTextComponent.getKeymap(String)*

public static |javax.swing.text.Keymap| getKeymap(java.lang.String nm)

Fetches a named keymap previously added to the document. This does not work 
with null-named keymaps. 

    nm - the name of the keymap 

    Returns: 
*javax.swing.text.JTextComponent.getMargin()*

public |java.awt.Insets| getMargin()

Returns the margin between the text component's border and its text. 


    Returns: 
*javax.swing.text.JTextComponent.getNavigationFilter()*

public |javax.swing.text.NavigationFilter| getNavigationFilter()

Returns the NavigationFilter. NavigationFilter is used by DefaultCaret and the 
default cursor movement actions as a way to restrict the cursor movement. A 
null return value implies the cursor movement and selection should not be 
restricted. 


    Returns: the NavigationFilter 
*javax.swing.text.JTextComponent.getPreferredScrollableViewportSize()*

public |java.awt.Dimension| getPreferredScrollableViewportSize()

Returns the preferred size of the viewport for a view component. This is 
implemented to do the default behavior of returning the preferred size of the 
component. 


    Returns: the preferredSize of a JViewport whose view is this Scrollable 
*javax.swing.text.JTextComponent.getScrollableBlockIncrement(Rectangle,int,int)*

public int getScrollableBlockIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Components that display logical rows or columns should compute the scroll 
increment that will completely expose one block of rows or columns, depending 
on the value of orientation. 

The default implementation of this is to simply return the visible area. 
Subclasses will likely be able to provide a much more reasonable value. 

    visibleRect - the view area visible within the viewport 
    orientation - either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL 
    direction - less than zero to scroll up/left, greater than zero for down/right 

    Returns: the "block" increment for scrolling in the specified direction 
*javax.swing.text.JTextComponent.getScrollableTracksViewportHeight()*

public boolean getScrollableTracksViewportHeight()

Returns true if a viewport should always force the height of this Scrollable to 
match the height of the viewport. For example a columnar text view that flowed 
text in left to right columns could effectively disable vertical scrolling by 
returning true here. 

Scrolling containers, like JViewport, will use this method each time they are 
validated. 


    Returns: true if a viewport should force the Scrollables height to match its own 
*javax.swing.text.JTextComponent.getScrollableTracksViewportWidth()*

public boolean getScrollableTracksViewportWidth()

Returns true if a viewport should always force the width of this Scrollable to 
match the width of the viewport. For example a normal text view that supported 
line wrapping would return true here, since it would be undesirable for wrapped 
lines to disappear beyond the right edge of the viewport. Note that returning 
true for a Scrollable whose ancestor is a JScrollPane effectively disables 
horizontal scrolling. 

Scrolling containers, like JViewport, will use this method each time they are 
validated. 


    Returns: true if a viewport should force the Scrollables width to match its own 
*javax.swing.text.JTextComponent.getScrollableUnitIncrement(Rectangle,int,int)*

public int getScrollableUnitIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Components that display logical rows or columns should compute the scroll 
increment that will completely expose one new row or column, depending on the 
value of orientation. Ideally, components should handle a partially exposed row 
or column by returning the distance required to completely expose the item. 

The default implementation of this is to simply return 10% of the visible area. 
Subclasses are likely to be able to provide a much more reasonable value. 

    visibleRect - the view area visible within the viewport 
    orientation - either SwingConstants.VERTICAL or SwingConstants.HORIZONTAL 
    direction - less than zero to scroll up/left, greater than zero for down/right 

    Returns: the "unit" increment for scrolling in the specified direction 
*javax.swing.text.JTextComponent.getSelectedText()*

public |java.lang.String| getSelectedText()

Returns the selected text contained in this TextComponent. If the selection is 
null or the document empty, returns null. 


    Returns: 
*javax.swing.text.JTextComponent.getSelectedTextColor()*

public |java.awt.Color| getSelectedTextColor()

Fetches the current color used to render the selected text. 


    Returns: 
*javax.swing.text.JTextComponent.getSelectionColor()*

public |java.awt.Color| getSelectionColor()

Fetches the current color used to render the selection. 


    Returns: 
*javax.swing.text.JTextComponent.getSelectionEnd()*

public int getSelectionEnd()

Returns the selected text's end position. Return 0 if the document is empty, or 
the value of dot if there is no selection. 


    Returns: the end position >= 0 
*javax.swing.text.JTextComponent.getSelectionStart()*

public int getSelectionStart()

Returns the selected text's start position. Return 0 for an empty document, or 
the value of dot if no selection. 


    Returns: the start position >= 0 
*javax.swing.text.JTextComponent.getText()*

public |java.lang.String| getText()

Returns the text contained in this TextComponent. If the underlying document is 
null, will give a NullPointerException. 

Note that text is not a bound property, so no PropertyChangeEvent is fired when 
it changes. To listen for changes to the text, use DocumentListener. 


    Returns: 
*javax.swing.text.JTextComponent.getText(int,int)*

public |java.lang.String| getText(
  int offs,
  int len)
  throws |javax.swing.text.BadLocationException|
         
Fetches a portion of the text represented by the component. Returns an empty 
string if length is 0. 

    offs - the offset >= 0 
    len - the length >= 0 

    Returns: 
*javax.swing.text.JTextComponent.getToolTipText(MouseEvent)*

public |java.lang.String| getToolTipText(java.awt.event.MouseEvent event)

Returns the string to be used as the tooltip for event. This will return one 
of: 

If setToolTipText has been invoked with a non-null value, it will be returned, 
otherwise The value from invoking getToolTipText on the UI will be returned. 

By default JTextComponent does not register itself with the ToolTipManager. 
This means that tooltips will NOT be shown from the TextUI unless 
registerComponent has been invoked on the ToolTipManager. 

    event - the event in question 

    Returns: the string to be used as the tooltip for event 
*javax.swing.text.JTextComponent.getUI()*

public |javax.swing.plaf.TextUI| getUI()

Fetches the user-interface factory for this text-oriented editor. 


    Returns: 
*javax.swing.text.JTextComponent.isEditable()*

public boolean isEditable()

Returns the boolean indicating whether this TextComponent is editable or not. 


    Returns: the boolean value 
*javax.swing.text.JTextComponent.loadKeymap(Keymap,JTextComponent.KeyBinding[],Action[])*

public static void loadKeymap(
  javax.swing.text.Keymap map,
  javax.swing.text.JTextComponent.KeyBinding[] bindings,
  javax.swing.Action[] actions)

Loads a keymap with a bunch of bindings. This can be used to take a static 
table of definitions and load them into some keymap. The following example 
illustrates an example of binding some keys to the cut, copy, and paste actions 
associated with a JTextComponent. A code fragment to accomplish this might look 
as follows: 

static final JTextComponent.KeyBinding[] defaultBindings = { new 
JTextComponent.KeyBinding( KeyStroke.getKeyStroke(KeyEvent.VK_C, 
InputEvent.CTRL_MASK), DefaultEditorKit.copyAction), new 
JTextComponent.KeyBinding( KeyStroke.getKeyStroke(KeyEvent.VK_V, 
InputEvent.CTRL_MASK), DefaultEditorKit.pasteAction), new 
JTextComponent.KeyBinding( KeyStroke.getKeyStroke(KeyEvent.VK_X, 
InputEvent.CTRL_MASK), DefaultEditorKit.cutAction), }; 

JTextComponent c = new JTextPane(); Keymap k = c.getKeymap(); 
JTextComponent.loadKeymap(k, defaultBindings, c.getActions()); 



The sets of bindings and actions may be empty but must be non-null. 

    map - the keymap 
    bindings - the bindings 
    actions - the set of actions 

*javax.swing.text.JTextComponent.modelToView(int)*

public |java.awt.Rectangle| modelToView(int pos)
  throws |javax.swing.text.BadLocationException|
         
Converts the given location in the model to a place in the view coordinate 
system. The component must have a positive size for this translation to be 
computed (i.e. layout cannot be computed until the component has been sized). 
The component does not have to be visible or painted. 

    pos - the position >= 0 

    Returns: the coordinates as a rectangle, with (r.x, r.y) as the location in the 
             coordinate system, or null if the component does not yet have a 
             positive size. 
*javax.swing.text.JTextComponent.moveCaretPosition(int)*

public void moveCaretPosition(int pos)

Moves the caret to a new position, leaving behind a mark defined by the last 
time setCaretPosition was called. This forms a selection. If the document is 
null, does nothing. The position must be between 0 and the length of the 
component's text or else an exception is thrown. 

    pos - the position 

*javax.swing.text.JTextComponent.paramString()*

protected |java.lang.String| paramString()

Returns a string representation of this JTextComponent. This method is intended 
to be used only for debugging purposes, and the content and format of the 
returned string may vary between implementations. The returned string may be 
empty but may not be null. 

Overriding paramString to provide information about the specific new aspects of 
the JFC components. 


    Returns: a string representation of this JTextComponent 
*javax.swing.text.JTextComponent.paste()*

public void paste()

Transfers the contents of the system clipboard into the associated text model. 
If there is a selection in the associated view, it is replaced with the 
contents of the clipboard. If there is no selection, the clipboard contents are 
inserted in front of the current insert position in the associated view. If the 
clipboard is empty, does nothing. 


*javax.swing.text.JTextComponent.processInputMethodEvent(InputMethodEvent)*

protected void processInputMethodEvent(java.awt.event.InputMethodEvent e)




*javax.swing.text.JTextComponent.read(Reader,Object)*

public void read(
  java.io.Reader in,
  java.lang.Object desc)
  throws |java.io.IOException|
         
Initializes from a stream. This creates a model of the type appropriate for the 
component and initializes the model from the stream. By default this will load 
the model as plain text. Previous contents of the model are discarded. 

    in - the stream to read from 
    desc - an object describing the stream; this might be a string, a File, a URL, etc. 
       Some kinds of documents (such as html for example) might be able to make 
       use of this information; if non-null, it is added as a property of the 
       document 

*javax.swing.text.JTextComponent.removeCaretListener(CaretListener)*

public void removeCaretListener(javax.swing.event.CaretListener listener)

Removes a caret listener. 

    listener - the listener to be removed 

*javax.swing.text.JTextComponent.removeKeymap(String)*

public static |javax.swing.text.Keymap| removeKeymap(java.lang.String nm)

Removes a named keymap previously added to the document. Keymaps with null 
names may not be removed in this way. 

    nm - the name of the keymap to remove 

    Returns: the keymap that was removed 
*javax.swing.text.JTextComponent.removeNotify()*

public void removeNotify()




*javax.swing.text.JTextComponent.replaceSelection(String)*

public void replaceSelection(java.lang.String content)

Replaces the currently selected content with new content represented by the 
given string. If there is no selection this amounts to an insert of the given 
text. If there is no replacement text this amounts to a removal of the current 
selection. 

This is the method that is used by the default implementation of the action for 
inserting content that gets bound to the keymap actions. 

This method is thread safe, although most Swing methods are not. Please see 
Threads and Swing for more information. 

    content - the content to replace the selection with 

*javax.swing.text.JTextComponent.select(int,int)*

public void select(
  int selectionStart,
  int selectionEnd)

Selects the text between the specified start and end positions. 

This method sets the start and end positions of the selected text, enforcing 
the restriction that the start position must be greater than or equal to zero. 
The end position must be greater than or equal to the start position, and less 
than or equal to the length of the text component's text. 

If the caller supplies values that are inconsistent or out of bounds, the 
method enforces these constraints silently, and without failure. Specifically, 
if the start position or end position is greater than the length of the text, 
it is reset to equal the text length. If the start position is less than zero, 
it is reset to zero, and if the end position is less than the start position, 
it is reset to the start position. 

This call is provided for backward compatibility. It is routed to a call to 
setCaretPosition followed by a call to moveCaretPosition. The preferred way to 
manage selection is by calling those methods directly. 

    selectionStart - the start position of the text 
    selectionEnd - the end position of the text 

*javax.swing.text.JTextComponent.selectAll()*

public void selectAll()

Selects all the text in the TextComponent. Does nothing on a null or empty 
document. 


*javax.swing.text.JTextComponent.setCaret(Caret)*

public void setCaret(javax.swing.text.Caret c)

Sets the caret to be used. By default this will be set by the UI that gets 
installed. This can be changed to a custom caret if desired. Setting the caret 
results in a PropertyChange event ("caret") being fired. 

    c - the caret 

*javax.swing.text.JTextComponent.setCaretColor(Color)*

public void setCaretColor(java.awt.Color c)

Sets the current color used to render the caret. Setting to null effectively 
restores the default color. Setting the color results in a PropertyChange event 
("caretColor") being fired. 

    c - the color 

*javax.swing.text.JTextComponent.setCaretPosition(int)*

public void setCaretPosition(int position)

Sets the position of the text insertion caret for the TextComponent. Note that 
the caret tracks change, so this may move if the underlying text of the 
component is changed. If the document is null, does nothing. The position must 
be between 0 and the length of the component's text or else an exception is 
thrown. 

    position - the position 

*javax.swing.text.JTextComponent.setComponentOrientation(ComponentOrientation)*

public void setComponentOrientation(java.awt.ComponentOrientation o)




*javax.swing.text.JTextComponent.setDisabledTextColor(Color)*

public void setDisabledTextColor(java.awt.Color c)

Sets the current color used to render the disabled text. Setting the color 
fires off a PropertyChange event ("disabledTextColor"). 

    c - the color 

*javax.swing.text.JTextComponent.setDocument(Document)*

public void setDocument(javax.swing.text.Document doc)

Associates the editor with a text document. The currently registered factory is 
used to build a view for the document, which gets displayed by the editor after 
revalidation. A PropertyChange event ("document") is propagated to each 
listener. 

    doc - the document to display/edit 

*javax.swing.text.JTextComponent.setDragEnabled(boolean)*

public void setDragEnabled(boolean b)

Sets the dragEnabled property, which must be true to enable automatic drag 
handling (the first part of drag and drop) on this component. The 
transferHandler property needs to be set to a non-null value for the drag to do 
anything. The default value of the dragEnabled property is false. 

When automatic drag handling is enabled, most look and feels begin a 
drag-and-drop operation whenever the user presses the mouse button over a 
selection and then moves the mouse a few pixels. Setting this property to true 
can therefore have a subtle effect on how selections behave. 

Some look and feels might not support automatic drag and drop; they will ignore 
this property. You can work around such look and feels by modifying the 
component to directly call the exportAsDrag method of a TransferHandler. 

    b - the value to set the dragEnabled property to 

*javax.swing.text.JTextComponent.setEditable(boolean)*

public void setEditable(boolean b)

Sets the specified boolean to indicate whether or not this TextComponent should 
be editable. A PropertyChange event ("editable") is fired when the state is 
changed. 

    b - the boolean to be set 

*javax.swing.text.JTextComponent.setFocusAccelerator(char)*

public void setFocusAccelerator(char aKey)

Sets the key accelerator that will cause the receiving text component to get 
the focus. The accelerator will be the key combination of the alt key and the 
character given (converted to upper case). By default, there is no focus 
accelerator key. Any previous key accelerator setting will be superseded. A 
'\0' key setting will be registered, and has the effect of turning off the 
focus accelerator. When the new key is set, a PropertyChange event 
(FOCUS_ACCELERATOR_KEY) will be fired. 

    aKey - the key 

*javax.swing.text.JTextComponent.setHighlighter(Highlighter)*

public void setHighlighter(javax.swing.text.Highlighter h)

Sets the highlighter to be used. By default this will be set by the UI that 
gets installed. This can be changed to a custom highlighter if desired. The 
highlighter can be set to null to disable it. A PropertyChange event 
("highlighter") is fired when a new highlighter is installed. 

    h - the highlighter 

*javax.swing.text.JTextComponent.setKeymap(Keymap)*

public void setKeymap(javax.swing.text.Keymap map)

Sets the keymap to use for binding events to actions. Setting to null 
effectively disables keyboard input. A PropertyChange event ("keymap") is fired 
when a new keymap is installed. 

    map - the keymap 

*javax.swing.text.JTextComponent.setMargin(Insets)*

public void setMargin(java.awt.Insets m)

Sets margin space between the text component's border and its text. The text 
component's default Border object will use this value to create the proper 
margin. However, if a non-default border is set on the text component, it is 
that Border object's responsibility to create the appropriate margin space 
(else this property will effectively be ignored). This causes a redraw of the 
component. A PropertyChange event ("margin") is sent to all listeners. 

    m - the space between the border and the text 

*javax.swing.text.JTextComponent.setNavigationFilter(NavigationFilter)*

public void setNavigationFilter(javax.swing.text.NavigationFilter filter)

Sets the NavigationFilter. NavigationFilter is used by DefaultCaret and the 
default cursor movement actions as a way to restrict the cursor movement. 


*javax.swing.text.JTextComponent.setSelectedTextColor(Color)*

public void setSelectedTextColor(java.awt.Color c)

Sets the current color used to render the selected text. Setting the color to 
null is the same as Color.black. Setting the color results in a PropertyChange 
event ("selectedTextColor") being fired. 

    c - the color 

*javax.swing.text.JTextComponent.setSelectionColor(Color)*

public void setSelectionColor(java.awt.Color c)

Sets the current color used to render the selection. Setting the color to null 
is the same as setting Color.white. Setting the color results in a 
PropertyChange event ("selectionColor"). 

    c - the color 

*javax.swing.text.JTextComponent.setSelectionEnd(int)*

public void setSelectionEnd(int selectionEnd)

Sets the selection end to the specified position. The new end point is 
constrained to be at or after the current selection start. 

This is available for backward compatibility to code that called this method on 
java.awt.TextComponent. This is implemented to forward to the Caret 
implementation which is where the actual selection is maintained. 

    selectionEnd - the end position of the text >= 0 

*javax.swing.text.JTextComponent.setSelectionStart(int)*

public void setSelectionStart(int selectionStart)

Sets the selection start to the specified position. The new starting point is 
constrained to be before or at the current selection end. 

This is available for backward compatibility to code that called this method on 
java.awt.TextComponent. This is implemented to forward to the Caret 
implementation which is where the actual selection is maintained. 

    selectionStart - the start position of the text >= 0 

*javax.swing.text.JTextComponent.setText(String)*

public void setText(java.lang.String t)

Sets the text of this TextComponent to the specified text. If the text is null 
or empty, has the effect of simply deleting the old text. When text has been 
inserted, the resulting caret location is determined by the implementation of 
the caret class. 

This method is thread safe, although most Swing methods are not. Please see 
Threads and Swing for more information. 

Note that text is not a bound property, so no PropertyChangeEvent is fired when 
it changes. To listen for changes to the text, use DocumentListener. 

    t - the new text to be set 

*javax.swing.text.JTextComponent.setUI(TextUI)*

public void setUI(javax.swing.plaf.TextUI ui)

Sets the user-interface factory for this text-oriented editor. 

    ui - the factory 

*javax.swing.text.JTextComponent.updateUI()*

public void updateUI()

Reloads the pluggable UI. The key used to fetch the new interface is 
getUIClassID(). The type of the UI is TextUI. invalidate is called after 
setting the UI. 


*javax.swing.text.JTextComponent.viewToModel(Point)*

public int viewToModel(java.awt.Point pt)

Converts the given place in the view coordinate system to the nearest 
representative location in the model. The component must have a positive size 
for this translation to be computed (i.e. layout cannot be computed until the 
component has been sized). The component does not have to be visible or 
painted. 

    pt - the location in the view to translate 

    Returns: the offset >= 0 from the start of the document, or -1 if the component does not 
             yet have a positive size. 
*javax.swing.text.JTextComponent.write(Writer)*

public void write(java.io.Writer out)
  throws |java.io.IOException|
         
Stores the contents of the model into the given stream. By default this will 
store the model as plain text. 

    out - the output stream 


