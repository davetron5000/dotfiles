*javax.swing.text.View* *View* 
 A very important part of the text package is th

public abstract class View
  extends    |java.lang.Object|
  implements |javax.swing.SwingConstants|

|javax.swing.text.View_Description|
|javax.swing.text.View_Fields|
|javax.swing.text.View_Constructors|
|javax.swing.text.View_Methods|

================================================================================

*javax.swing.text.View_Fields*
|int_javax.swing.text.View.BadBreakWeight|
|int_javax.swing.text.View.ExcellentBreakWeight|
|int_javax.swing.text.View.ForcedBreakWeight|
|int_javax.swing.text.View.GoodBreakWeight|
|int_javax.swing.text.View.X_AXIS|
|int_javax.swing.text.View.Y_AXIS|

*javax.swing.text.View_Constructors*
|javax.swing.text.View(Element)|Creates a new View object.

*javax.swing.text.View_Methods*
|javax.swing.text.View.append(View)|Appends a single child view.
|javax.swing.text.View.breakView(int,int,float,float)|Tries to break this view 
|javax.swing.text.View.changedUpdate(DocumentEvent,Shape,ViewFactory)|Gives not
|javax.swing.text.View.createFragment(int,int)|Creates a view that represents a
|javax.swing.text.View.forwardUpdate(DocumentEvent.ElementChange,DocumentEvent,Shape,ViewFactory)|
|javax.swing.text.View.forwardUpdateToView(View,DocumentEvent,Shape,ViewFactory)|
|javax.swing.text.View.getAlignment(int)|Determines the desired alignment for t
|javax.swing.text.View.getAttributes()|Fetches the attributes to use when rende
|javax.swing.text.View.getBreakWeight(int,float,float)|Determines how attractiv
|javax.swing.text.View.getChildAllocation(int,Shape)|Fetches the allocation for
|javax.swing.text.View.getContainer()|Fetches the container hosting the view.
|javax.swing.text.View.getDocument()|Fetches the model associated with the view
|javax.swing.text.View.getElement()|Fetches the structural portion of the subje
|javax.swing.text.View.getEndOffset()|Fetches the portion of the model for whic
|javax.swing.text.View.getGraphics()|Fetch a Graphics for rendering.
|javax.swing.text.View.getMaximumSpan(int)|Determines the maximum span for this
|javax.swing.text.View.getMinimumSpan(int)|Determines the minimum span for this
|javax.swing.text.View.getNextVisualPositionFrom(int,Position.Bias,Shape,int,Position.Bias[])|
|javax.swing.text.View.getParent()|Returns the parent of the view.
|javax.swing.text.View.getPreferredSpan(int)|Determines the preferred span for 
|javax.swing.text.View.getResizeWeight(int)|Determines the resizability of the 
|javax.swing.text.View.getStartOffset()|Fetches the portion of the model for wh
|javax.swing.text.View.getToolTipText(float,float,Shape)|Returns the tooltip te
|javax.swing.text.View.getView(int)|Gets the nth child view.
|javax.swing.text.View.getViewCount()|Returns the number of views in this view.
|javax.swing.text.View.getViewFactory()|Fetches the ViewFactory implementation 
|javax.swing.text.View.getViewIndex(float,float,Shape)|Returns the child view i
|javax.swing.text.View.getViewIndex(int,Position.Bias)|Returns the child view i
|javax.swing.text.View.insert(int,View)|Inserts a single child view.
|javax.swing.text.View.insertUpdate(DocumentEvent,Shape,ViewFactory)|Gives noti
|javax.swing.text.View.isVisible()|Returns a boolean that indicates whether   t
|javax.swing.text.View.modelToView(int,Position.Bias,int,Position.Bias,Shape)|P
|javax.swing.text.View.modelToView(int,Shape)|Provides a mapping from the docum
|javax.swing.text.View.modelToView(int,Shape,Position.Bias)|Provides a mapping,
|javax.swing.text.View.paint(Graphics,Shape)|Renders using the given rendering 
|javax.swing.text.View.preferenceChanged(View,boolean,boolean)|Child views can 
|javax.swing.text.View.remove(int)|Removes one of the children at the given pos
|javax.swing.text.View.removeAll()|Removes all of the children.
|javax.swing.text.View.removeUpdate(DocumentEvent,Shape,ViewFactory)|Gives noti
|javax.swing.text.View.replace(int,int,View[])|Replaces child views.
|javax.swing.text.View.setParent(View)|Establishes the parent view for this vie
|javax.swing.text.View.setSize(float,float)|Sets the size of the view.
|javax.swing.text.View.updateChildren(DocumentEvent.ElementChange,DocumentEvent,ViewFactory)|
|javax.swing.text.View.updateLayout(DocumentEvent.ElementChange,DocumentEvent,Shape)|
|javax.swing.text.View.viewToModel(float,float,Shape)|Provides a mapping from t
|javax.swing.text.View.viewToModel(float,float,Shape,Position.Bias[])|Provides 

*javax.swing.text.View_Description*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.BadBreakWeight*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.ExcellentBreakWeight*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.ForcedBreakWeight*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.GoodBreakWeight*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.X_AXIS*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 




*int_javax.swing.text.View.Y_AXIS*

A very important part of the text package is the View class. As the name 
suggests it represents a view of the text model, or a piece of the text model. 
It is this class that is responsible for the look of the text component. The 
view is not intended to be some completely new thing that one must learn, but 
rather is much like a lightweight component. In fact, the original View 
implementation was a lightweight component. There were several reasons why the 
Component implementation was abandoned in favor of an alternative. 



There was barely time to get the lightweight component support in the 1.1 
version of the JDK. There simply wasn't time to lighten up the component 
further to where it would need to be to be used for text purposes. The 
additions made to JComponent increased the memory consumption, and as it 
currently stands its much too heavy for representing text. 



The layout semantics aren't quite right for text, and changing the current 
layout semantics of component might break existing applications. 



The component api uses integers, but in 1.2 one can use floating point device 
independent coordinates. An api that works in both 1.1 and 1.2 would be 
convenient for minimizing transition difficulties. The View class uses the 
Shape interface and float arguments to enable View implementations for the Java 
2 platform v1.2 and later while still functioning in the older 1.1 JDK. 



By default, a view is very light. It contains a reference to the parent view 
from which it can fetch many things without holding state, and it contains a 
reference to a portion of the model (Element). A view does not have to exactly 
represent an element in the model, that is simply a typical and therefore 
convenient mapping. A view can alternatively maintain a couple of Position 
objects to maintain its location in the model (i.e. represent a fragment of an 
element). This is typically the result of formatting where views have been 
broken down into pieces. The convenience of a substantial relationship to the 
element makes it easier to build factories to produce the views, and makes it 
easier to keep track of the view pieces as the model is changed and the view 
must be changed to reflect the model. Simple views therefore represent an 
Element directly and complex views do not. 

A view has the following responsibilities: 

Participate in layout. 

The view has a setSize method which is like doLayout and setSize in Component 
combined. The view has a preferenceChanged method which is like invalidate in 
Component except that one can invalidate just one axis and the child requesting 
the change is identified. A View expresses the size that it would like to be in 
terms of three values, a minimum, a preferred, and a maximum span. Layout in a 
view is can be done independently upon each axis. For a properly functioning 
View implementation, the minimum span will be <= the preferred span which in 
turn will be <= the maximum span. 

The minimum set of methods for layout are: 

getMinimumSpan getPreferredSpan getMaximumSpan getAlignment preferenceChanged 
setSize 

The setSize method should be prepared to be called a number of times (i.e. It 
may be called even if the size didn't change). The setSize method is generally 
called to make sure the View layout is complete prior to trying to perform an 
operation on it that requires an up-to-date layout. A view's size should always 
be set to a value within the minimum and maximum span specified by that view. 
Additionally, the view must always call the preferenceChanged method on the 
parent if it has changed the values for the layout it would like, and expects 
the parent to honor. The parent View is not required to recognize a change 
until the preferenceChanged has been sent. This allows parent View 
implementations to cache the child requirements if desired. The calling 
sequence looks something like the following: 



The exact calling sequence is up to the layout functionality of the parent view 
(if the view has any children). The view may collect the preferences of the 
children prior to determining what it will give each child, or it might 
iteratively update the children one at a time. 

Render a portion of the model. 

This is done in the paint method, which is pretty much like a component paint 
method. Views are expected to potentially populate a fairly large tree. A View 
has the following semantics for rendering: 

The view gets its allocation from the parent at paint time, so it must be 
prepared to redo layout if the allocated area is different from what it is 
prepared to deal with. The coordinate system is the same as the hosting 
Component (i.e. the Component returned by the getContainer method). This means 
a child view lives in the same coordinate system as the parent view unless the 
parent has explicitly changed the coordinate system. To schedule itself to be 
repainted a view can call repaint on the hosting Component. The default is to 
not clip the children. It is more efficient to allow a view to clip only if it 
really feels it needs clipping. The Graphics object given is not initialized in 
any way. A view should set any settings needed. A View is inherently 
transparent. While a view may render into its entire allocation, typically a 
view does not. Rendering is performed by tranversing down the tree of View 
implementations. Each View is responsible for rendering its children. This 
behavior is depended upon for thread safety. While view implementations do not 
necessarily have to be implemented with thread safety in mind, other view 
implementations that do make use of concurrency can depend upon a tree 
traversal to guarantee thread safety. The order of views relative to the model 
is up to the implementation. Although child views will typically be arranged in 
the same order that they occur in the model, they may be visually arranged in 
an entirely different order. View implementations may have Z-Order associated 
with them if the children are overlapping. 

The methods for rendering are: 

paint 



Translate between the model and view coordinate systems. 

Because the view objects are produced from a factory and therefore cannot 
necessarily be counted upon to be in a particular pattern, one must be able to 
perform translation to properly locate spatial representation of the model. The 
methods for doing this are: 

modelToView viewToModel getDocument getElement getStartOffset getEndOffset 

The layout must be valid prior to attempting to make the translation. The 
translation is not valid, and must not be attempted while changes are being 
broadcasted from the model via a DocumentEvent. 

Respond to changes from the model. 

If the overall view is represented by many pieces (which is the best situation 
if one want to be able to change the view and write the least amount of new 
code), it would be impractical to have a huge number of DocumentListeners. If 
each view listened to the model, only a few would actually be interested in the 
changes broadcasted at any given time. Since the model has no knowledge of 
views, it has no way to filter the broadcast of change information. The view 
hierarchy itself is instead responsible for propagating the change information. 
At any level in the view hierarchy, that view knows enough about its children 
to best distribute the change information further. Changes are therefore 
broadcasted starting from the root of the view hierarchy. The methods for doing 
this are: 

insertUpdate removeUpdate changedUpdate 





*javax.swing.text.View(Element)*

public View(javax.swing.text.Element elem)

Creates a new View object. 

    elem - the Element to represent 

*javax.swing.text.View.append(View)*

public void append(javax.swing.text.View v)

Appends a single child view. This is a convenience call to replace. 

    v - the view 

*javax.swing.text.View.breakView(int,int,float,float)*

public |javax.swing.text.View| breakView(
  int axis,
  int offset,
  float pos,
  float len)

Tries to break this view on the given axis. This is called by views that try to 
do formatting of their children. For example, a view of a paragraph will 
typically try to place its children into row and views representing chunks of 
text can sometimes be broken down into smaller pieces. 

This is implemented to return the view itself, which represents the default 
behavior on not being breakable. If the view does support breaking, the 
starting offset of the view returned should be the given offset, and the end 
offset should be less than or equal to the end offset of the view being broken. 

    axis - may be either View.X_AXIS or View.Y_AXIS 
    offset - the location in the document model that a broken fragment would occupy >= 0. 
       This would be the starting offset of the fragment returned 
    pos - the position along the axis that the broken view would occupy >= 0. This may be 
       useful for things like tab calculations 
    len - specifies the distance along the axis where a potential break is desired >= 0 

    Returns: the fragment of the view that represents the given span, if the view can be 
             broken. If the view doesn't support breaking behavior, the view 
             itself is returned. 
*javax.swing.text.View.changedUpdate(DocumentEvent,Shape,ViewFactory)*

public void changedUpdate(
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a,
  javax.swing.text.ViewFactory f)

Gives notification from the document that attributes were changed in a location 
that this view is responsible for. To reduce the burden to subclasses, this 
functionality is spread out into the following calls that subclasses can 
reimplement: 

updateChildren is called if there were any changes to the element this view is 
responsible for. If this view has child views that are represent the child 
elements, then this method should do whatever is necessary to make sure the 
child views correctly represent the model. forwardUpdate is called to forward 
the DocumentEvent to the appropriate child views. updateLayout is called to 
give the view a chance to either repair its layout, to reschedule layout, or do 
nothing. 

    e - the change information from the associated document 
    a - the current allocation of the view 
    f - the factory to use to rebuild if the view has children 

*javax.swing.text.View.createFragment(int,int)*

public |javax.swing.text.View| createFragment(
  int p0,
  int p1)

Creates a view that represents a portion of the element. This is potentially 
useful during formatting operations for taking measurements of fragments of the 
view. If the view doesn't support fragmenting (the default), it should return 
itself. 

    p0 - the starting offset >= 0. This should be a value greater or equal to the 
       element starting offset and less than the element ending offset. 
    p1 - the ending offset > p0. This should be a value less than or equal to the 
       elements end offset and greater than the elements starting offset. 

    Returns: the view fragment, or itself if the view doesn't support breaking into 
             fragments 
*javax.swing.text.View.forwardUpdate(DocumentEvent.ElementChange,DocumentEvent,Shape,ViewFactory)*

protected void forwardUpdate(
  javax.swing.event.DocumentEvent.ElementChange ec,
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a,
  javax.swing.text.ViewFactory f)

Forwards the given DocumentEvent to the child views that need to be notified of 
the change to the model. If there were changes to the element this view is 
responsible for, that should be considered when forwarding (i.e. new child 
views should not get notified). 

    ec - changes to the element this view is responsible for (may be null if there were 
       no changes). 
    e - the change information from the associated document 
    a - the current allocation of the view 
    f - the factory to use to rebuild if the view has children 

*javax.swing.text.View.forwardUpdateToView(View,DocumentEvent,Shape,ViewFactory)*

protected void forwardUpdateToView(
  javax.swing.text.View v,
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a,
  javax.swing.text.ViewFactory f)

Forwards the DocumentEvent to the give child view. This simply messages the 
view with a call to insertUpdate, removeUpdate, or changedUpdate depending upon 
the type of the event. This is called by forwardUpdate to forward the event to 
children that need it. 

    v - the child view to forward the event to 
    e - the change information from the associated document 
    a - the current allocation of the view 
    f - the factory to use to rebuild if the view has children 

*javax.swing.text.View.getAlignment(int)*

public float getAlignment(int axis)

Determines the desired alignment for this view along an axis. The desired 
alignment is returned. This should be a value >= 0.0 and <= 1.0, where 0 
indicates alignment at the origin and 1.0 indicates alignment to the full span 
away from the origin. An alignment of 0.5 would be the center of the view. 

    axis - may be either View.X_AXIS or View.Y_AXIS 

    Returns: the value 0.5 
*javax.swing.text.View.getAttributes()*

public |javax.swing.text.AttributeSet| getAttributes()

Fetches the attributes to use when rendering. By default this simply returns 
the attributes of the associated element. This method should be used rather 
than using the element directly to obtain access to the attributes to allow 
view-specific attributes to be mixed in or to allow the view to have 
view-specific conversion of attributes by subclasses. Each view should document 
what attributes it recognizes for the purpose of rendering or layout, and 
should always access them through the AttributeSet returned by this method. 


*javax.swing.text.View.getBreakWeight(int,float,float)*

public int getBreakWeight(
  int axis,
  float pos,
  float len)

Determines how attractive a break opportunity in this view is. This can be used 
for determining which view is the most attractive to call breakView on in the 
process of formatting. A view that represents text that has whitespace in it 
might be more attractive than a view that has no whitespace, for example. The 
higher the weight, the more attractive the break. A value equal to or lower 
than BadBreakWeight should not be considered for a break. A value greater than 
or equal to ForcedBreakWeight should be broken. 

This is implemented to provide the default behavior of returning BadBreakWeight 
unless the length is greater than the length of the view in which case the 
entire view represents the fragment. Unless a view has been written to support 
breaking behavior, it is not attractive to try and break the view. An example 
of a view that does support breaking is LabelView. An example of a view that 
uses break weight is ParagraphView. 

    axis - may be either View.X_AXIS or View.Y_AXIS 
    pos - the potential location of the start of the broken view >= 0. This may be useful 
       for calculating tab positions 
    len - specifies the relative length from pos where a potential break is desired >= 0 

    Returns: the weight, which should be a value between ForcedBreakWeight and 
             BadBreakWeight 
*javax.swing.text.View.getChildAllocation(int,Shape)*

public |java.awt.Shape| getChildAllocation(
  int index,
  java.awt.Shape a)

Fetches the allocation for the given child view. This enables finding out where 
various views are located, without assuming how the views store their location. 
This returns null since the default is to not have any child views. 

    index - the index of the child, >= 0 getViewCount() 
    a - the allocation to this view 

    Returns: the allocation to the child 
*javax.swing.text.View.getContainer()*

public |java.awt.Container| getContainer()

Fetches the container hosting the view. This is useful for things like 
scheduling a repaint, finding out the host components font, etc. The default 
implementation of this is to forward the query to the parent view. 


    Returns: the container, null if none 
*javax.swing.text.View.getDocument()*

public |javax.swing.text.Document| getDocument()

Fetches the model associated with the view. 


    Returns: the view model, null if none 
*javax.swing.text.View.getElement()*

public |javax.swing.text.Element| getElement()

Fetches the structural portion of the subject that this view is mapped to. The 
view may not be responsible for the entire portion of the element. 


    Returns: 
*javax.swing.text.View.getEndOffset()*

public int getEndOffset()

Fetches the portion of the model for which this view is responsible. 


    Returns: the ending offset into the model >= 0 
*javax.swing.text.View.getGraphics()*

public |java.awt.Graphics| getGraphics()

Fetch a Graphics for rendering. This can be used to determine font 
characteristics, and will be different for a print view than a component view. 


    Returns: a Graphics object for rendering 
*javax.swing.text.View.getMaximumSpan(int)*

public float getMaximumSpan(int axis)

Determines the maximum span for this view along an axis. 

    axis - may be either View.X_AXIS or View.Y_AXIS 

    Returns: the maximum span the view can be rendered into 
*javax.swing.text.View.getMinimumSpan(int)*

public float getMinimumSpan(int axis)

Determines the minimum span for this view along an axis. 

    axis - may be either View.X_AXIS or View.Y_AXIS 

    Returns: the minimum span the view can be rendered into 
*javax.swing.text.View.getNextVisualPositionFrom(int,Position.Bias,Shape,int,Position.Bias[])*

public int getNextVisualPositionFrom(
  int pos,
  javax.swing.text.Position.Bias b,
  java.awt.Shape a,
  int direction,
  javax.swing.text.Position.Bias[] biasRet)
  throws |javax.swing.text.BadLocationException|
         
Provides a way to determine the next visually represented model location at 
which one might place a caret. Some views may not be visible, they might not be 
in the same order found in the model, or they just might not allow access to 
some of the locations in the model. 

    pos - the position to convert >= 0 
    a - the allocated region in which to render 
    direction - the direction from the current position that can be thought of as the arrow 
       keys typically found on a keyboard. This will be one of the following 
       values: 

SwingConstants.WEST SwingConstants.EAST SwingConstants.NORTH 
       SwingConstants.SOUTH 

    Returns: the location within the model that best represents the next location visual 
             position 
*javax.swing.text.View.getParent()*

public |javax.swing.text.View| getParent()

Returns the parent of the view. 


    Returns: the parent, or null if none exists 
*javax.swing.text.View.getPreferredSpan(int)*

public abstract float getPreferredSpan(int axis)

Determines the preferred span for this view along an axis. 

    axis - may be either View.X_AXIS or View.Y_AXIS 

    Returns: the span the view would like to be rendered into. Typically the view is told to 
             render into the span that is returned, although there is no 
             guarantee. The parent may choose to resize or break the view 
*javax.swing.text.View.getResizeWeight(int)*

public int getResizeWeight(int axis)

Determines the resizability of the view along the given axis. A value of 0 or 
less is not resizable. 

    axis - may be either View.X_AXIS or View.Y_AXIS 

    Returns: 
*javax.swing.text.View.getStartOffset()*

public int getStartOffset()

Fetches the portion of the model for which this view is responsible. 


    Returns: the starting offset into the model >= 0 
*javax.swing.text.View.getToolTipText(float,float,Shape)*

public |java.lang.String| getToolTipText(
  float x,
  float y,
  java.awt.Shape allocation)

Returns the tooltip text at the specified location. The default implementation 
returns the value from the child View identified by the passed in location. 


*javax.swing.text.View.getView(int)*

public |javax.swing.text.View| getView(int n)

Gets the nth child view. Since there are no children by default, this returns 
null. 

    n - the number of the view to get, >= 0 < getViewCount() 

    Returns: 
*javax.swing.text.View.getViewCount()*

public int getViewCount()

Returns the number of views in this view. Since the default is to not be a 
composite view this returns 0. 


    Returns: the number of views >= 0 
*javax.swing.text.View.getViewFactory()*

public |javax.swing.text.ViewFactory| getViewFactory()

Fetches the ViewFactory implementation that is feeding the view hierarchy. 
Normally the views are given this as an argument to updates from the model when 
they are most likely to need the factory, but this method serves to provide it 
at other times. 


    Returns: the factory, null if none 
*javax.swing.text.View.getViewIndex(float,float,Shape)*

public int getViewIndex(
  float x,
  float y,
  java.awt.Shape allocation)

Returns the child view index representing the given position in the view. This 
iterates over all the children returning the first with a bounds that contains 
x, y. 

    x - the x coordinate 
    y - the y coordinate 
    allocation - current allocation of the View. 

    Returns: index of the view representing the given location, or -1 if no view represents 
             that position 
*javax.swing.text.View.getViewIndex(int,Position.Bias)*

public int getViewIndex(
  int pos,
  javax.swing.text.Position.Bias b)

Returns the child view index representing the given position in the model. By 
default a view has no children so this is implemented to return -1 to indicate 
there is no valid child index for any position. 

    pos - the position >= 0 

    Returns: index of the view representing the given position, or -1 if no view represents 
             that position 
*javax.swing.text.View.insert(int,View)*

public void insert(
  int offs,
  javax.swing.text.View v)

Inserts a single child view. This is a convenience call to replace. 

    offs - the offset of the view to insert before >= 0 
    v - the view 

*javax.swing.text.View.insertUpdate(DocumentEvent,Shape,ViewFactory)*

public void insertUpdate(
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a,
  javax.swing.text.ViewFactory f)

Gives notification that something was inserted into the document in a location 
that this view is responsible for. To reduce the burden to subclasses, this 
functionality is spread out into the following calls that subclasses can 
reimplement: 

updateChildren is called if there were any changes to the element this view is 
responsible for. If this view has child views that are represent the child 
elements, then this method should do whatever is necessary to make sure the 
child views correctly represent the model. forwardUpdate is called to forward 
the DocumentEvent to the appropriate child views. updateLayout is called to 
give the view a chance to either repair its layout, to reschedule layout, or do 
nothing. 

    e - the change information from the associated document 
    a - the current allocation of the view 
    f - the factory to use to rebuild if the view has children 

*javax.swing.text.View.isVisible()*

public boolean isVisible()

Returns a boolean that indicates whether the view is visible or not. By default 
all views are visible. 


    Returns: always returns true 
*javax.swing.text.View.modelToView(int,Position.Bias,int,Position.Bias,Shape)*

public |java.awt.Shape| modelToView(
  int p0,
  javax.swing.text.Position.Bias b0,
  int p1,
  javax.swing.text.Position.Bias b1,
  java.awt.Shape a)
  throws |javax.swing.text.BadLocationException|
         
Provides a mapping, for a given region, from the document model coordinate 
space to the view coordinate space. The specified region is created as a union 
of the first and last character positions. 

    p0 - the position of the first character (>=0) 
    b0 - the bias of the first character position, toward the previous character or the 
       next character represented by the offset, in case the position is a 
       boundary of two views; b0 will have one of these values: 

Position.Bias.Forward Position.Bias.Backward 
    p1 - the position of the last character (>=0) 
    b1 - the bias for the second character position, defined one of the legal values 
       shown above 
    a - the area of the view, which encompasses the requested region 

    Returns: the bounding box which is a union of the region specified by the first and last 
             character positions 
*javax.swing.text.View.modelToView(int,Shape)*

public |java.awt.Shape| modelToView(
  int pos,
  java.awt.Shape a)
  throws |javax.swing.text.BadLocationException|
         
Provides a mapping from the document model coordinate space to the coordinate 
space of the view mapped to it. This is implemented to default the bias to 
Position.Bias.Forward which was previously implied. 

    pos - the position to convert >= 0 
    a - the allocated region in which to render 

    Returns: the bounding box of the given position is returned 
*javax.swing.text.View.modelToView(int,Shape,Position.Bias)*

public abstract |java.awt.Shape| modelToView(
  int pos,
  java.awt.Shape a,
  javax.swing.text.Position.Bias b)
  throws |javax.swing.text.BadLocationException|
         
Provides a mapping, for a given character, from the document model coordinate 
space to the view coordinate space. 

    pos - the position of the desired character (>=0) 
    a - the area of the view, which encompasses the requested character 
    b - the bias toward the previous character or the next character represented by the 
       offset, in case the position is a boundary of two views; b will have one 
       of these values: 

Position.Bias.Forward Position.Bias.Backward 

    Returns: the bounding box, in view coordinate space, of the character at the specified 
             position 
*javax.swing.text.View.paint(Graphics,Shape)*

public abstract void paint(
  java.awt.Graphics g,
  java.awt.Shape allocation)

Renders using the given rendering surface and area on that surface. The view 
may need to do layout and create child views to enable itself to render into 
the given allocation. 

    g - the rendering surface to use 
    allocation - the allocated region to render into 

*javax.swing.text.View.preferenceChanged(View,boolean,boolean)*

public void preferenceChanged(
  javax.swing.text.View child,
  boolean width,
  boolean height)

Child views can call this on the parent to indicate that the preference has 
changed and should be reconsidered for layout. By default this just propagates 
upward to the next parent. The root view will call revalidate on the associated 
text component. 

    child - the child view 
    width - true if the width preference has changed 
    height - true if the height preference has changed 

*javax.swing.text.View.remove(int)*

public void remove(int i)

Removes one of the children at the given position. This is a convenience call 
to replace. 


*javax.swing.text.View.removeAll()*

public void removeAll()

Removes all of the children. This is a convenience call to replace. 


*javax.swing.text.View.removeUpdate(DocumentEvent,Shape,ViewFactory)*

public void removeUpdate(
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a,
  javax.swing.text.ViewFactory f)

Gives notification that something was removed from the document in a location 
that this view is responsible for. To reduce the burden to subclasses, this 
functionality is spread out into the following calls that subclasses can 
reimplement: 

updateChildren is called if there were any changes to the element this view is 
responsible for. If this view has child views that are represent the child 
elements, then this method should do whatever is necessary to make sure the 
child views correctly represent the model. forwardUpdate is called to forward 
the DocumentEvent to the appropriate child views. updateLayout is called to 
give the view a chance to either repair its layout, to reschedule layout, or do 
nothing. 

    e - the change information from the associated document 
    a - the current allocation of the view 
    f - the factory to use to rebuild if the view has children 

*javax.swing.text.View.replace(int,int,View[])*

public void replace(
  int offset,
  int length,
  javax.swing.text.View[] views)

Replaces child views. If there are no views to remove this acts as an insert. 
If there are no views to add this acts as a remove. Views being removed will 
have the parent set to null, and the internal reference to them removed so that 
they can be garbage collected. This is implemented to do nothing, because by 
default a view has no children. 

    offset - the starting index into the child views to insert the new views. This should be 
       a value >= 0 and <= getViewCount 
    length - the number of existing child views to remove This should be a value >= 0 and <= 
       (getViewCount() - offset). 
    views - the child views to add. This value can be null to indicate no children are 
       being added (useful to remove). 

*javax.swing.text.View.setParent(View)*

public void setParent(javax.swing.text.View parent)

Establishes the parent view for this view. This is guaranteed to be called 
before any other methods if the parent view is functioning properly. This is 
also the last method called, since it is called to indicate the view has been 
removed from the hierarchy as well. When this method is called to set the 
parent to null, this method does the same for each of its children, propogating 
the notification that they have been disconnected from the view tree. If this 
is reimplemented, super.setParent() should be called. 

    parent - the new parent, or null if the view is being removed from a parent 

*javax.swing.text.View.setSize(float,float)*

public void setSize(
  float width,
  float height)

Sets the size of the view. This should cause layout of the view along the given 
axis, if it has any layout duties. 

    width - the width >= 0 
    height - the height >= 0 

*javax.swing.text.View.updateChildren(DocumentEvent.ElementChange,DocumentEvent,ViewFactory)*

protected boolean updateChildren(
  javax.swing.event.DocumentEvent.ElementChange ec,
  javax.swing.event.DocumentEvent e,
  javax.swing.text.ViewFactory f)

Updates the child views in response to receiving notification that the model 
changed, and there is change record for the element this view is responsible 
for. This is implemented to assume the child views are directly responsible for 
the child elements of the element this view represents. The ViewFactory is used 
to create child views for each element specified as added in the ElementChange, 
starting at the index specified in the given ElementChange. The number of child 
views representing the removed elements specified are removed. 

    ec - the change information for the element this view is responsible for. This 
       should not be null if this method gets called 
    e - the change information from the associated document 
    f - the factory to use to build child views 

    Returns: whether or not the child views represent the child elements of the element this 
             view is responsible for. Some views create children that represent 
             a portion of the element they are responsible for, and should 
             return false. This information is used to determine if views in 
             the range of the added elements should be forwarded to or not 
*javax.swing.text.View.updateLayout(DocumentEvent.ElementChange,DocumentEvent,Shape)*

protected void updateLayout(
  javax.swing.event.DocumentEvent.ElementChange ec,
  javax.swing.event.DocumentEvent e,
  java.awt.Shape a)

Updates the layout in response to receiving notification of change from the 
model. This is implemented to call preferenceChanged to reschedule a new layout 
if the ElementChange record is not null. 

    ec - changes to the element this view is responsible for (may be null if there were 
       no changes) 
    e - the change information from the associated document 
    a - the current allocation of the view 

*javax.swing.text.View.viewToModel(float,float,Shape)*

public int viewToModel(
  float x,
  float y,
  java.awt.Shape a)

Provides a mapping from the view coordinate space to the logical coordinate 
space of the model. 

    x - the X coordinate >= 0 
    y - the Y coordinate >= 0 
    a - the allocated region in which to render 

    Returns: the location within the model that best represents the given point in the view 
             >= 0 
*javax.swing.text.View.viewToModel(float,float,Shape,Position.Bias[])*

public abstract int viewToModel(
  float x,
  float y,
  java.awt.Shape a,
  javax.swing.text.Position.Bias[] biasReturn)

Provides a mapping from the view coordinate space to the logical coordinate 
space of the model. The biasReturn argument will be filled in to indicate that 
the point given is closer to the next character in the model or the previous 
character in the model. 

    x - the X coordinate >= 0 
    y - the Y coordinate >= 0 
    a - the allocated region in which to render 

    Returns: the location within the model that best represents the given point in the view 
             >= 0. The biasReturn argument will be filled in to indicate that 
             the point given is closer to the next character in the model or 
             the previous character in the model. 

