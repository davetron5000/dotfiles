*javax.swing.JList* *JList* A component that allows the user to select one or more objects from a
 list.

public class JList
  extends    |javax.swing.JComponent|
  implements |javax.swing.Scrollable|
             |javax.accessibility.Accessible|

|javax.swing.JList_Description|
|javax.swing.JList_Fields|
|javax.swing.JList_Constructors|
|javax.swing.JList_Methods|

====================================================================================================================================================================================

*javax.swing.JList_Fields*
|int_javax.swing.JList.HORIZONTAL_WRAP|
|int_javax.swing.JList.VERTICAL|
|int_javax.swing.JList.VERTICAL_WRAP|

*javax.swing.JList_Constructors*
|javax.swing.JList()|Constructs a JList with an empty model.
|javax.swing.JList(ListModel)|Constructs a JList that displays the elements in the  specified, non-null model.
|javax.swing.JList(Object[])|Constructs a JList that displays the elements in  the specified array.
|javax.swing.JList(Vector<?>)|Constructs a JList that displays the elements in  the specified Vector.

*javax.swing.JList_Methods*
|javax.swing.JList.addListSelectionListener(ListSelectionListener)|Adds a listener to the list that's notified each time a change  to the selection occurs.
|javax.swing.JList.addSelectionInterval(int,int)|Sets the selection to be the union of the specified interval with current  selection.
|javax.swing.JList.clearSelection()|Clears the selection - after calling this method   isSelectionEmpty will return true.
|javax.swing.JList.createSelectionModel()|Returns an instance of DefaultListSelectionModel.
|javax.swing.JList.ensureIndexIsVisible(int)|Scrolls the viewport to make the specified cell completely visible.
|javax.swing.JList.fireSelectionValueChanged(int,int,boolean)|Notifies JList ListSelectionListeners that  the selection model has changed.
|javax.swing.JList.getAccessibleContext()|Gets the AccessibleContext associated with this JList.
|javax.swing.JList.getAnchorSelectionIndex()|Returns the first index argument from the most recent   addSelectionModel or setSelectionInterval call.
|javax.swing.JList.getCellBounds(int,int)|Returns the bounds of the specified range of items in JList  coordinates.
|javax.swing.JList.getCellRenderer()|Returns the object that renders the list items.
|javax.swing.JList.getDragEnabled()|Gets the dragEnabled property.
|javax.swing.JList.getFirstVisibleIndex()|Returns the index of the first visible cell.
|javax.swing.JList.getFixedCellHeight()|Returns the fixed cell height value -- the value specified by setting  the fixedCellHeight property,  rather than that calculated from the 
|javax.swing.JList.getFixedCellWidth()|Returns the fixed cell width value -- the value specified by setting  the fixedCellWidth property, rather than that calculated  from the lis
|javax.swing.JList.getLastVisibleIndex()|Returns the index of the last visible cell.
|javax.swing.JList.getLayoutOrientation()|Returns JList.VERTICAL if the layout is a single  column of cells, or JList.VERTICAL_WRAP if the layout  is "newspaper style" with the co
|javax.swing.JList.getLeadSelectionIndex()|Returns the second index argument from the most recent  addSelectionInterval or setSelectionInterval  call.
|javax.swing.JList.getListSelectionListeners()|Returns an array of all the ListSelectionListeners added  to this JList with addListSelectionListener().
|javax.swing.JList.getMaxSelectionIndex()|Returns the largest selected cell index.
|javax.swing.JList.getMinSelectionIndex()|Returns the smallest selected cell index.
|javax.swing.JList.getModel()|Returns the data model that holds the list of items displayed  by the JList component.
|javax.swing.JList.getNextMatch(String,int,Position.Bias)|Returns the next list element that starts with   a prefix.
|javax.swing.JList.getPreferredScrollableViewportSize()|Computes the size of the viewport needed to display   visibleRowCount  rows.
|javax.swing.JList.getPrototypeCellValue()|Returns the cell width of the "prototypical cell" -- a cell used  for the calculation of cell widths, because it has the same value  as 
|javax.swing.JList.getScrollableBlockIncrement(Rectangle,int,int)|Returns the distance to scroll to expose the next or previous block.
|javax.swing.JList.getScrollableTracksViewportHeight()|Returns true if this JList is displayed in a   JViewport and the viewport is taller than  JList's preferred height, or if th
|javax.swing.JList.getScrollableTracksViewportWidth()|Returns true if this JList is displayed in a   JViewport and the viewport is wider than  JList's preferred width; or if the  
|javax.swing.JList.getScrollableUnitIncrement(Rectangle,int,int)|Returns the distance to scroll to expose the next or previous  row (for vertical scrolling) or column (for horizon
|javax.swing.JList.getSelectedIndex()|Returns the first selected index; returns -1 if there is no  selected item.
|javax.swing.JList.getSelectedIndices()|Returns an array of all of the selected indices in increasing  order.
|javax.swing.JList.getSelectedValue()|Returns the first selected value, or null if the   selection is empty.
|javax.swing.JList.getSelectedValues()|Returns an array of the values for the selected cells.
|javax.swing.JList.getSelectionBackground()|Returns the background color for selected cells.
|javax.swing.JList.getSelectionForeground()|Returns the selection foreground color.
|javax.swing.JList.getSelectionMode()|Returns whether single-item or multiple-item selections are allowed.
|javax.swing.JList.getSelectionModel()|Returns the value of the current selection model.
|javax.swing.JList.getToolTipText(MouseEvent)|Overrides JComponent's getToolTipText  method in order to allow the renderer's tips to be used  if it has text set.
|javax.swing.JList.getUI()|Returns the look and feel (Lobject that renders this component.
|javax.swing.JList.getUIClassID()|Returns the suffix used to construct the name of the look and feel   (Lclass used to render this component.
|javax.swing.JList.getValueIsAdjusting()|Returns the value of the data model's isAdjusting property.
|javax.swing.JList.getVisibleRowCount()|Returns the preferred number of visible rows.
|javax.swing.JList.indexToLocation(int)|Returns the origin of the specified item in JList  coordinates.
|javax.swing.JList.isSelectedIndex(int)|Returns true if the specified index is selected.
|javax.swing.JList.isSelectionEmpty()|Returns true if nothing is selected.
|javax.swing.JList.locationToIndex(Point)|Convert a point in JList coordinates to the closest index  of the cell at that location.
|javax.swing.JList.paramString()|Returns a string representation of this JList.
|javax.swing.JList.removeListSelectionListener(ListSelectionListener)|Removes a listener from the list that's notified each time a  change to the selection occurs.
|javax.swing.JList.removeSelectionInterval(int,int)|Sets the selection to be the set difference of the specified interval  and the current selection.
|javax.swing.JList.setCellRenderer(ListCellRenderer)|Sets the delegate that's used to paint each cell in the list.
|javax.swing.JList.setDragEnabled(boolean)|Sets the dragEnabled property,  which must be true to enable  automatic drag handling (the first part of drag and drop)  on this compone
|javax.swing.JList.setFixedCellHeight(int)|Sets the height of every cell in the list.
|javax.swing.JList.setFixedCellWidth(int)|Sets the width of every cell in the list.
|javax.swing.JList.setLayoutOrientation(int)|Defines the way list cells are layed out.
|javax.swing.JList.setListData(Object[])|Constructs a ListModel from an array of objects and then  applies setModel to it.
|javax.swing.JList.setListData(Vector<?>)|Constructs a ListModel from a Vector and then  applies setModel to it.
|javax.swing.JList.setModel(ListModel)|Sets the model that represents the contents or "value" of the  list and clears the list selection after notifying  PropertyChangeListeners.
|javax.swing.JList.setPrototypeCellValue(Object)|Computes the fixedCellWidth and   fixedCellHeight properties  by configuring the cellRenderer to index equals  zero for the specif
|javax.swing.JList.setSelectedIndex(int)|Selects a single cell.
|javax.swing.JList.setSelectedIndices(int[])|Selects a set of cells.
|javax.swing.JList.setSelectedValue(Object,boolean)|Selects the specified object from the list.
|javax.swing.JList.setSelectionBackground(Color)|Sets the background color for selected cells.
|javax.swing.JList.setSelectionForeground(Color)|Sets the foreground color for selected cells.
|javax.swing.JList.setSelectionInterval(int,int)|Selects the specified interval.
|javax.swing.JList.setSelectionMode(int)|Determines whether single-item or multiple-item  selections are allowed.
|javax.swing.JList.setSelectionModel(ListSelectionModel)|Sets the selectionModel for the list to a  non-null ListSelectionModel  implementation.
|javax.swing.JList.setUI(ListUI)|Sets the look and feel (Lobject that renders this component.
|javax.swing.JList.setValueIsAdjusting(boolean)|Sets the data model's isAdjusting property to true,  so that a single event will be generated when all of the selection  events hav
|javax.swing.JList.setVisibleRowCount(int)|Sets the preferred number of rows in the list that can be displayed  without a scrollbar, as determined by the nearest  JViewport ancest
|javax.swing.JList.updateUI()|Resets the UI property with the value from the current look and feel.

*javax.swing.JList_Description*

A component that allows the user to select one or more objects from a list. A separate model, ListModel, represents the contents of the list. It's easy to display an array or 
vector of objects, using a JList constructor that builds a ListModel instance for you: 

// Create a JList that displays the strings in data[] 

String[] data = {"one", "two", "three", "four"}; JList dataList = new JList(data); 

// The value of the JList model property is an object that provides // a read-only view of the data. It was constructed automatically. 

for(int i = 0; i JList doesn't support scrolling directly. To create a scrolling list you make the JList the viewport view of a JScrollPane. For example: 

JScrollPane scrollPane = new JScrollPane(dataList); // Or in two steps: JScrollPane scrollPane = new JScrollPane(); scrollPane.getViewport().setView(dataList); 

By default the JList selection model allows any combination of items to be selected at a time, using the constant MULTIPLE_INTERVAL_SELECTION. The selection state is actually 
managed by a separate delegate object, an instance of ListSelectionModel. However JList provides convenient properties for managing the selection. 

String[] data = {"one", "two", "three", "four"}; JList dataList = new JList(data); 

dataList.setSelectedIndex(1); // select "two" dataList.getSelectedValue(); // returns "two" 

The contents of a JList can be dynamic, in other words, the list elements can change value and the size of the list can change after the JList has been created. The JList observes 
changes in its model with a swing.event.ListDataListener implementation. A correct implementation of ListModel notifies it's listeners each time a change occurs. The changes are 
characterized by a swing.event.ListDataEvent, which identifies the range of list indices that have been modified, added, or removed. Simple dynamic-content JList applications can 
use the DefaultListModel class to store list elements. This class implements the ListModel interface and provides the java.util.Vector API as well. Applications that need to 
provide custom ListModel implementations can subclass AbstractListModel, which provides basic ListDataListener support. For example: 

// This list model has about 2^16 elements. Enjoy scrolling. 

ListModel bigData = new AbstractListModel() { public int getSize() { return Short.MAX_VALUE; } public Object getElementAt(int index) { return "Index " + index; } }; 

JList bigDataList = new JList(bigData); 

// We don't want the JList implementation to compute the width // or height of all of the list cells, so we give it a string // that's as big as we'll need for any cell. It uses 
this to // compute values for the fixedCellWidth and fixedCellHeight // properties. 

bigDataList.setPrototypeCellValue("Index 1234567890"); 

JList uses a java.awt.Component, provided by a delegate called the cellRendererer, to paint the visible cells in the list. The cell renderer component is used like a "rubber 
stamp" to paint each visible row. Each time the JList needs to paint a cell it asks the cell renderer for the component, moves it into place using setBounds() and then draws it by 
calling its paint method. The default cell renderer uses a JLabel component to render the string value of each component. You can substitute your own cell renderer, using code 
like this: 

// Display an icon and a string for each object in the list. 

class MyCellRenderer extends JLabel implements ListCellRenderer { final static ImageIcon longIcon = new ImageIcon("long.gif"); final static ImageIcon shortIcon = new 
ImageIcon("short.gif"); 

// This is the only method defined by ListCellRenderer. // We just reconfigure the JLabel each time we're called. 

public Component getListCellRendererComponent( JList list, Object value, // value to display int index, // cell index boolean isSelected, // is the cell selected boolean 
cellHasFocus) // the list and the cell have the focus { String s = value.toString(); setText(s); setIcon((s.length() > 10) ? longIcon : shortIcon); if (isSelected) { 
setBackground(list.getSelectionBackground()); setForeground(list.getSelectionForeground()); } else { setBackground(list.getBackground()); setForeground(list.getForeground()); } 
setEnabled(list.isEnabled()); setFont(list.getFont()); setOpaque(true); return this; } } 

String[] data = {"one", "two", "three", "four"}; JList dataList = new JList(data); dataList.setCellRenderer(new MyCellRenderer()); 

JList doesn't provide any special support for handling double or triple (or N) mouse clicks however it's easy to handle them using a MouseListener. Use the JList method 
locationToIndex() to determine what cell was clicked. For example: 

final JList list = new JList(dataModel); MouseListener mouseListener = new MouseAdapter() { public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { int index = 
list.locationToIndex(e.getPoint()); System.out.println("Double clicked on Item " + index); } } }; list.addMouseListener(mouseListener); 

Note that in this example the dataList is final because it's referred to by the anonymous MouseListener class. 

Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between 
applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansTM has been added to the java.beans package. Please see 
(|java.beans.XMLEncoder|) . 

See How to Use Lists in The Java Tutorial for further documentation. Also see the article Advanced JList Programming in The Swing Connection. 



*int_javax.swing.JList.HORIZONTAL_WRAP*

Indicates "newspaper style" with the cells flowing horizontally then vertically. 


*int_javax.swing.JList.VERTICAL*

Indicates the default layout: one column of cells. 


*int_javax.swing.JList.VERTICAL_WRAP*

Indicates "newspaper style" layout with the cells flowing vertically then horizontally. 



*javax.swing.JList()*

public JList()

Constructs a JList with an empty model. 


*javax.swing.JList(ListModel)*

public JList(javax.swing.ListModel dataModel)

Constructs a JList that displays the elements in the specified, non-null model. All JList constructors delegate to this one. 

    dataModel - the data model for this list 

*javax.swing.JList(Object[])*

public JList(java.lang.Object[] listData)

Constructs a JList that displays the elements in the specified array. This constructor just delegates to the ListModel constructor. 

    listData - the array of Objects to be loaded into the data model 

*javax.swing.JList(Vector<?>)*

public JList(java.util.Vector<?> listData)

Constructs a JList that displays the elements in the specified Vector. This constructor just delegates to the ListModel constructor. 

    listData - the Vector to be loaded into the data model 

*javax.swing.JList.addListSelectionListener(ListSelectionListener)*

public void addListSelectionListener(javax.swing.event.ListSelectionListener listener)

Adds a listener to the list that's notified each time a change to the selection occurs. Listeners added directly to the JList will have their ListSelectionEvent.getSource() == 
this JList (instead of the ListSelectionModel). 


    listener - the ListSelectionListener to add 

*javax.swing.JList.addSelectionInterval(int,int)*

public void addSelectionInterval(
  int anchor,
  int lead)

Sets the selection to be the union of the specified interval with current selection. Both the anchor and lead indices are included. It's not necessary for anchor to be less than 
lead. This is a convenience method that just delegates to the selectionModel. The DefaultListSelectionModel implementation will do nothing if either anchor or lead are -1. If 
anchor or lead are less than -1, IndexOutOfBoundsException is thrown. 


    anchor - the first index to add to the selection 
    lead - the last index to add to the selection 

*javax.swing.JList.clearSelection()*

public void clearSelection()

Clears the selection - after calling this method isSelectionEmpty will return true. This is a convenience method that just delegates to the selectionModel. 



*javax.swing.JList.createSelectionModel()*

protected |javax.swing.ListSelectionModel| createSelectionModel()

Returns an instance of DefaultListSelectionModel. This method is used by the constructor to initialize the selectionModel property. 



    Returns: the ListSelectionModel used by this JList. 

*javax.swing.JList.ensureIndexIsVisible(int)*

public void ensureIndexIsVisible(int index)

Scrolls the viewport to make the specified cell completely visible. Note, for this method to work, the JList must be displayed within a JViewport. 


    index - the index of the cell to make visible 

*javax.swing.JList.fireSelectionValueChanged(int,int,boolean)*

protected void fireSelectionValueChanged(
  int firstIndex,
  int lastIndex,
  boolean isAdjusting)

Notifies JList ListSelectionListeners that the selection model has changed. It's used to forward ListSelectionEvents from the selectionModel to the ListSelectionListeners added 
directly to the JList. 


    firstIndex - the first selected index 
    lastIndex - the last selected index 
    isAdjusting - true if multiple changes are being made 

*javax.swing.JList.getAccessibleContext()*

public |javax.accessibility.AccessibleContext| getAccessibleContext()

Gets the AccessibleContext associated with this JList. For JLists, the AccessibleContext takes the form of an AccessibleJList. A new AccessibleJList instance is created if 
necessary. 



    Returns: an AccessibleJList that serves as the AccessibleContext of this JList 

*javax.swing.JList.getAnchorSelectionIndex()*

public int getAnchorSelectionIndex()

Returns the first index argument from the most recent addSelectionModel or setSelectionInterval call. This is a convenience method that just delegates to the selectionModel. 



    Returns: the index that most recently anchored an interval selection 

*javax.swing.JList.getCellBounds(int,int)*

public |java.awt.Rectangle| getCellBounds(
  int index0,
  int index1)

Returns the bounds of the specified range of items in JList coordinates. Returns null if index isn't valid. 


    index0 - the index of the first JList cell in the range 
    index1 - the index of the last JList cell in the range 

    Returns: the bounds of the indexed cells in pixels 

*javax.swing.JList.getCellRenderer()*

public |javax.swing.ListCellRenderer| getCellRenderer()

Returns the object that renders the list items. 



    Returns: the ListCellRenderer 

*javax.swing.JList.getDragEnabled()*

public boolean getDragEnabled()

Gets the dragEnabled property. 



    Returns: the value of the dragEnabled property 

*javax.swing.JList.getFirstVisibleIndex()*

public int getFirstVisibleIndex()

Returns the index of the first visible cell. The cell considered to be "first" depends on the list's componentOrientation property. If the orientation is horizontal left-to-right, 
then the first visible cell is in the list's upper-left corner. If the orientation is horizontal right-to-left, then the first visible cell is in the list's upper-right corner. If 
nothing is visible or the list is empty, a -1 is returned. Note that the returned cell may only be partially visible. 



    Returns: the index of the first visible cell 

*javax.swing.JList.getFixedCellHeight()*

public int getFixedCellHeight()

Returns the fixed cell height value -- the value specified by setting the fixedCellHeight property, rather than that calculated from the list elements. 



    Returns: the fixed cell height, in pixels 

*javax.swing.JList.getFixedCellWidth()*

public int getFixedCellWidth()

Returns the fixed cell width value -- the value specified by setting the fixedCellWidth property, rather than that calculated from the list elements. 



    Returns: the fixed cell width 

*javax.swing.JList.getLastVisibleIndex()*

public int getLastVisibleIndex()

Returns the index of the last visible cell. The cell considered to be "last" depends on the list's componentOrientation property. If the orientation is horizontal left-to-right, 
then the last visible cell is in the JList's lower-right corner. If the orientation is horizontal right-to-left, then the last visible cell is in the JList's lower-left corner. If 
nothing is visible or the list is empty, a -1 is returned. Note that the returned cell may only be partially visible. 



    Returns: the index of the last visible cell 

*javax.swing.JList.getLayoutOrientation()*

public int getLayoutOrientation()

Returns JList.VERTICAL if the layout is a single column of cells, or JList.VERTICAL_WRAP if the layout is "newspaper style" with the content flowing vertically then horizontally 
or JList.HORIZONTAL_WRAP if the layout is "newspaper style" with the content flowing horizontally then vertically. 



    Returns: the value of the layoutOrientation property 

*javax.swing.JList.getLeadSelectionIndex()*

public int getLeadSelectionIndex()

Returns the second index argument from the most recent addSelectionInterval or setSelectionInterval call. This is a convenience method that just delegates to the selectionModel. 



    Returns: the index that most recently ended a interval selection 

*javax.swing.JList.getListSelectionListeners()*

public |javax.swing.event.ListSelectionListener|[] getListSelectionListeners()

Returns an array of all the ListSelectionListeners added to this JList with addListSelectionListener(). 



    Returns: all of the ListSelectionListeners added or an empty array if no listeners have been added 

*javax.swing.JList.getMaxSelectionIndex()*

public int getMaxSelectionIndex()

Returns the largest selected cell index. This is a convenience method that just delegates to the selectionModel. 



    Returns: the largest selected cell index 

*javax.swing.JList.getMinSelectionIndex()*

public int getMinSelectionIndex()

Returns the smallest selected cell index. This is a convenience method that just delegates to the selectionModel. 



    Returns: the smallest selected cell index 

*javax.swing.JList.getModel()*

public |javax.swing.ListModel| getModel()

Returns the data model that holds the list of items displayed by the JList component. 



    Returns: the ListModel that provides the displayed list of items 

*javax.swing.JList.getNextMatch(String,int,Position.Bias)*

public int getNextMatch(
  java.lang.String prefix,
  int startIndex,
  javax.swing.text.Position.Bias bias)

Returns the next list element that starts with a prefix. 


    prefix - the string to test for a match 
    startIndex - the index for starting the search 
    bias - the search direction, either Position.Bias.Forward or Position.Bias.Backward. 

    Returns: the index of the next list element that starts with the prefix; otherwise -1 

*javax.swing.JList.getPreferredScrollableViewportSize()*

public |java.awt.Dimension| getPreferredScrollableViewportSize()

Computes the size of the viewport needed to display visibleRowCount rows. This is trivial if fixedCellWidth and fixedCellHeight were specified. Note that they can be specified 
implicitly with the prototypeCellValue property. If fixedCellWidth wasn't specified, it's computed by finding the widest list element. If fixedCellHeight wasn't specified then we 
resort to heuristics: 

If the model isn't empty we just multiply the height of the first row by visibleRowCount. 

If the model is empty, (JList.getModel().getSize() == 0), then we just allocate 16 pixels per visible row, and 256 pixels for the width (unless fixedCellWidth was set), and hope 
for the best. 

If the layout orientation is not VERTICAL, than this will return the value from getPreferredSize. The current ListUI is expected to override getPreferredSize to return an 
appropriate value. 



    Returns: a dimension containing the size of the viewport needed to display visibleRowCount rows 

*javax.swing.JList.getPrototypeCellValue()*

public |java.lang.Object| getPrototypeCellValue()

Returns the cell width of the "prototypical cell" -- a cell used for the calculation of cell widths, because it has the same value as all other list items. 



    Returns: the value of the prototypeCellValue property 

*javax.swing.JList.getScrollableBlockIncrement(Rectangle,int,int)*

public int getScrollableBlockIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Returns the distance to scroll to expose the next or previous block. For vertical scrolling we are using the follows rules: 

if scrolling down (direction is greater than 0), the last visible element should become the first completely visible element if scrolling up, the first visible element should 
become the last completely visible element visibleRect.height if the list is empty 

For horizontal scrolling if the list is layed out horizontally (the orientation is VERTICAL_WRAP or HORIZONTAL_WRAP): 

if scrolling right (direction is greater than 0), the last visible element should become the first completely visible element if scrolling left, the first visible element should 
become the last completely visible element visibleRect.width if the list is empty 

Return visibleRect.width if the list is layed out vertically. 

Note that the value of visibleRect must be the equal to this.getVisibleRect(). 


    visibleRect - the visible rectangle 
    orientation - HORIZONTAL or VERTICAL 
    direction - if 0, then scroll DOWN 

    Returns: the block increment amount. 

*javax.swing.JList.getScrollableTracksViewportHeight()*

public boolean getScrollableTracksViewportHeight()

Returns true if this JList is displayed in a JViewport and the viewport is taller than JList's preferred height, or if the layout orientation is VERTICAL_WRAP and the number of 
visible rows is JViewport is itself embedded in a JScrollPane. 



    Returns: true if viewport is taller than Jlist's preferred height, otherwise false 

*javax.swing.JList.getScrollableTracksViewportWidth()*

public boolean getScrollableTracksViewportWidth()

Returns true if this JList is displayed in a JViewport and the viewport is wider than JList's preferred width; or if the layout orientation is HORIZONTAL_WRAP and the visible row 
count is JViewport is itself embedded in a JScrollPane. 



    Returns: true if viewport is wider than the JList's preferred width, otherwise false 

*javax.swing.JList.getScrollableUnitIncrement(Rectangle,int,int)*

public int getScrollableUnitIncrement(
  java.awt.Rectangle visibleRect,
  int orientation,
  int direction)

Returns the distance to scroll to expose the next or previous row (for vertical scrolling) or column (for horizontal scrolling). 

For horizontal scrolling if the list is layed out vertically (the orientation is VERTICAL) than the lists font size or 1 is returned if the font is null is used. 

Note that the value of visibleRect must be the equal to this.getVisibleRect(). 


    visibleRect - the visible rectangle 
    orientation - HORIZONTAL or VERTICAL 
    direction - if 0, then scroll DOWN 

    Returns: the distance, in pixels, to scroll to expose the next or previous unit 

*javax.swing.JList.getSelectedIndex()*

public int getSelectedIndex()

Returns the first selected index; returns -1 if there is no selected item. 



    Returns: the value of getMinSelectionIndex 

*javax.swing.JList.getSelectedIndices()*

public int[] getSelectedIndices()

Returns an array of all of the selected indices in increasing order. 



    Returns: all of the selected indices, in increasing order 

*javax.swing.JList.getSelectedValue()*

public |java.lang.Object| getSelectedValue()

Returns the first selected value, or null if the selection is empty. 



    Returns: the first selected value 

*javax.swing.JList.getSelectedValues()*

public |java.lang.Object|[] getSelectedValues()

Returns an array of the values for the selected cells. The returned values are sorted in increasing index order. 



    Returns: the selected values or an empty list if nothing is selected 

*javax.swing.JList.getSelectionBackground()*

public |java.awt.Color| getSelectionBackground()

Returns the background color for selected cells. 



    Returns: the Color used for the background of selected list items 

*javax.swing.JList.getSelectionForeground()*

public |java.awt.Color| getSelectionForeground()

Returns the selection foreground color. 



    Returns: the Color object for the foreground property 

*javax.swing.JList.getSelectionMode()*

public int getSelectionMode()

Returns whether single-item or multiple-item selections are allowed. 



    Returns: the value of the selectionMode property 

*javax.swing.JList.getSelectionModel()*

public |javax.swing.ListSelectionModel| getSelectionModel()

Returns the value of the current selection model. The selection model handles the task of making single selections, selections of contiguous ranges, and non-contiguous selections. 



    Returns: the ListSelectionModel that implements list selections 

*javax.swing.JList.getToolTipText(MouseEvent)*

public |java.lang.String| getToolTipText(java.awt.event.MouseEvent event)

Overrides JComponent's getToolTipText method in order to allow the renderer's tips to be used if it has text set. 

Note: For JList to properly display tooltips of its renderers JList must be a registered component with the ToolTipManager. This is done automatically in the constructor, but if 
at a later point JList is told setToolTipText(null) it will unregister the list component, and no tips from renderers will display anymore. 



*javax.swing.JList.getUI()*

public |javax.swing.plaf.ListUI| getUI()

Returns the look and feel (Lobject that renders this component. 



    Returns: the ListUI object that renders this component 

*javax.swing.JList.getUIClassID()*

public |java.lang.String| getUIClassID()

Returns the suffix used to construct the name of the look and feel (Lclass used to render this component. 



    Returns: the string "ListUI" 

*javax.swing.JList.getValueIsAdjusting()*

public boolean getValueIsAdjusting()

Returns the value of the data model's isAdjusting property. This value is true if multiple changes are being made. 



    Returns: true if multiple selection-changes are occurring, as when the mouse is being dragged over the list 

*javax.swing.JList.getVisibleRowCount()*

public int getVisibleRowCount()

Returns the preferred number of visible rows. 



    Returns: an integer indicating the preferred number of rows to display without using a scroll bar 

*javax.swing.JList.indexToLocation(int)*

public |java.awt.Point| indexToLocation(int index)

Returns the origin of the specified item in JList coordinates. Returns null if index isn't valid. 


    index - the index of the JList cell 

    Returns: the origin of the index'th cell 

*javax.swing.JList.isSelectedIndex(int)*

public boolean isSelectedIndex(int index)

Returns true if the specified index is selected. This is a convenience method that just delegates to the selectionModel. 


    index - index to be queried for selection state 

    Returns: true if the specified index is selected 

*javax.swing.JList.isSelectionEmpty()*

public boolean isSelectionEmpty()

Returns true if nothing is selected. This is a convenience method that just delegates to the selectionModel. 



    Returns: true if nothing is selected 

*javax.swing.JList.locationToIndex(Point)*

public int locationToIndex(java.awt.Point location)

Convert a point in JList coordinates to the closest index of the cell at that location. To determine if the cell actually contains the specified location use a combination of this 
method and getCellBounds. Returns -1 if the model is empty. 


    location - the coordinates of the cell, relative to JList 

    Returns: an integer -- the index of the cell at the given location, or -1. 

*javax.swing.JList.paramString()*

protected |java.lang.String| paramString()

Returns a string representation of this JList. This method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between 
implementations. The returned string may be empty but may not be null. 



    Returns: a string representation of this JList. 

*javax.swing.JList.removeListSelectionListener(ListSelectionListener)*

public void removeListSelectionListener(javax.swing.event.ListSelectionListener listener)

Removes a listener from the list that's notified each time a change to the selection occurs. 


    listener - the ListSelectionListener to remove 

*javax.swing.JList.removeSelectionInterval(int,int)*

public void removeSelectionInterval(
  int index0,
  int index1)

Sets the selection to be the set difference of the specified interval and the current selection. Both the index0 and index1 indices are removed. It's not necessary for index0 to 
be less than index1. This is a convenience method that just delegates to the selectionModel. The DefaultListSelectionModel implementation will do nothing if either index0 or 
index1 are -1. If index0 or index1 are less than -1, IndexOutOfBoundsException is thrown. 


    index0 - the first index to remove from the selection 
    index1 - the last index to remove from the selection 

*javax.swing.JList.setCellRenderer(ListCellRenderer)*

public void setCellRenderer(javax.swing.ListCellRenderer cellRenderer)

Sets the delegate that's used to paint each cell in the list. If prototypeCellValue was set then the fixedCellWidth and fixedCellHeight properties are set as well. Only one 
PropertyChangeEvent is generated however - for the cellRenderer property. 

The default value of this property is provided by the ListUI delegate, i.e. by the look and feel implementation. 

To see an example which sets the cell renderer, see the class description above. 

This is a JavaBeans bound property. 


    cellRenderer - the ListCellRenderer that paints list cells 

*javax.swing.JList.setDragEnabled(boolean)*

public void setDragEnabled(boolean b)

Sets the dragEnabled property, which must be true to enable automatic drag handling (the first part of drag and drop) on this component. The transferHandler property needs to be 
set to a non-null value for the drag to do anything. The default value of the dragEnabled property is false. 



When automatic drag handling is enabled, most look and feels begin a drag-and-drop operation whenever the user presses the mouse button over a selection and then moves the mouse a 
few pixels. Setting this property to true can therefore have a subtle effect on how selections behave. 



Some look and feels might not support automatic drag and drop; they will ignore this property. You can work around such look and feels by modifying the component to directly call 
the exportAsDrag method of a TransferHandler. 


    b - the value to set the dragEnabled property to 

*javax.swing.JList.setFixedCellHeight(int)*

public void setFixedCellHeight(int height)

Sets the height of every cell in the list. If height is -1, cell heights are computed by applying getPreferredSize to the cellRenderer component for each list element. 

The default value of this property is -1. 

This is a JavaBeans bound property. 


    height - an integer giving the height, in pixels, for all cells in this list 

*javax.swing.JList.setFixedCellWidth(int)*

public void setFixedCellWidth(int width)

Sets the width of every cell in the list. If width is -1, cell widths are computed by applying getPreferredSize to the cellRenderer component for each list element. 

The default value of this property is -1. 

This is a JavaBeans bound property. 


    width - the width, in pixels, for all cells in this list 

*javax.swing.JList.setLayoutOrientation(int)*

public void setLayoutOrientation(int layoutOrientation)

Defines the way list cells are layed out. Consider a JList with four cells, this can be layed out in one of the following ways: 

0 1 2 3 



0 1 2 3 



0 2 1 3 

These correspond to the following values: 

ValueDescription JList.VERTICAL The cells should be layed out vertically in one column. JList.HORIZONTAL_WRAP The cells should be layed out horizontally, wrapping to a new row as 
necessary. The number of rows to use will either be defined by getVisibleRowCount if > 0, otherwise the number of rows will be determined by the width of the JList. 
JList.VERTICAL_WRAP The cells should be layed out vertically, wrapping to a new column as necessary. The number of rows to use will either be defined by getVisibleRowCount if > 0, 
otherwise the number of rows will be determined by the height of the JList. 

The default value of this property is JList.VERTICAL. 

This will throw an IllegalArgumentException if layoutOrientation is not one of JList.HORIZONTAL_WRAP or JList.VERTICAL or JList.VERTICAL_WRAP 


    layoutOrientation - New orientation, one of JList.HORIZONTAL_WRAP, JList.VERTICAL or JList.VERTICAL_WRAP. 

*javax.swing.JList.setListData(Object[])*

public void setListData(java.lang.Object[] listData)

Constructs a ListModel from an array of objects and then applies setModel to it. 


    listData - an array of Objects containing the items to display in the list 

*javax.swing.JList.setListData(Vector<?>)*

public void setListData(java.util.Vector<?> listData)

Constructs a ListModel from a Vector and then applies setModel to it. 


    listData - a Vector containing the items to display in the list 

*javax.swing.JList.setModel(ListModel)*

public void setModel(javax.swing.ListModel model)

Sets the model that represents the contents or "value" of the list and clears the list selection after notifying PropertyChangeListeners. 

This is a JavaBeans bound property. 


    model - the ListModel that provides the list of items for display 

*javax.swing.JList.setPrototypeCellValue(Object)*

public void setPrototypeCellValue(java.lang.Object prototypeCellValue)

Computes the fixedCellWidth and fixedCellHeight properties by configuring the cellRenderer to index equals zero for the specified value and then computing the renderer component's 
preferred size. These properties are useful when the list is too long to allow JList to compute the width/height of each cell and there is a single cell value that is known to 
occupy as much space as any of the others. 

Note that we do set the fixedCellWidth and fixedCellHeight properties here but only a prototypeCellValue PropertyChangeEvent is fired. 

To see an example which sets this property, see the class description above. 

The default value of this property is null. 

This is a JavaBeans bound property. 


    prototypeCellValue - the value on which to base fixedCellWidth and fixedCellHeight 

*javax.swing.JList.setSelectedIndex(int)*

public void setSelectedIndex(int index)

Selects a single cell. 


    index - the index of the one cell to select 

*javax.swing.JList.setSelectedIndices(int[])*

public void setSelectedIndices(int[] indices)

Selects a set of cells. 


    indices - an array of the indices of the cells to select 

*javax.swing.JList.setSelectedValue(Object,boolean)*

public void setSelectedValue(
  java.lang.Object anObject,
  boolean shouldScroll)

Selects the specified object from the list. 


    anObject - the object to select 
    shouldScroll - true if the list should scroll to display the selected object, if one exists; otherwise false 

*javax.swing.JList.setSelectionBackground(Color)*

public void setSelectionBackground(java.awt.Color selectionBackground)

Sets the background color for selected cells. Cell renderers can use this color to the fill selected cells. 

The default value of this property is defined by the look and feel implementation. 

This is a JavaBeans bound property. 


    selectionBackground - the Color to use for the background of selected cells 

*javax.swing.JList.setSelectionForeground(Color)*

public void setSelectionForeground(java.awt.Color selectionForeground)

Sets the foreground color for selected cells. Cell renderers can use this color to render text and graphics for selected cells. 

The default value of this property is defined by the look and feel implementation. 

This is a JavaBeans bound property. 


    selectionForeground - the Color to use in the foreground for selected list items 

*javax.swing.JList.setSelectionInterval(int,int)*

public void setSelectionInterval(
  int anchor,
  int lead)

Selects the specified interval. Both the anchor and lead indices are included. It's not necessary for anchor to be less than lead. This is a convenience method that just delegates 
to the selectionModel. The DefaultListSelectionModel implementation will do nothing if either anchor or lead are -1. If anchor or lead are less than -1, IndexOutOfBoundsException 
is thrown. 


    anchor - the first index to select 
    lead - the last index to select 

*javax.swing.JList.setSelectionMode(int)*

public void setSelectionMode(int selectionMode)

Determines whether single-item or multiple-item selections are allowed. The following selectionMode values are allowed: 

ListSelectionModel.SINGLE_SELECTION Only one list index can be selected at a time. In this mode the setSelectionInterval and addSelectionInterval methods are equivalent, and only 
the second index argument is used. ListSelectionModel.SINGLE_INTERVAL_SELECTION One contiguous index interval can be selected at a time. In this mode setSelectionInterval and 
addSelectionInterval are equivalent. ListSelectionModel.MULTIPLE_INTERVAL_SELECTION In this mode, there's no restriction on what can be selected. This is the default. 


    selectionMode - an integer specifying the type of selections that are permissible 

*javax.swing.JList.setSelectionModel(ListSelectionModel)*

public void setSelectionModel(javax.swing.ListSelectionModel selectionModel)

Sets the selectionModel for the list to a non-null ListSelectionModel implementation. The selection model handles the task of making single selections, selections of contiguous 
ranges, and non-contiguous selections. 

This is a JavaBeans bound property. 


    selectionModel - the ListSelectionModel that implements the selections 

*javax.swing.JList.setUI(ListUI)*

public void setUI(javax.swing.plaf.ListUI ui)

Sets the look and feel (Lobject that renders this component. 


    ui - the ListUI Lobject 

*javax.swing.JList.setValueIsAdjusting(boolean)*

public void setValueIsAdjusting(boolean b)

Sets the data model's isAdjusting property to true, so that a single event will be generated when all of the selection events have finished (for example, when the mouse is being 
dragged over the list in selection mode). 


    b - the boolean value for the property value 

*javax.swing.JList.setVisibleRowCount(int)*

public void setVisibleRowCount(int visibleRowCount)

Sets the preferred number of rows in the list that can be displayed without a scrollbar, as determined by the nearest JViewport ancestor, if any. The value of this property only 
affects the value of the JList's preferredScrollableViewportSize. 

The default value of this property is 8. 

This is a JavaBeans bound property. 


    visibleRowCount - an integer specifying the preferred number of visible rows 

*javax.swing.JList.updateUI()*

public void updateUI()

Resets the UI property with the value from the current look and feel. 




