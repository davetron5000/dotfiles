*java.awt.font.TextLayout* *TextLayout* TextLayout is an immutable graphical rep

public final class TextLayout
  extends    |java.lang.Object|
  implements |java.lang.Cloneable|

|java.awt.font.TextLayout_Description|
|java.awt.font.TextLayout_Fields|
|java.awt.font.TextLayout_Constructors|
|java.awt.font.TextLayout_Methods|

================================================================================

*java.awt.font.TextLayout_Fields*
|java.awt.font.TextLayout.CaretPolicy_java.awt.font.TextLayout.DEFAULT_CARET_POLICY|

*java.awt.font.TextLayout_Constructors*
|java.awt.font.TextLayout(AttributedCharacterIterator,FontRenderContext)|Constr
|java.awt.font.TextLayout(String,Font,FontRenderContext)|Constructs a TextLayou
|java.awt.font.TextLayout(String,Map,FontRenderContext)|Constructs a TextLayout

*java.awt.font.TextLayout_Methods*
|java.awt.font.TextLayout.clone()|Creates a copy of this TextLayout.
|java.awt.font.TextLayout.draw(Graphics2D,float,float)|Renders this TextLayout 
|java.awt.font.TextLayout.equals(Object)|Returns true if the specified Object i
|java.awt.font.TextLayout.equals(TextLayout)|Returns true if the two layouts ar
|java.awt.font.TextLayout.getAdvance()|Returns the advance of this TextLayout.
|java.awt.font.TextLayout.getAscent()|Returns the ascent of this TextLayout.
|java.awt.font.TextLayout.getBaseline()|Returns the baseline for this TextLayou
|java.awt.font.TextLayout.getBaselineOffsets()|Returns the offsets array for th
|java.awt.font.TextLayout.getBlackBoxBounds(int,int)|Returns the black box boun
|java.awt.font.TextLayout.getBounds()|Returns the bounds of this TextLayout.
|java.awt.font.TextLayout.getCaretInfo(TextHitInfo)|Returns information about t
|java.awt.font.TextLayout.getCaretInfo(TextHitInfo,Rectangle2D)|Returns informa
|java.awt.font.TextLayout.getCaretShape(TextHitInfo)|Returns a Shape representi
|java.awt.font.TextLayout.getCaretShape(TextHitInfo,Rectangle2D)|Returns aShape
|java.awt.font.TextLayout.getCaretShapes(int)|Returns two paths corresponding t
|java.awt.font.TextLayout.getCaretShapes(int,Rectangle2D)|Returns two paths cor
|java.awt.font.TextLayout.getCaretShapes(int,Rectangle2D,TextLayout.CaretPolicy)|
|java.awt.font.TextLayout.getCharacterCount()|Returns the number of characters 
|java.awt.font.TextLayout.getCharacterLevel(int)|Returns the level of the chara
|java.awt.font.TextLayout.getDescent()|Returns the descent of this TextLayout.
|java.awt.font.TextLayout.getJustifiedLayout(float)|Creates a copy of this Text
|java.awt.font.TextLayout.getLeading()|Returns the leading of the TextLayout.
|java.awt.font.TextLayout.getLogicalHighlightShape(int,int)|Returns a Shape enc
|java.awt.font.TextLayout.getLogicalHighlightShape(int,int,Rectangle2D)|Returns
|java.awt.font.TextLayout.getLogicalRangesForVisualSelection(TextHitInfo,TextHitInfo)|
|java.awt.font.TextLayout.getNextLeftHit(int)|Returns the hit for the next care
|java.awt.font.TextLayout.getNextLeftHit(int,TextLayout.CaretPolicy)|Returns th
|java.awt.font.TextLayout.getNextLeftHit(TextHitInfo)|Returns the hit for the n
|java.awt.font.TextLayout.getNextRightHit(int)|Returns the hit for the next car
|java.awt.font.TextLayout.getNextRightHit(int,TextLayout.CaretPolicy)|Returns t
|java.awt.font.TextLayout.getNextRightHit(TextHitInfo)|Returns the hit for the 
|java.awt.font.TextLayout.getOutline(AffineTransform)|Returns a Shape represent
|java.awt.font.TextLayout.getVisibleAdvance()|Returns the advance of this TextL
|java.awt.font.TextLayout.getVisualHighlightShape(TextHitInfo,TextHitInfo)|Retu
|java.awt.font.TextLayout.getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)|
|java.awt.font.TextLayout.getVisualOtherHit(TextHitInfo)|Returns the hit on the
|java.awt.font.TextLayout.handleJustify(float)|Justify this layout.
|java.awt.font.TextLayout.hashCode()|Returns the hash code of this TextLayout.
|java.awt.font.TextLayout.hitTestChar(float,float)|Returns a TextHitInfo corres
|java.awt.font.TextLayout.hitTestChar(float,float,Rectangle2D)|Returns a TextHi
|java.awt.font.TextLayout.isLeftToRight()|Returns true if this TextLayout has  
|java.awt.font.TextLayout.isVertical()|Returns true if this TextLayout is verti
|java.awt.font.TextLayout.toString()|Returns debugging information for this Tex

*java.awt.font.TextLayout_Description*

TextLayout is an immutable graphical representation of styled character data. 

It provides the following capabilities: 

implicit bidirectional analysis and reordering, cursor positioning and 
movement, including split cursors for mixed directional text, highlighting, 
including both logical and visual highlighting for mixed directional text, 
multiple baselines (roman, hanging, and centered), hit testing, justification, 
default font substitution, metric information such as ascent, descent, and 
advance, and rendering 

A TextLayout object can be rendered using its draw method. 

TextLayout can be constructed either directly or through the use of a 
(|java.awt.font.LineBreakMeasurer|) . When constructed directly, the source 
text represents a single paragraph. LineBreakMeasurer allows styled text to be 
broken into lines that fit within a particular width. See the LineBreakMeasurer 
documentation for more information. 

TextLayout construction logically proceeds as follows: 

paragraph attributes are extracted and examined, text is analyzed for 
bidirectional reordering, and reordering information is computed if needed, 
text is segmented into style runs fonts are chosen for style runs, first by 
using a font if the attribute (|java.awt.font.TextAttribute|) is present, 
otherwise by computing a default font using the attributes that have been 
defined if text is on multiple baselines, the runs or subruns are further 
broken into subruns sharing a common baseline, glyphvectors are generated for 
each run using the chosen font, final bidirectional reordering is performed on 
the glyphvectors 

All graphical information returned from a TextLayout object's methods is 
relative to the origin of the TextLayout, which is the intersection of the 
TextLayout object's baseline with its left edge. Also, coordinates passed into 
a TextLayout object's methods are assumed to be relative to the TextLayout 
object's origin. Clients usually need to translate between a TextLayout 
object's coordinate system and the coordinate system in another object (such as 
a Graphics(|java.awt.Graphics|) object). 

TextLayout objects are constructed from styled text, but they do not retain a 
reference to their source text. Thus, changes in the text previously used to 
generate a TextLayout do not affect the TextLayout. 

Three methods on a TextLayout object (getNextRightHit, getNextLeftHit, and 
hitTestChar) return instances of (|java.awt.font.TextHitInfo|) . The offsets 
contained in these TextHitInfo objects are relative to the start of the 
TextLayout, not to the text used to create the TextLayout. Similarly, 
TextLayout methods that accept TextHitInfo instances as parameters expect the 
TextHitInfo object's offsets to be relative to the TextLayout, not to any 
underlying text storage model. 

Examples: Constructing and drawing a TextLayout and its bounding rectangle: 

Graphics2D g = ...; Point2D loc = ...; Font font = 
Font.getFont("Helvetica-bold-italic"); FontRenderContext frc = 
g.getFontRenderContext(); TextLayout layout = new TextLayout("This is a 
string", font, frc); layout.draw(g, (float)loc.getX(), (float)loc.getY()); 

Rectangle2D bounds = layout.getBounds(); 
bounds.setRect(bounds.getX()+loc.getX(), bounds.getY()+loc.getY(), 
bounds.getWidth(), bounds.getHeight()); g.draw(bounds); 



Hit-testing a TextLayout (determining which character is at a particular 
graphical location): 

Point2D click = ...; TextHitInfo hit = layout.hitTestChar( (float) 
(click.getX() - loc.getX()), (float) (click.getY() - loc.getY())); 



Responding to a right-arrow key press: 

int insertionIndex = ...; TextHitInfo next = 
layout.getNextRightHit(insertionIndex); if (next != null) { // translate 
graphics to origin of layout on screen g.translate(loc.getX(), loc.getY()); 
Shape[] carets = layout.getCaretShapes(next.getInsertionIndex()); 
g.draw(carets[0]); if (carets[1] != null) { g.draw(carets[1]); } } 

Drawing a selection range corresponding to a substring in the source text. The 
selected area may not be visually contiguous: 

// selStart, selLimit should be relative to the layout, // not to the source 
text 

int selStart = ..., selLimit = ...; Color selectionColor = ...; Shape selection 
= layout.getLogicalHighlightShape(selStart, selLimit); // selection may consist 
of disjoint areas // graphics is assumed to be tranlated to origin of layout 
g.setColor(selectionColor); g.fill(selection); 

Drawing a visually contiguous selection range. The selection range may 
correspond to more than one substring in the source text. The ranges of the 
corresponding source text substrings can be obtained with 
getLogicalRangesForVisualSelection(): 

TextHitInfo selStart = ..., selLimit = ...; Shape selection = 
layout.getVisualHighlightShape(selStart, selLimit); g.setColor(selectionColor); 
g.fill(selection); int[] ranges = getLogicalRangesForVisualSelection(selStart, 
selLimit); // ranges[0], ranges[1] is the first selection range, // ranges[2], 
ranges[3] is the second selection range, etc. 




*java.awt.font.TextLayout.CaretPolicy_java.awt.font.TextLayout.DEFAULT_CARET_POLICY*

TextLayout is an immutable graphical representation of styled character data. 

It provides the following capabilities: 

implicit bidirectional analysis and reordering, cursor positioning and 
movement, including split cursors for mixed directional text, highlighting, 
including both logical and visual highlighting for mixed directional text, 
multiple baselines (roman, hanging, and centered), hit testing, justification, 
default font substitution, metric information such as ascent, descent, and 
advance, and rendering 

A TextLayout object can be rendered using its draw method. 

TextLayout can be constructed either directly or through the use of a 
(|java.awt.font.LineBreakMeasurer|) . When constructed directly, the source 
text represents a single paragraph. LineBreakMeasurer allows styled text to be 
broken into lines that fit within a particular width. See the LineBreakMeasurer 
documentation for more information. 

TextLayout construction logically proceeds as follows: 

paragraph attributes are extracted and examined, text is analyzed for 
bidirectional reordering, and reordering information is computed if needed, 
text is segmented into style runs fonts are chosen for style runs, first by 
using a font if the attribute (|java.awt.font.TextAttribute|) is present, 
otherwise by computing a default font using the attributes that have been 
defined if text is on multiple baselines, the runs or subruns are further 
broken into subruns sharing a common baseline, glyphvectors are generated for 
each run using the chosen font, final bidirectional reordering is performed on 
the glyphvectors 

All graphical information returned from a TextLayout object's methods is 
relative to the origin of the TextLayout, which is the intersection of the 
TextLayout object's baseline with its left edge. Also, coordinates passed into 
a TextLayout object's methods are assumed to be relative to the TextLayout 
object's origin. Clients usually need to translate between a TextLayout 
object's coordinate system and the coordinate system in another object (such as 
a Graphics(|java.awt.Graphics|) object). 

TextLayout objects are constructed from styled text, but they do not retain a 
reference to their source text. Thus, changes in the text previously used to 
generate a TextLayout do not affect the TextLayout. 

Three methods on a TextLayout object (getNextRightHit, getNextLeftHit, and 
hitTestChar) return instances of (|java.awt.font.TextHitInfo|) . The offsets 
contained in these TextHitInfo objects are relative to the start of the 
TextLayout, not to the text used to create the TextLayout. Similarly, 
TextLayout methods that accept TextHitInfo instances as parameters expect the 
TextHitInfo object's offsets to be relative to the TextLayout, not to any 
underlying text storage model. 

Examples: Constructing and drawing a TextLayout and its bounding rectangle: 

Graphics2D g = ...; Point2D loc = ...; Font font = 
Font.getFont("Helvetica-bold-italic"); FontRenderContext frc = 
g.getFontRenderContext(); TextLayout layout = new TextLayout("This is a 
string", font, frc); layout.draw(g, (float)loc.getX(), (float)loc.getY()); 

Rectangle2D bounds = layout.getBounds(); 
bounds.setRect(bounds.getX()+loc.getX(), bounds.getY()+loc.getY(), 
bounds.getWidth(), bounds.getHeight()); g.draw(bounds); 



Hit-testing a TextLayout (determining which character is at a particular 
graphical location): 

Point2D click = ...; TextHitInfo hit = layout.hitTestChar( (float) 
(click.getX() - loc.getX()), (float) (click.getY() - loc.getY())); 



Responding to a right-arrow key press: 

int insertionIndex = ...; TextHitInfo next = 
layout.getNextRightHit(insertionIndex); if (next != null) { // translate 
graphics to origin of layout on screen g.translate(loc.getX(), loc.getY()); 
Shape[] carets = layout.getCaretShapes(next.getInsertionIndex()); 
g.draw(carets[0]); if (carets[1] != null) { g.draw(carets[1]); } } 

Drawing a selection range corresponding to a substring in the source text. The 
selected area may not be visually contiguous: 

// selStart, selLimit should be relative to the layout, // not to the source 
text 

int selStart = ..., selLimit = ...; Color selectionColor = ...; Shape selection 
= layout.getLogicalHighlightShape(selStart, selLimit); // selection may consist 
of disjoint areas // graphics is assumed to be tranlated to origin of layout 
g.setColor(selectionColor); g.fill(selection); 

Drawing a visually contiguous selection range. The selection range may 
correspond to more than one substring in the source text. The ranges of the 
corresponding source text substrings can be obtained with 
getLogicalRangesForVisualSelection(): 

TextHitInfo selStart = ..., selLimit = ...; Shape selection = 
layout.getVisualHighlightShape(selStart, selLimit); g.setColor(selectionColor); 
g.fill(selection); int[] ranges = getLogicalRangesForVisualSelection(selStart, 
selLimit); // ranges[0], ranges[1] is the first selection range, // ranges[2], 
ranges[3] is the second selection range, etc. 





*java.awt.font.TextLayout(AttributedCharacterIterator,FontRenderContext)*

public TextLayout(
  java.text.AttributedCharacterIterator text,
  java.awt.font.FontRenderContext frc)

Constructs a TextLayout from an iterator over styled text. 

The iterator must specify a single paragraph of text because an entire 
paragraph is required for the bidirectional algorithm. 

    text - the styled text to display 
    frc - contains information about a graphics device which is needed to measure the 
       text correctly. Text measurements can vary slightly depending on the 
       device resolution, and attributes such as antialiasing. This parameter 
       does not specify a translation between the TextLayout and user space. 

*java.awt.font.TextLayout(String,Font,FontRenderContext)*

public TextLayout(
  java.lang.String string,
  java.awt.Font font,
  java.awt.font.FontRenderContext frc)

Constructs a TextLayout from a String and a (|java.awt.Font|) . All the text is 
styled using the specified Font. 

The String must specify a single paragraph of text, because an entire paragraph 
is required for the bidirectional algorithm. 

    string - the text to display 
    font - a Font used to style the text 
    frc - contains information about a graphics device which is needed to measure the 
       text correctly. Text measurements can vary slightly depending on the 
       device resolution, and attributes such as antialiasing. This parameter 
       does not specify a translation between the TextLayout and user space. 

*java.awt.font.TextLayout(String,Map,FontRenderContext)*

public TextLayout(
  java.lang.String string,
  java.util.Map attributes,
  java.awt.font.FontRenderContext frc)

Constructs a TextLayout from a String and an attribute set. 

All the text is styled using the provided attributes. 

string must specify a single paragraph of text because an entire paragraph is 
required for the bidirectional algorithm. 

    string - the text to display 
    attributes - the attributes used to style the text 
    frc - contains information about a graphics device which is needed to measure the 
       text correctly. Text measurements can vary slightly depending on the 
       device resolution, and attributes such as antialiasing. This parameter 
       does not specify a translation between the TextLayout and user space. 

*java.awt.font.TextLayout.clone()*

protected |java.lang.Object| clone()

Creates a copy of this TextLayout. 


*java.awt.font.TextLayout.draw(Graphics2D,float,float)*

public void draw(
  java.awt.Graphics2D g2,
  float x,
  float y)

Renders this TextLayout at the specified location in the specified 
Graphics2D(|java.awt.Graphics2D|) context. The origin of the layout is placed 
at x,y. Rendering may touch any point within getBounds() of this position. This 
leaves the g2 unchanged. 

    g2 - the Graphics2D context into which to render the layout 
    x,&nbsp;y - the coordinates of the origin of this TextLayout 

*java.awt.font.TextLayout.equals(Object)*

public boolean equals(java.lang.Object obj)

Returns true if the specified Object is a TextLayout object and if the 
specified Object equals this TextLayout. 

    obj - an Object to test for equality 

    Returns: true if the specified Object equals this TextLayout; false otherwise. 
*java.awt.font.TextLayout.equals(TextLayout)*

public boolean equals(java.awt.font.TextLayout rhs)

Returns true if the two layouts are equal. Two layouts are equal if they 
contain equal glyphvectors in the same order. 

    rhs - the TextLayout to compare to this TextLayout 

    Returns: true if the specified TextLayout equals this TextLayout. 
*java.awt.font.TextLayout.getAdvance()*

public float getAdvance()

Returns the advance of this TextLayout. The advance is the distance from the 
origin to the advance of the rightmost (bottommost) character measuring in the 
line direction. 


    Returns: the advance of this TextLayout. 
*java.awt.font.TextLayout.getAscent()*

public float getAscent()

Returns the ascent of this TextLayout. The ascent is the distance from the top 
(right) of the TextLayout to the baseline. It is always either positive or 
zero. The ascent is sufficient to accomodate superscripted text and is the 
maximum of the sum of the ascent, offset, and baseline of each glyph. 


    Returns: the ascent of this TextLayout. 
*java.awt.font.TextLayout.getBaseline()*

public byte getBaseline()

Returns the baseline for this TextLayout. The baseline is one of the values 
defined in Font, which are roman, centered and hanging. Ascent and descent are 
relative to this baseline. The baselineOffsets are also relative to this 
baseline. 


    Returns: the baseline of this TextLayout. 
*java.awt.font.TextLayout.getBaselineOffsets()*

public float getBaselineOffsets()

Returns the offsets array for the baselines used for this TextLayout. 

The array is indexed by one of the values defined in Font, which are roman, 
centered and hanging. The values are relative to this TextLayout object's 
baseline, so that getBaselineOffsets[getBaseline()] == 0. Offsets are added to 
the position of the TextLayout object's baseline to get the position for the 
new baseline. 


    Returns: the offsets array containing the baselines used for this TextLayout. 
*java.awt.font.TextLayout.getBlackBoxBounds(int,int)*

public |java.awt.Shape| getBlackBoxBounds(
  int firstEndpoint,
  int secondEndpoint)

Returns the black box bounds of the characters in the specified range. The 
black box bounds is an area consisting of the union of the bounding boxes of 
all the glyphs corresponding to the characters between start and limit. This 
path may be disjoint. 

    firstEndpoint - one end of the character range 
    secondEndpoint - the other end of the character range. Can be less than firstEndpoint. 

    Returns: a path enclosing the black box bounds. 
*java.awt.font.TextLayout.getBounds()*

public |java.awt.geom.Rectangle2D| getBounds()

Returns the bounds of this TextLayout. The bounds contains all of the pixels 
the TextLayout can draw. It might not coincide exactly with the ascent, 
descent, origin or advance of the TextLayout. 


    Returns: a {@link Rectangle2D} that is the bounds of this TextLayout. 
*java.awt.font.TextLayout.getCaretInfo(TextHitInfo)*

public float getCaretInfo(java.awt.font.TextHitInfo hit)

Returns information about the caret corresponding to hit. This method is a 
convenience overload of getCaretInfo and uses the natural bounds of this 
TextLayout. 

    hit - a hit on a character in this TextLayout 

    Returns: the information about a caret corresponding to a hit. 
*java.awt.font.TextLayout.getCaretInfo(TextHitInfo,Rectangle2D)*

public float getCaretInfo(
  java.awt.font.TextHitInfo hit,
  java.awt.geom.Rectangle2D bounds)

Returns information about the caret corresponding to hit. The first element of 
the array is the intersection of the caret with the baseline. The second 
element of the array is the inverse slope (run/rise) of the caret. 

This method is meant for informational use. To display carets, it is better to 
use getCaretShapes. 

    hit - a hit on a character in this TextLayout 
    bounds - the bounds to which the caret info is constructed 

    Returns: a two-element array containing the position and slope of the caret. 
*java.awt.font.TextLayout.getCaretShape(TextHitInfo)*

public |java.awt.Shape| getCaretShape(java.awt.font.TextHitInfo hit)

Returns a Shape representing the caret at the specified hit inside the natural 
bounds of this TextLayout. 

    hit - the hit at which to generate the caret 

    Returns: a Shape representing the caret. 
*java.awt.font.TextLayout.getCaretShape(TextHitInfo,Rectangle2D)*

public |java.awt.Shape| getCaretShape(
  java.awt.font.TextHitInfo hit,
  java.awt.geom.Rectangle2D bounds)

Returns a (|java.awt.Shape|) representing the caret at the specified hit inside 
the specified bounds. 

    hit - the hit at which to generate the caret 
    bounds - the bounds of the TextLayout to use in generating the caret. 

    Returns: a Shape representing the caret. 
*java.awt.font.TextLayout.getCaretShapes(int)*

public |java.awt.Shape| getCaretShapes(int offset)

Returns two paths corresponding to the strong and weak caret. This method is a 
convenience overload of getCaretShapes that uses the default caret policy and 
this TextLayout object's natural bounds. 

    offset - an offset in this TextLayout 

    Returns: two paths corresponding to the strong and weak caret as defined by the 
             DEFAULT_CARET_POLICY 
*java.awt.font.TextLayout.getCaretShapes(int,Rectangle2D)*

public |java.awt.Shape| getCaretShapes(
  int offset,
  java.awt.geom.Rectangle2D bounds)

Returns two paths corresponding to the strong and weak caret. This method is a 
convenience overload of getCaretShapes that uses the default caret policy. 

    offset - an offset in this TextLayout 
    bounds - the bounds to which to extend the carets 

    Returns: two paths corresponding to the strong and weak caret as defined by the 
             DEFAULT_CARET_POLICY 
*java.awt.font.TextLayout.getCaretShapes(int,Rectangle2D,TextLayout.CaretPolicy)*

public |java.awt.Shape| getCaretShapes(
  int offset,
  java.awt.geom.Rectangle2D bounds,
  java.awt.font.TextLayout.CaretPolicy policy)

Returns two paths corresponding to the strong and weak caret. 

    offset - an offset in this TextLayout 
    bounds - the bounds to which to extend the carets 
    policy - the specified CaretPolicy 

    Returns: an array of two paths. Element zero is the strong caret. If there are two 
             carets, element one is the weak caret, otherwise it is null. 
*java.awt.font.TextLayout.getCharacterCount()*

public int getCharacterCount()

Returns the number of characters represented by this TextLayout. 


    Returns: the number of characters in this TextLayout. 
*java.awt.font.TextLayout.getCharacterLevel(int)*

public byte getCharacterLevel(int index)

Returns the level of the character at index. Indices -1 and characterCount are 
assigned the base level of this TextLayout. 

    index - the index of the character from which to get the level 

    Returns: the level of the character at the specified index. 
*java.awt.font.TextLayout.getDescent()*

public float getDescent()

Returns the descent of this TextLayout. The descent is the distance from the 
baseline to the bottom (left) of the TextLayout. It is always either positive 
or zero. The descent is sufficient to accomodate subscripted text and is the 
maximum of the sum of the descent, offset, and baseline of each glyph. 


    Returns: the descent of this TextLayout. 
*java.awt.font.TextLayout.getJustifiedLayout(float)*

public |java.awt.font.TextLayout| getJustifiedLayout(float justificationWidth)

Creates a copy of this TextLayout justified to the specified width. 

If this TextLayout has already been justified, an exception is thrown. If this 
TextLayout object's justification ratio is zero, a TextLayout identical to this 
TextLayout is returned. 

    justificationWidth - the width to use when justifying the line. For best results, it should not be 
       too different from the current advance of the line. 

    Returns: a TextLayout justified to the specified width. 
*java.awt.font.TextLayout.getLeading()*

public float getLeading()

Returns the leading of the TextLayout. The leading is the suggested interline 
spacing for this TextLayout. 

The leading is computed from the leading, descent, and baseline of all 
glyphvectors in the TextLayout. The algorithm is roughly as follows: 

maxD = 0; maxDL = 0; for (GlyphVector g in all glyphvectors) { maxD = max(maxD, 
g.getDescent() + offsets[g.getBaseline()]); maxDL = max(maxDL, g.getDescent() + 
g.getLeading() + offsets[g.getBaseline()]); } return maxDL - maxD; 


    Returns: the leading of this TextLayout. 
*java.awt.font.TextLayout.getLogicalHighlightShape(int,int)*

public |java.awt.Shape| getLogicalHighlightShape(
  int firstEndpoint,
  int secondEndpoint)

Returns a Shape enclosing the logical selection in the specified range, 
extended to the natural bounds of this TextLayout. This method is a convenience 
overload of getLogicalHighlightShape that uses the natural bounds of this 
TextLayout. 

    firstEndpoint - an endpoint in the range of characters to select 
    secondEndpoint - the other endpoint of the range of characters to select. Can be less than 
       firstEndpoint. The range includes the character at min(firstEndpoint, 
       secondEndpoint), but excludes max(firstEndpoint, secondEndpoint). 

    Returns: a Shape enclosing the selection. 
*java.awt.font.TextLayout.getLogicalHighlightShape(int,int,Rectangle2D)*

public |java.awt.Shape| getLogicalHighlightShape(
  int firstEndpoint,
  int secondEndpoint,
  java.awt.geom.Rectangle2D bounds)

Returns a Shape enclosing the logical selection in the specified range, 
extended to the specified bounds. 

If the selection range includes the first logical character, the selection is 
extended to the portion of bounds before the start of this TextLayout. If the 
range includes the last logical character, the selection is extended to the 
portion of bounds after the end of this TextLayout. The height (width on 
vertical lines) of the selection is always extended to bounds. 

The selection can be discontiguous on lines with mixed-direction text. Only 
those characters in the logical range between start and limit appear selected. 
For example, consider the text 'ABCdef' where capital letters indicate 
right-to-left text, rendered on a right-to-left line, with a logical selection 
from 0 to 4 ('ABCd'). The text appears as follows, with bold standing in for 
the selection, and underlining for the extension: 

defCBA 

The selection is discontiguous because the selected characters are visually 
discontiguous. Also note that since the range includes the first logical 
character (A), the selection is extended to the portion of the bounds before 
the start of the layout, which in this case (a right-to-left line) is the right 
portion of the bounds. 

    firstEndpoint - an endpoint in the range of characters to select 
    secondEndpoint - the other endpoint of the range of characters to select. Can be less than 
       firstEndpoint. The range includes the character at min(firstEndpoint, 
       secondEndpoint), but excludes max(firstEndpoint, secondEndpoint). 
    bounds - the bounding rectangle to which to extend the selection 

    Returns: an area enclosing the selection. 
*java.awt.font.TextLayout.getLogicalRangesForVisualSelection(TextHitInfo,TextHitInfo)*

public int getLogicalRangesForVisualSelection(
  java.awt.font.TextHitInfo firstEndpoint,
  java.awt.font.TextHitInfo secondEndpoint)

Returns the logical ranges of text corresponding to a visual selection. 

    firstEndpoint - an endpoint of the visual range 
    secondEndpoint - the other endpoint of the visual range. This endpoint can be less than 
       firstEndpoint. 

    Returns: an array of integers representing start/limit pairs for the selected ranges. 
*java.awt.font.TextLayout.getNextLeftHit(int)*

public |java.awt.font.TextHitInfo| getNextLeftHit(int offset)

Returns the hit for the next caret to the left (top); if no such hit, returns 
null. The hit is to the left of the strong caret at the specified offset, as 
determined by the default policy. The returned hit is the stronger of the two 
possible hits, as determined by the default policy. 

    offset - an insertion offset in this TextLayout. Cannot be less than 0 or greater than 
       this TextLayout object's character count. 

    Returns: a hit whose caret appears at the next position to the left (top) of the caret 
             of the provided hit, or null. 
*java.awt.font.TextLayout.getNextLeftHit(int,TextLayout.CaretPolicy)*

public |java.awt.font.TextHitInfo| getNextLeftHit(
  int offset,
  java.awt.font.TextLayout.CaretPolicy policy)

Returns the hit for the next caret to the left (top); if no such hit, returns 
null. The hit is to the left of the strong caret at the specified offset, as 
determined by the specified policy. The returned hit is the stronger of the two 
possible hits, as determined by the specified policy. 

    offset - an insertion offset in this TextLayout. Cannot be less than 0 or greater than 
       this TextLayout object's character count. 
    policy - the policy used to select the strong caret 

    Returns: a hit whose caret appears at the next position to the left (top) of the caret 
             of the provided hit, or null. 
*java.awt.font.TextLayout.getNextLeftHit(TextHitInfo)*

public |java.awt.font.TextHitInfo| getNextLeftHit(java.awt.font.TextHitInfo hit)

Returns the hit for the next caret to the left (top); if no such hit, returns 
null. If the hit character index is out of bounds, an IllegalArgumentException 
is thrown. 

    hit - a hit on a character in this TextLayout. 

    Returns: a hit whose caret appears at the next position to the left (top) of the caret 
             of the provided hit, or null. 
*java.awt.font.TextLayout.getNextRightHit(int)*

public |java.awt.font.TextHitInfo| getNextRightHit(int offset)

Returns the hit for the next caret to the right (bottom); if no such hit, 
returns null. The hit is to the right of the strong caret at the specified 
offset, as determined by the default policy. The returned hit is the stronger 
of the two possible hits, as determined by the default policy. 

    offset - an insertion offset in this TextLayout. Cannot be less than 0 or greater than 
       the TextLayout object's character count. 

    Returns: a hit whose caret appears at the next position to the right (bottom) of the 
             caret of the provided hit, or null. 
*java.awt.font.TextLayout.getNextRightHit(int,TextLayout.CaretPolicy)*

public |java.awt.font.TextHitInfo| getNextRightHit(
  int offset,
  java.awt.font.TextLayout.CaretPolicy policy)

Returns the hit for the next caret to the right (bottom); if no such hit, 
returns null. The hit is to the right of the strong caret at the specified 
offset, as determined by the specified policy. The returned hit is the stronger 
of the two possible hits, as determined by the specified policy. 

    offset - an insertion offset in this TextLayout. Cannot be less than 0 or greater than 
       this TextLayout object's character count. 
    policy - the policy used to select the strong caret 

    Returns: a hit whose caret appears at the next position to the right (bottom) of the 
             caret of the provided hit, or null. 
*java.awt.font.TextLayout.getNextRightHit(TextHitInfo)*

public |java.awt.font.TextHitInfo| getNextRightHit(java.awt.font.TextHitInfo hit)

Returns the hit for the next caret to the right (bottom); if there is no such 
hit, returns null. If the hit character index is out of bounds, an 
(|java.lang.IllegalArgumentException|) is thrown. 

    hit - a hit on a character in this layout 

    Returns: a hit whose caret appears at the next position to the right (bottom) of the 
             caret of the provided hit or null. 
*java.awt.font.TextLayout.getOutline(AffineTransform)*

public |java.awt.Shape| getOutline(java.awt.geom.AffineTransform tx)

Returns a Shape representing the outline of this TextLayout. 

    tx - an optional {@link AffineTransform} to apply to the outline of this TextLayout. 

    Returns: a Shape that is the outline of this TextLayout. 
*java.awt.font.TextLayout.getVisibleAdvance()*

public float getVisibleAdvance()

Returns the advance of this TextLayout, minus trailing whitespace. 


    Returns: the advance of this TextLayout without the trailing whitespace. 
*java.awt.font.TextLayout.getVisualHighlightShape(TextHitInfo,TextHitInfo)*

public |java.awt.Shape| getVisualHighlightShape(
  java.awt.font.TextHitInfo firstEndpoint,
  java.awt.font.TextHitInfo secondEndpoint)

Returns a Shape enclosing the visual selection in the specified range, extended 
to the bounds. This method is a convenience overload of getVisualHighlightShape 
that uses the natural bounds of this TextLayout. 

    firstEndpoint - one end of the visual selection 
    secondEndpoint - the other end of the visual selection 

    Returns: a Shape enclosing the selection. 
*java.awt.font.TextLayout.getVisualHighlightShape(TextHitInfo,TextHitInfo,Rectangle2D)*

public |java.awt.Shape| getVisualHighlightShape(
  java.awt.font.TextHitInfo firstEndpoint,
  java.awt.font.TextHitInfo secondEndpoint,
  java.awt.geom.Rectangle2D bounds)

Returns a path enclosing the visual selection in the specified range, extended 
to bounds. 

If the selection includes the leftmost (topmost) position, the selection is 
extended to the left (top) of bounds. If the selection includes the rightmost 
(bottommost) position, the selection is extended to the right (bottom) of the 
bounds. The height (width on vertical lines) of the selection is always 
extended to bounds. 

Although the selection is always contiguous, the logically selected text can be 
discontiguous on lines with mixed-direction text. The logical ranges of text 
selected can be retrieved using getLogicalRangesForVisualSelection. For 
example, consider the text 'ABCdef' where capital letters indicate 
right-to-left text, rendered on a right-to-left line, with a visual selection 
from 0L (the leading edge of 'A') to 3T (the trailing edge of 'd'). The text 
appears as follows, with bold underlined areas representing the selection: 

defCBA 

The logical selection ranges are 0-3, 4-6 (ABC, ef) because the visually 
contiguous text is logically discontiguous. Also note that since the rightmost 
position on the layout (to the right of 'A') is selected, the selection is 
extended to the right of the bounds. 

    firstEndpoint - one end of the visual selection 
    secondEndpoint - the other end of the visual selection 
    bounds - the bounding rectangle to which to extend the selection 

    Returns: a Shape enclosing the selection. 
*java.awt.font.TextLayout.getVisualOtherHit(TextHitInfo)*

public |java.awt.font.TextHitInfo| getVisualOtherHit(java.awt.font.TextHitInfo hit)

Returns the hit on the opposite side of the specified hit's caret. 

    hit - the specified hit 

    Returns: a hit that is on the opposite side of the specified hit's caret. 
*java.awt.font.TextLayout.handleJustify(float)*

protected void handleJustify(float justificationWidth)

Justify this layout. Overridden by subclassers to control justification (if 
there were subclassers, that is...) 

The layout will only justify if the paragraph attributes (from the source text, 
possibly defaulted by the layout attributes) indicate a non-zero justification 
ratio. The text will be justified to the indicated width. The current 
implementation also adjusts hanging punctuation and trailing whitespace to 
overhang the justification width. Once justified, the layout may not be 
rejustified. 

Some code may rely on immutablity of layouts. Subclassers should not call this 
directly, but instead should call getJustifiedLayout, which will call this 
method on a clone of this layout, preserving the original. 

    justificationWidth - the width to use when justifying the line. For best results, it should not be 
       too different from the current advance of the line. 

*java.awt.font.TextLayout.hashCode()*

public int hashCode()

Returns the hash code of this TextLayout. 


    Returns: the hash code of this TextLayout. 
*java.awt.font.TextLayout.hitTestChar(float,float)*

public |java.awt.font.TextHitInfo| hitTestChar(
  float x,
  float y)

Returns a TextHitInfo corresponding to the specified point. This method is a 
convenience overload of hitTestChar that uses the natural bounds of this 
TextLayout. 

    x - the x offset from the origin of this TextLayout 
    y - the y offset from the origin of this TextLayout 

    Returns: a hit describing the character and edge (leading or trailing) under the 
             specified point. 
*java.awt.font.TextLayout.hitTestChar(float,float,Rectangle2D)*

public |java.awt.font.TextHitInfo| hitTestChar(
  float x,
  float y,
  java.awt.geom.Rectangle2D bounds)

Returns a TextHitInfo corresponding to the specified point. Coordinates outside 
the bounds of the TextLayout map to hits on the leading edge of the first 
logical character, or the trailing edge of the last logical character, as 
appropriate, regardless of the position of that character in the line. Only the 
direction along the baseline is used to make this evaluation. 

    x - the x offset from the origin of this TextLayout 
    y - the y offset from the origin of this TextLayout 
    bounds - the bounds of the TextLayout 

    Returns: a hit describing the character and edge (leading or trailing) under the 
             specified point. 
*java.awt.font.TextLayout.isLeftToRight()*

public boolean isLeftToRight()

Returns true if this TextLayout has a left-to-right base direction or false if 
it has a right-to-left base direction. The TextLayout has a base direction of 
either left-to-right (LTR) or right-to-left (RTL). The base direction is 
independent of the actual direction of text on the line, which may be either 
LTR, RTL, or mixed. Left-to-right layouts by default should position flush 
left. If the layout is on a tabbed line, the tabs run left to right, so that 
logically successive layouts position left to right. The opposite is true for 
RTL layouts. By default they should position flush left, and tabs run 
right-to-left. 


    Returns: true if the base direction of this TextLayout is left-to-right; false 
             otherwise. 
*java.awt.font.TextLayout.isVertical()*

public boolean isVertical()

Returns true if this TextLayout is vertical. 


    Returns: true if this TextLayout is vertical; false otherwise. 
*java.awt.font.TextLayout.toString()*

public |java.lang.String| toString()

Returns debugging information for this TextLayout. 


    Returns: the textLine of this TextLayout as a String. 

